{"version":2,"sessionId":"f2e62d2c-77c9-4883-ab60-40b4656f2b16","initialFileContents":[["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","a7dfefc"],["file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","09f8166"],["file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","cc74f85"],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","fe5a182"]],"timeline":{"checkpoints":[{"checkpointId":"088fb3b9-f94b-4070-9952-2d01e6b00292","epoch":0,"label":"Initial State","description":"Starting point before any edits"},{"checkpointId":"c5f1341a-d2c1-42f2-9c47-8d037798691a","requestId":"request_be3612f3-7d33-4e8e-bf97-d400707bbafa","epoch":1,"label":"Request request_be3612f3-7d33-4e8e-bf97-d400707bbafa"},{"checkpointId":"be671654-7223-4b3a-8901-d6dca9aa2d98","requestId":"request_be3612f3-7d33-4e8e-bf97-d400707bbafa","undoStopId":"6ea8e526-bf3c-4883-a1d4-a147ff1435e7","epoch":2,"label":"Request request_be3612f3-7d33-4e8e-bf97-d400707bbafa - Stop 6ea8e526-bf3c-4883-a1d4-a147ff1435e7"},{"checkpointId":"da3a0fd3-04d4-4271-8947-67c741d21ddd","requestId":"request_d16c5c0d-5152-4eae-9afa-632c2336b503","epoch":5,"label":"Request request_d16c5c0d-5152-4eae-9afa-632c2336b503"},{"checkpointId":"da9b8737-685f-44a4-a374-6febb735835f","requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","epoch":6,"label":"Request request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7"},{"checkpointId":"6fcb097f-045a-4a02-acf5-42601373c5f4","requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","undoStopId":"637d8a8d-0769-4ba6-b884-5812380dc891","epoch":7,"label":"Request request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7 - Stop 637d8a8d-0769-4ba6-b884-5812380dc891"},{"checkpointId":"636ca6ad-9971-4781-9816-63457e3735c1","requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","undoStopId":"13c3b494-b0f0-45c3-bd6d-fa3252b92523","epoch":10,"label":"Request request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7 - Stop 13c3b494-b0f0-45c3-bd6d-fa3252b92523"},{"checkpointId":"4851a3f8-6bec-498f-b239-915b1aac09be","requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","epoch":12,"label":"Request request_d7699234-21c0-49d5-8d4d-c7776a74afdc"},{"checkpointId":"da28cdf0-6267-4bf5-bc72-55d10e966e45","requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","undoStopId":"7fd7aac5-f84f-4995-9e10-f546fce77853","epoch":13,"label":"Request request_d7699234-21c0-49d5-8d4d-c7776a74afdc - Stop 7fd7aac5-f84f-4995-9e10-f546fce77853"},{"checkpointId":"7f0cbb55-7b27-43c8-9c1a-40f11c4c4db2","requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","undoStopId":"0129656f-4eeb-499d-9c5d-e0a23cb973db","epoch":16,"label":"Request request_d7699234-21c0-49d5-8d4d-c7776a74afdc - Stop 0129656f-4eeb-499d-9c5d-e0a23cb973db"},{"checkpointId":"b2b73ebd-7f7a-4609-b203-ffd06056593d","requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","undoStopId":"197367b8-f197-4169-a1df-232542fbbede","epoch":18,"label":"Request request_d7699234-21c0-49d5-8d4d-c7776a74afdc - Stop 197367b8-f197-4169-a1df-232542fbbede"},{"checkpointId":"3705bf4e-6332-4ed5-a592-02b1caa1e7fe","requestId":"request_37f8630f-7ce8-4c24-bbc9-c953b3a9f7f5","epoch":20,"label":"Request request_37f8630f-7ce8-4c24-bbc9-c953b3a9f7f5"},{"checkpointId":"44c407bb-b3cd-4355-bc37-b58bd87323df","requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","epoch":21,"label":"Request request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d"},{"checkpointId":"52370d8d-e1dd-4c8c-aa38-ef5364e0c36c","requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","undoStopId":"2af9aa79-8187-4cb7-a17f-fadf9324090b","epoch":22,"label":"Request request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d - Stop 2af9aa79-8187-4cb7-a17f-fadf9324090b"},{"checkpointId":"a477d313-8dc9-42cb-a463-b6407268fe43","requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","undoStopId":"c47336ad-c458-434a-b121-335a66141902","epoch":25,"label":"Request request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d - Stop c47336ad-c458-434a-b121-335a66141902"},{"checkpointId":"3b50e6d4-ee94-43de-8982-cb70b5cae6fc","requestId":"request_bddfb2ab-dc09-4ed4-8c50-3bba87d11d28","epoch":27,"label":"Request request_bddfb2ab-dc09-4ed4-8c50-3bba87d11d28"},{"checkpointId":"f3a7d1a3-282c-405d-8843-ca54a5fc65ed","requestId":"request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2","epoch":30,"label":"Request request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2"},{"checkpointId":"a40dccbb-6872-4a26-bd3d-6be03bc5e9ac","requestId":"request_49631ab7-9ad2-4700-9e9e-b32efabc7177","epoch":33,"label":"Request request_49631ab7-9ad2-4700-9e9e-b32efabc7177"},{"checkpointId":"987e6ecc-374b-45f3-ac24-a77f28929e4a","requestId":"request_8896403a-6894-4396-a058-b17b1b1499e7","epoch":37,"label":"Request request_8896403a-6894-4396-a058-b17b1b1499e7"},{"checkpointId":"90b9e95b-e5c3-4c1a-9338-ab9b2ef76bc5","requestId":"request_b054dee5-2ef3-417c-a8ac-7d662a467283","epoch":40,"label":"Request request_b054dee5-2ef3-417c-a8ac-7d662a467283"},{"checkpointId":"cb24026d-883c-45ee-aa27-637e5fff7ea3","requestId":"request_6f8bada3-b098-4c51-b0b2-727bb015575a","epoch":43,"label":"Request request_6f8bada3-b098-4c51-b0b2-727bb015575a"},{"checkpointId":"c9ff272c-780d-4d3c-85ea-2816d850f1d2","requestId":"request_9d1a734f-1fb3-4999-b7bb-8a28cceeb48e","epoch":44,"label":"Request request_9d1a734f-1fb3-4999-b7bb-8a28cceeb48e"},{"checkpointId":"373f7b73-9817-46e4-9268-e6b516b4a039","requestId":"request_269d5b27-8e89-438c-bbb8-63b3245733cb","epoch":47,"label":"Request request_269d5b27-8e89-438c-bbb8-63b3245733cb"},{"checkpointId":"ab519ccf-a9cc-4f63-bb2f-1a1faf69f211","requestId":"request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0","epoch":50,"label":"Request request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0"},{"checkpointId":"999b6a30-5312-4644-b22a-dd34bbee0578","requestId":"request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0","undoStopId":"1d5fe17d-88e2-49f4-9b61-ab3ee37dc055","epoch":51,"label":"Request request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0 - Stop 1d5fe17d-88e2-49f4-9b61-ab3ee37dc055"},{"checkpointId":"3ad63ffb-4fdf-4407-b3aa-fcc348f67210","requestId":"request_12a6e73d-b33c-4750-899a-23b3790b61ab","epoch":54,"label":"Request request_12a6e73d-b33c-4750-899a-23b3790b61ab"},{"checkpointId":"668ae82e-374e-4440-9bc8-afcba49fe9a5","requestId":"request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76","epoch":58,"label":"Request request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76"},{"checkpointId":"198c1cd1-ec59-419d-be56-45b0a86fe566","requestId":"request_3676fdae-cdcc-4867-91e4-99d4b4c0f9a6","epoch":62,"label":"Request request_3676fdae-cdcc-4867-91e4-99d4b4c0f9a6"},{"checkpointId":"ab9d100e-8a5e-4834-b5a8-3666d4dd1449","requestId":"request_338f27d9-6b23-4aad-a745-773b1b4384a6","epoch":65,"label":"Request request_338f27d9-6b23-4aad-a745-773b1b4384a6"},{"checkpointId":"db20c36b-2874-4533-a34b-3a7015729415","requestId":"request_b9b1f611-e696-4e64-83e5-44d8a486ea4f","epoch":68,"label":"Request request_b9b1f611-e696-4e64-83e5-44d8a486ea4f"},{"checkpointId":"38108de0-15d7-435e-8025-557bc4435818","requestId":"request_18c89704-8cd3-4be9-b079-5a7dee1a30c8","epoch":69,"label":"Request request_18c89704-8cd3-4be9-b079-5a7dee1a30c8"},{"checkpointId":"a1c8e158-a951-4c40-92bf-efdf9027fddc","requestId":"request_9d694dd5-b50c-4dd8-9cbc-d1e314dc8ebb","epoch":72,"label":"Request request_9d694dd5-b50c-4dd8-9cbc-d1e314dc8ebb"},{"checkpointId":"0ff70bac-afcb-4b78-933b-abab27e95a56","requestId":"request_668f889f-1529-48c7-a0f0-c7536b019d14","epoch":75,"label":"Request request_668f889f-1529-48c7-a0f0-c7536b019d14"},{"checkpointId":"dbed2ae6-3383-409b-b9c3-c9bb5b382249","requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":78,"label":"Request request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f"},{"checkpointId":"a6f374a2-8339-4898-aa8c-82a0692caec6","requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","undoStopId":"e89be17d-a8ae-428e-958a-9b8af8b996de","epoch":79,"label":"Request request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f - Stop e89be17d-a8ae-428e-958a-9b8af8b996de"},{"checkpointId":"0a84adfa-94bc-4015-97dd-98537001f0ff","requestId":"request_3f7988f8-035d-4978-8086-8ab93d462ba9","epoch":96,"label":"Request request_3f7988f8-035d-4978-8086-8ab93d462ba9"},{"checkpointId":"ab8adc9c-c80a-48bc-b68d-2d7640e2fc7e","requestId":"request_ab239e5c-3640-4e58-99d5-329005c0207e","epoch":97,"label":"Request request_ab239e5c-3640-4e58-99d5-329005c0207e"},{"checkpointId":"c37170b2-c480-45cb-b594-1549ab19ba03","requestId":"request_ab239e5c-3640-4e58-99d5-329005c0207e","undoStopId":"8577bcc5-b3f3-46f0-8798-daa70ede5e92","epoch":98,"label":"Request request_ab239e5c-3640-4e58-99d5-329005c0207e - Stop 8577bcc5-b3f3-46f0-8798-daa70ede5e92"},{"checkpointId":"c60c08f5-3d06-487d-b24e-5af0ec5d5477","requestId":"request_f8485595-2b79-45f6-93d4-e89dfd54ca67","epoch":101,"label":"Request request_f8485595-2b79-45f6-93d4-e89dfd54ca67"},{"checkpointId":"46f34bee-c97c-4f4b-be99-a00bb41a0b6f","requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":102,"label":"Request request_926b3694-cc27-4bf4-b344-24aa1dcd8cee"},{"checkpointId":"85e8915f-417a-4f93-986c-7a89a0c0d52b","requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","undoStopId":"7c209a6d-5364-46a0-a899-4b7825e20c2a","epoch":103,"label":"Request request_926b3694-cc27-4bf4-b344-24aa1dcd8cee - Stop 7c209a6d-5364-46a0-a899-4b7825e20c2a"},{"checkpointId":"74289c99-b236-474e-b357-29378986b350","requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","undoStopId":"5b2e2928-2b6d-4411-8448-d88dc0de0f73","epoch":106,"label":"Request request_926b3694-cc27-4bf4-b344-24aa1dcd8cee - Stop 5b2e2928-2b6d-4411-8448-d88dc0de0f73"},{"checkpointId":"0d064d12-034f-43b7-b2bb-1ce4bf2a418b","requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","undoStopId":"d719a717-1135-421c-b5a9-693748f1b136","epoch":109,"label":"Request request_926b3694-cc27-4bf4-b344-24aa1dcd8cee - Stop d719a717-1135-421c-b5a9-693748f1b136"},{"checkpointId":"3faf8ad6-3619-447f-bd0f-81a15c9ea336","requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":115,"label":"Request request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8"},{"checkpointId":"e706eeba-6397-4979-858d-6e20cd1f540e","requestId":"request_7d982c0d-9823-4c23-a284-aadfadd67288","epoch":122,"label":"Request request_7d982c0d-9823-4c23-a284-aadfadd67288"},{"checkpointId":"a023fea6-9d1c-4ea2-9a07-1d569393153e","requestId":"request_902d9085-b309-44eb-85dd-8462bbdde193","epoch":123,"label":"Request request_902d9085-b309-44eb-85dd-8462bbdde193"},{"checkpointId":"3a03ea0c-433c-4fd9-a9e4-4d3d718eb05f","requestId":"request_dec7a56d-2ccc-48a9-b2e3-3d5e8a694801","epoch":124,"label":"Request request_dec7a56d-2ccc-48a9-b2e3-3d5e8a694801"},{"checkpointId":"9f791431-a35a-4002-ab50-14490b5c9f9e","requestId":"request_dfeec41f-c3c5-4c87-9cf3-cd7f92c4f118","epoch":125,"label":"Request request_dfeec41f-c3c5-4c87-9cf3-cd7f92c4f118"},{"checkpointId":"da0a6308-20ff-44e3-8aa9-33525817dc92","requestId":"request_ccab1dff-5727-436a-a3ae-344ce2122d29","epoch":126,"label":"Request request_ccab1dff-5727-436a-a3ae-344ce2122d29"},{"checkpointId":"75c5b684-2e08-4b9a-9570-4d39934708ce","requestId":"request_e23a538c-2870-479a-84f5-cfacced903cb","epoch":127,"label":"Request request_e23a538c-2870-479a-84f5-cfacced903cb"},{"checkpointId":"8e4582df-f1b0-4303-b402-18c4ad295fee","requestId":"request_a0180ac0-a311-45b0-a410-0c59c959ef7b","epoch":128,"label":"Request request_a0180ac0-a311-45b0-a410-0c59c959ef7b"},{"checkpointId":"6ed2da2e-6e1f-4f32-9a7e-988d4cda21f1","requestId":"request_78e22980-ef21-4299-a996-6b61e18fe6d5","epoch":129,"label":"Request request_78e22980-ef21-4299-a996-6b61e18fe6d5"},{"checkpointId":"444c0be3-6f6c-4c27-ab71-2d14a5a4f58f","requestId":"request_20e39536-1b4c-47b0-8dee-a2153e44b27d","epoch":130,"label":"Request request_20e39536-1b4c-47b0-8dee-a2153e44b27d"},{"checkpointId":"c3088837-cf46-401c-ab29-7a1bfa2e2db9","requestId":"request_411ab292-5756-487f-8aa8-328dd69ca5e8","epoch":131,"label":"Request request_411ab292-5756-487f-8aa8-328dd69ca5e8"},{"checkpointId":"08f8dd62-4e2f-4c20-9da4-07d26969ba22","requestId":"request_411ab292-5756-487f-8aa8-328dd69ca5e8","undoStopId":"b25b0d7c-c94c-4495-8f62-21a247fcd03e","epoch":132,"label":"Request request_411ab292-5756-487f-8aa8-328dd69ca5e8 - Stop b25b0d7c-c94c-4495-8f62-21a247fcd03e"}],"currentEpoch":135,"fileBaselines":[["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_be3612f3-7d33-4e8e-bf97-d400707bbafa",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_be3612f3-7d33-4e8e-bf97-d400707bbafa","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Validates input and stores column names.\"\"\"\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        \"\"\"Calculate expiration timestamps.\"\"\"\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        \"\"\"Helper method to compute all price targets without tail indicators\"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n\n        # Pre-calculate expiration timestamps aligned to the bar close (current_ts + 1h)\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            # SAFER REFERENCE PRICE HANDLING\n            try:\n                reference_price = row['prev_close']\n                # Handle case where reference_price might be a Series (duplicate columns)\n                if isinstance(reference_price, pd.Series):\n                    if reference_price.empty or reference_price.isna().all() or (reference_price <= 1e-9).all():\n                        continue\n                    reference_price = reference_price.iloc[0]  # Take first value\n                elif pd.isna(reference_price) or reference_price <= 1e-9:\n                    continue\n            except KeyError:\n                continue  # Skip if reference price not available\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts:\n                    continue\n\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                \n                if not prices1_h.empty:\n                    # Basic price targets\n\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n\n                    # Peak/trough timing\n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    peak_offset = (max_idx - current_bar_end).total_seconds() / 3600.0\n                    trough_offset = (min_idx - current_bar_end).total_seconds() / 3600.0\n                    results['exp1_peak_frac'] = peak_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_trough_frac'] = trough_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    # Close return\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError:\n                        pass\n                    \n                    for k, v in results.items():\n                        targets_df.at[current_ts, k] = v\n\n        return targets_df\n\n\n\n    def _calculate_absolute_expiry_targets(self, X):\n        \"\"\"\n        For each expiry window, compute the absolute peak/trough and their times.\n        Assign these to all rows in the window.\n        Also computes absolute min/max for the following expiry window (exp2).\n        \"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        prev_close = X['prev_close']\n\n        # Map each timestamp to its expiry window start and end\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp2_times = pd.Series({ts: exp[1] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0:\n                continue\n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            # Use the close from the row immediately before the window start (even if exp_start is not in index)\n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx >= 0:\n                prev_close_ts = X.index[prev_idx]\n                window_prev_close = X.loc[prev_close_ts, 'c']\n            else:\n                window_prev_close = np.nan\n\n            if window_h.empty or pd.isna(window_prev_close) or window_prev_close <= 1e-9:\n                continue\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n\n            # Absolute peak/trough and their times for expiry 1\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            abs_max_ret = (abs_max / window_prev_close) - 1.0\n            abs_min_ret = (abs_min / window_prev_close) - 1.0\n            max_idx = window_h.idxmax()\n            min_idx = window_l.idxmin()\n            window_length = (exp_end - exp_start).total_seconds() / 3600.0\n            peak_offset = (max_idx - exp_start).total_seconds() / 3600.0\n            trough_offset = (min_idx - exp_start).total_seconds() / 3600.0\n            abs_peak_frac = peak_offset / window_length if window_length > 0 else np.nan\n            abs_trough_frac = trough_offset / window_length if window_length > 0 else np.nan\n            abs_peak_hours_to_expiry = (exp_end - max_idx).total_seconds() / 3600.0\n            abs_trough_hours_to_expiry = (exp_end - min_idx).total_seconds() / 3600.0\n\n            # Absolute mean reversion targets for expiry 1\n            if not window_c.empty:\n                close_at_expiry = window_c.iloc[-1]\n                abs_peak_to_close_ret = (close_at_expiry / abs_max) - 1.0 if abs_max > 1e-9 else np.nan\n                abs_trough_to_close_ret = (close_at_expiry / abs_min) - 1.0 if abs_min > 1e-9 else np.nan\n            else:\n                abs_peak_to_close_ret = np.nan\n                abs_trough_to_close_ret = np.nan\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = abs_max_ret\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = abs_min_ret\n            abs_targets.loc[window_idx, 'abs_exp1_peak_frac'] = abs_peak_frac\n            abs_targets.loc[window_idx, 'abs_exp1_trough_frac'] = abs_trough_frac\n            abs_targets.loc[window_idx, 'abs_exp1_peak_hours_to_expiry'] = abs_peak_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_trough_hours_to_expiry'] = abs_trough_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_peak_to_close_ret'] = abs_peak_to_close_ret\n            abs_targets.loc[window_idx, 'abs_exp1_trough_to_close_ret'] = abs_trough_to_close_ret\n\n            # --- NEW: Absolute min/max for the following expiry window (exp2) ---\n            # Find exp2 window for this expiry\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_idx = timestamps[mask2]\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            window2_c = prices_c[mask2]\n\n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_exp2_max_ret = (abs_max_p2 / window_prev_close) - 1.0\n                abs_exp2_min_ret = (abs_min_p2 / window_prev_close) - 1.0\n                max2_idx = window2_h.idxmax()\n                min2_idx = window2_l.idxmin()\n                # Mean reversion for exp2\n                if not window2_c.empty:\n                    close_at_expiry2 = window2_c.iloc[-1]\n                    abs_peak_to_close_ret2 = (close_at_expiry2 / abs_max_p2) - 1.0 if abs_max_p2 > 1e-9 else np.nan\n                    abs_trough_to_close_ret2 = (close_at_expiry2 / abs_min_p2) - 1.0 if abs_min_p2 > 1e-9 else np.nan\n                else:\n                    abs_peak_to_close_ret2 = np.nan\n                    abs_trough_to_close_ret2 = np.nan\n\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = abs_exp2_max_ret\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = abs_exp2_min_ret\n                abs_targets.loc[window_idx, 'abs_exp2_peak_to_close_ret'] = abs_peak_to_close_ret2\n                abs_targets.loc[window_idx, 'abs_exp2_trough_to_close_ret'] = abs_trough_to_close_ret2\n\n        return abs_targets\n\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n    \n        # --- Engineered logrets ---\n        engineered_targets = [\n            'logret_up_1h', 'logret_down_1h',\n            'logret_up_3h', 'logret_down_3h',\n            'logret_up_6h', 'logret_down_6h',\n            'logret_up_12h', 'logret_down_12h',   \n            'logret_up_24h', 'logret_down_24h',\n            'next_24h_vol'    # Add realized volatility target\n        ]\n        \n        # Engineered logrets: all compare future high/low to current close\n        df['logret_up_1h'] = np.log(df['h'].shift(-1) / df['c'])\n        df['logret_down_1h'] = np.log(df['l'].shift(-1) / df['c'])\n        \n        # For 3h: max high and min low over the next 3 hours (including the next hour, not current)\n        df['logret_up_3h'] = np.log(df['h'].shift(-3).rolling(window=3, min_periods=3).max() / df['c'])\n        df['logret_down_3h'] = np.log(df['l'].shift(-3).rolling(window=3, min_periods=3).min() / df['c'])\n        \n        # For 6h: max high and min low over the next 6 hours\n        df['logret_up_6h'] = np.log(df['h'].shift(-6).rolling(window=6, min_periods=6).max() / df['c'])\n        df['logret_down_6h'] = np.log(df['l'].shift(-6).rolling(window=6, min_periods=6).min() / df['c'])\n    \n            # For 12h: max high and min low over the next 12 hours\n        df['logret_up_12h'] = np.log(df['h'].shift(-12).rolling(window=12, min_periods=12).max() / df['c'])\n        df['logret_down_12h'] = np.log(df['l'].shift(-12).rolling(window=12, min_periods=12).min() / df['c'])\n\n        # For 24h: max high and min low over the next 24 hours\n        df['logret_up_24h'] = np.log(df['h'].shift(-24).rolling(window=24, min_periods=24).max() / df['c'])\n        df['logret_down_24h'] = np.log(df['l'].shift(-24).rolling(window=24, min_periods=24).min() / df['c'])\n        \n        # --- Next 24-hour realized volatility ---\n        # Calculate close-to-close log returns for the next 24 hours\n        # This is the realized volatility that will occur over the next 24 hours\n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        # Rolling std of future returns over next 24 hours, annualized\n        # Use shift(-24) to look forward, then rolling to get the window\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n\n        # --- Calculate price targets ---\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n    \n        # Merge all targets\n        df_targets = pd.concat([price_targets, abs_targets, df[engineered_targets]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n\n        # Always filter, even if empty\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)","epoch":3,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Validates input and stores column names.\"\"\"\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        \"\"\"Calculate expiration timestamps.\"\"\"\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        \"\"\"Helper method to compute all price targets without tail indicators\"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n\n        # Pre-calculate expiration timestamps aligned to the bar close (current_ts + 1h)\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            # SAFER REFERENCE PRICE HANDLING\n            try:\n                reference_price = row['prev_close']\n                # Handle case where reference_price might be a Series (duplicate columns)\n                if isinstance(reference_price, pd.Series):\n                    if reference_price.empty or reference_price.isna().all() or (reference_price <= 1e-9).all():\n                        continue\n                    reference_price = reference_price.iloc[0]  # Take first value\n                elif pd.isna(reference_price) or reference_price <= 1e-9:\n                    continue\n            except KeyError:\n                continue  # Skip if reference price not available\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts:\n                    continue\n\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                \n                if not prices1_h.empty:\n                    # Basic price targets\n\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n\n                    # Peak/trough timing\n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    peak_offset = (max_idx - current_bar_end).total_seconds() / 3600.0\n                    trough_offset = (min_idx - current_bar_end).total_seconds() / 3600.0\n                    results['exp1_peak_frac'] = peak_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_trough_frac'] = trough_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    # Close return\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError:\n                        pass\n                    \n                    for k, v in results.items():\n                        targets_df.at[current_ts, k] = v\n\n        return targets_df\n\n\n\n    def _calculate_absolute_expiry_targets(self, X):\n        \"\"\"\n        For each expiry window, compute the absolute peak/trough and their times.\n        Assign these to all rows in the window.\n        Also computes absolute min/max for the following expiry window (exp2).\n        \"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        prev_close = X['prev_close']\n\n        # Map each timestamp to its expiry window start and end\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp2_times = pd.Series({ts: exp[1] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0:\n                continue\n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            # Use the close from the row immediately before the window start (even if exp_start is not in index)\n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx >= 0:\n                prev_close_ts = X.index[prev_idx]\n                window_prev_close = X.loc[prev_close_ts, 'c']\n            else:\n                window_prev_close = np.nan\n\n            if window_h.empty or pd.isna(window_prev_close) or window_prev_close <= 1e-9:\n                continue\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n\n            # Absolute peak/trough and their times for expiry 1\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            abs_max_ret = (abs_max / window_prev_close) - 1.0\n            abs_min_ret = (abs_min / window_prev_close) - 1.0\n            max_idx = window_h.idxmax()\n            min_idx = window_l.idxmin()\n            window_length = (exp_end - exp_start).total_seconds() / 3600.0\n            peak_offset = (max_idx - exp_start).total_seconds() / 3600.0\n            trough_offset = (min_idx - exp_start).total_seconds() / 3600.0\n            abs_peak_frac = peak_offset / window_length if window_length > 0 else np.nan\n            abs_trough_frac = trough_offset / window_length if window_length > 0 else np.nan\n            abs_peak_hours_to_expiry = (exp_end - max_idx).total_seconds() / 3600.0\n            abs_trough_hours_to_expiry = (exp_end - min_idx).total_seconds() / 3600.0\n\n            # Absolute mean reversion targets for expiry 1\n            if not window_c.empty:\n                close_at_expiry = window_c.iloc[-1]\n                abs_peak_to_close_ret = (close_at_expiry / abs_max) - 1.0 if abs_max > 1e-9 else np.nan\n                abs_trough_to_close_ret = (close_at_expiry / abs_min) - 1.0 if abs_min > 1e-9 else np.nan\n            else:\n                abs_peak_to_close_ret = np.nan\n                abs_trough_to_close_ret = np.nan\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = abs_max_ret\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = abs_min_ret\n            abs_targets.loc[window_idx, 'abs_exp1_peak_frac'] = abs_peak_frac\n            abs_targets.loc[window_idx, 'abs_exp1_trough_frac'] = abs_trough_frac\n            abs_targets.loc[window_idx, 'abs_exp1_peak_hours_to_expiry'] = abs_peak_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_trough_hours_to_expiry'] = abs_trough_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_peak_to_close_ret'] = abs_peak_to_close_ret\n            abs_targets.loc[window_idx, 'abs_exp1_trough_to_close_ret'] = abs_trough_to_close_ret\n\n            # --- NEW: Absolute min/max for the following expiry window (exp2) ---\n            # Find exp2 window for this expiry\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_idx = timestamps[mask2]\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            window2_c = prices_c[mask2]\n\n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_exp2_max_ret = (abs_max_p2 / window_prev_close) - 1.0\n                abs_exp2_min_ret = (abs_min_p2 / window_prev_close) - 1.0\n                max2_idx = window2_h.idxmax()\n                min2_idx = window2_l.idxmin()\n                # Mean reversion for exp2\n                if not window2_c.empty:\n                    close_at_expiry2 = window2_c.iloc[-1]\n                    abs_peak_to_close_ret2 = (close_at_expiry2 / abs_max_p2) - 1.0 if abs_max_p2 > 1e-9 else np.nan\n                    abs_trough_to_close_ret2 = (close_at_expiry2 / abs_min_p2) - 1.0 if abs_min_p2 > 1e-9 else np.nan\n                else:\n                    abs_peak_to_close_ret2 = np.nan\n                    abs_trough_to_close_ret2 = np.nan\n\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = abs_exp2_max_ret\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = abs_exp2_min_ret\n                abs_targets.loc[window_idx, 'abs_exp2_peak_to_close_ret'] = abs_peak_to_close_ret2\n                abs_targets.loc[window_idx, 'abs_exp2_trough_to_close_ret'] = abs_trough_to_close_ret2\n\n        return abs_targets\n\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n    \n        # --- Engineered logrets ---\n        engineered_targets = [\n            'logret_up_1h', 'logret_down_1h',\n            'logret_up_3h', 'logret_down_3h',\n            'logret_up_6h', 'logret_down_6h',\n            'logret_up_12h', 'logret_down_12h',   \n            'logret_up_24h', 'logret_down_24h',\n            'next_24h_vol'    # Add realized volatility target\n        ]\n        \n        # Engineered logrets: all compare future high/low to current close\n        df['logret_up_1h'] = np.log(df['h'].shift(-1) / df['c'])\n        df['logret_down_1h'] = np.log(df['l'].shift(-1) / df['c'])\n        \n        # For 3h: max high and min low over the next 3 hours (including the next hour, not current)\n        df['logret_up_3h'] = np.log(df['h'].shift(-3).rolling(window=3, min_periods=3).max() / df['c'])\n        df['logret_down_3h'] = np.log(df['l'].shift(-3).rolling(window=3, min_periods=3).min() / df['c'])\n        \n        # For 6h: max high and min low over the next 6 hours\n        df['logret_up_6h'] = np.log(df['h'].shift(-6).rolling(window=6, min_periods=6).max() / df['c'])\n        df['logret_down_6h'] = np.log(df['l'].shift(-6).rolling(window=6, min_periods=6).min() / df['c'])\n    \n            # For 12h: max high and min low over the next 12 hours\n        df['logret_up_12h'] = np.log(df['h'].shift(-12).rolling(window=12, min_periods=12).max() / df['c'])\n        df['logret_down_12h'] = np.log(df['l'].shift(-12).rolling(window=12, min_periods=12).min() / df['c'])\n\n        # For 24h: max high and min low over the next 24 hours\n        df['logret_up_24h'] = np.log(df['h'].shift(-24).rolling(window=24, min_periods=24).max() / df['c'])\n        df['logret_down_24h'] = np.log(df['l'].shift(-24).rolling(window=24, min_periods=24).min() / df['c'])\n        \n        # --- Next 24-hour realized volatility ---\n        # Calculate close-to-close log returns for the next 24 hours\n        # This is the realized volatility that will occur over the next 24 hours\n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        # Rolling std of future returns over next 24 hours, annualized\n        # Use shift(-24) to look forward, then rolling to get the window\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n\n        # --- Calculate price targets ---\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n    \n        # Merge all targets\n        df_targets = pd.concat([price_targets, abs_targets, df[engineered_targets]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n\n        # Always filter, even if empty\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Creates volatility regime labels for classification:\n    0 = Normal/Mean Reverting\n    1 = Trending\n    2 = Jump Risk\n    \n    Parameters\n    ----------\n    lookback_window : int, default=24\n        Hours to look back for regime calculation\n    \n    forward_window : int, default=12\n        Hours to look forward for regime labeling\n        \n    vol_percentile : float, default=75\n        Percentile threshold for high volatility (jump risk)\n        \n    trend_threshold : float, default=0.6\n        Threshold for directional consistency to identify trends\n        \n    jump_threshold_std : float, default=2.5\n        Standard deviation threshold for identifying jumps\n    \"\"\"\n    \n    def __init__(self, \n                 lookback_window: int = 24,\n                 forward_window: int = 12,\n                 vol_percentile: float = 75,\n                 trend_threshold: float = 0.6,\n                 jump_threshold_std: float = 2.5):\n        self.lookback_window = lookback_window\n        self.forward_window = forward_window\n        self.vol_percentile = vol_percentile\n        self.trend_threshold = trend_threshold\n        self.jump_threshold_std = jump_threshold_std\n        self._feature_names_out = None\n        self._vol_threshold = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Calculates volatility thresholds from training data.\"\"\"\n        required_cols = ['c', 'h', 'l', 'o']\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        \n        # Calculate realized volatility to set threshold\n        safe_close = X['c'].replace(0, np.nan)\n        log_returns = np.log(safe_close / safe_close.shift(1))\n        realized_vol = log_returns.rolling(window=self.lookback_window, min_periods=int(self.lookback_window*0.75)).std()\n        realized_vol_annualized = realized_vol * np.sqrt(24 * 365)\n        \n        # Store the percentile threshold for jump detection\n        self._vol_threshold = np.nanpercentile(realized_vol_annualized.dropna(), self.vol_percentile)\n        \n        return self\n    \n    def _calculate_regime_features(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Calculate features used for regime classification.\"\"\"\n        df = X.copy()\n        safe_close = df['c'].replace(0, np.nan)\n        \n        # 1. Realized volatility (annualized)\n        log_returns = np.log(safe_close / safe_close.shift(1))\n        realized_vol = log_returns.rolling(window=self.lookback_window, \n                                          min_periods=int(self.lookback_window*0.75)).std()\n        df['realized_vol'] = realized_vol * np.sqrt(24 * 365)\n        \n        # 2. High-Low range as % of close (volatility proxy)\n        df['hl_range_pct'] = ((df['h'] - df['l']) / df['c']) * 100\n        \n        # 3. Directional consistency (trend indicator)\n        # Positive if upward trend, negative if downward\n        returns = log_returns.rolling(window=self.lookback_window, \n                                      min_periods=int(self.lookback_window*0.75)).apply(\n            lambda x: (x > 0).sum() / len(x) if len(x) > 0 else np.nan\n        )\n        df['directional_consistency'] = returns\n        \n        # 4. Gap detection (for jump risk)\n        # Gap between close and next open\n        df['gap_size'] = np.abs(np.log(df['o'] / safe_close.shift(1)))\n        \n        # 5. Intrabar range expansion (jump indicator)\n        # Compare current bar range to recent average\n        avg_range = df['hl_range_pct'].rolling(window=self.lookback_window, \n                                               min_periods=int(self.lookback_window*0.75)).mean()\n        df['range_expansion'] = df['hl_range_pct'] / avg_range\n        \n        # 6. Mean reversion indicator\n        # Distance from moving average as % of std dev\n        ma = safe_close.rolling(window=self.lookback_window, \n                               min_periods=int(self.lookback_window*0.75)).mean()\n        std = safe_close.rolling(window=self.lookback_window, \n                                min_periods=int(self.lookback_window*0.75)).std()\n        df['zscore'] = (safe_close - ma) / std\n        \n        # 7. Return to mean measure (for forward window)\n        # How much price reverts after reaching extremes\n        df['max_deviation_fwd'] = df['h'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.75)).max()\n        df['min_deviation_fwd'] = df['l'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.75)).min()\n        \n        return df\n    \n    def _assign_regime_labels(self, df: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Assign regime labels based on forward-looking characteristics.\n        \n        Returns\n        -------\n        pd.Series with regime labels: 0=Normal/Mean Reverting, 1=Trending, 2=Jump Risk\n        \"\"\"\n        labels = pd.Series(index=df.index, dtype='Int64')\n        \n        # Calculate forward-looking metrics for labeling\n        safe_close = df['c'].replace(0, np.nan)\n        \n        # Forward returns and volatility\n        fwd_returns = np.log(safe_close.shift(-self.forward_window) / safe_close)\n        fwd_high = df['h'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).max()\n        fwd_low = df['l'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).min()\n        \n        # Forward realized volatility\n        fwd_vol = np.log(safe_close.shift(-1) / safe_close).shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).std() * np.sqrt(24 * 365)\n        \n        # Forward range expansion\n        fwd_range_pct = ((fwd_high - fwd_low) / safe_close) * 100\n        \n        # Forward directional consistency\n        fwd_direction = np.log(safe_close.shift(-1) / safe_close).shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).apply(\n            lambda x: np.abs((x > 0).sum() / len(x) - 0.5) if len(x) > 0 else np.nan\n        )\n        \n        # Mean reversion measure: does price return to starting level?\n        fwd_close = safe_close.shift(-self.forward_window)\n        price_reversion = np.abs(np.log(fwd_close / safe_close))\n        \n        # Check for large jumps in forward window\n        fwd_gaps = df['gap_size'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=1).max()\n        fwd_range_expansion = df['range_expansion'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=1).max()\n        \n        # REGIME CLASSIFICATION LOGIC\n        for idx in df.index:\n            if pd.isna(fwd_vol.loc[idx]) or pd.isna(fwd_direction.loc[idx]):\n                labels.loc[idx] = pd.NA\n                continue\n            \n            # JUMP RISK (Priority 1): High volatility or large gaps/range expansion\n            if (fwd_vol.loc[idx] > self._vol_threshold or \n                fwd_gaps.loc[idx] > self.jump_threshold_std * df['gap_size'].std() or\n                fwd_range_expansion.loc[idx] > self.jump_threshold_std):\n                labels.loc[idx] = 2\n                \n            # TRENDING (Priority 2): Strong directional consistency\n            elif fwd_direction.loc[idx] > self.trend_threshold:\n                labels.loc[idx] = 1\n                \n            # NORMAL/MEAN REVERTING (Default): Lower volatility with reversion\n            else:\n                labels.loc[idx] = 0\n        \n        return labels\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Generate regime labels and supporting features.\n        \n        Returns\n        -------\n        pd.DataFrame with regime label and intermediate features\n        \"\"\"\n        check_is_fitted(self, '_vol_threshold')\n        \n        # Calculate regime features\n        df_features = self._calculate_regime_features(X)\n        \n        # Assign regime labels\n        regime_labels = self._assign_regime_labels(df_features)\n        \n        # Create output dataframe\n        output = pd.DataFrame(index=X.index)\n        output['regime_label'] = regime_labels\n        \n        # Add useful features for model training\n        output['regime_realized_vol'] = df_features['realized_vol']\n        output['regime_hl_range_pct'] = df_features['hl_range_pct']\n        output['regime_directional_consistency'] = df_features['directional_consistency']\n        output['regime_gap_size'] = df_features['gap_size']\n        output['regime_range_expansion'] = df_features['range_expansion']\n        output['regime_zscore'] = df_features['zscore']\n        \n        self._feature_names_out = list(output.columns)\n        \n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Get the distribution of regimes in the dataset.\n        \n        Returns\n        -------\n        pd.Series with counts for each regime\n        \"\"\"\n        transformed = self.transform(X)\n        return transformed['regime_label'].value_counts().sort_index()","epoch":8,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py::request_d7699234-21c0-49d5-8d4d-c7776a74afdc",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","content":"\"\"\"Tiered feature engineering pipeline with heavy cache and live state support.\n\nThis module reorganizes the legacy feature engineering code into three distinct\nfeature categories (stateless, rolling, and complex/grouped) and exposes a\nthree-tier caching strategy:\n\n* Tier 1 (Heavy cache): expensive grouped aggregations persisted to disk.\n* Tier 2 (Live state cache): in-memory rolling window state for incremental updates.\n* Tier 3 (On-demand row projection): combines cached state with the latest bar.\n\nQuick start (sklearn-compatible fit/transform pattern):\n\n1. **Training Phase**: Fit on historical data to build heavy cache and learn patterns::\n\n         from featureEngineer import FeatureEngineer\n\n         # Initialize with production settings\n         fe = FeatureEngineer()\n         \n         # Fit on training data (builds heavy cache, ~1-2s for 1000 rows)\n         fe.fit(historical_ohlcv_data)\n         \n         # Transform training data (reuses cache, fast)\n         training_features = fe.transform(historical_ohlcv_data)\n\n2. **Real-time Inference**: Transform new data using fitted pipeline::\n\n         # Transform single new row (target: <100ms latency)\n         new_features = fe.transform(latest_market_data)\n         \n         # Transform updated/corrected data (same performance)\n         corrected_features = fe.transform(corrected_market_data)\n\n3. **Performance**: Typical latency ~50-100ms per row for real-time inference.\n\nAdvanced usage for streaming:\n\n4. For high-frequency streaming updates, use the live state system::\n\n       live_state = fe.initialize_live_state(price_df)\n       # Append the next bar\n       next_features = fe.ingest_live_row(next_bar)\n       # Replace the latest bar with revised data\n       revised_features = fe.ingest_live_row(revised_bar)\n\nThe design targets low-fragmentation DataFrame operations while remaining fully\ncompatible with the existing offline batch workflow.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport pickle\nimport time\nimport warnings\nfrom collections import deque\nfrom contextlib import nullcontext\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Tuple\n\nimport numpy as np\nimport pandas as pd\nimport ta\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\nfrom ML_general_tools import stat_tools\nfrom data_pipeline import is_europe_dst\n\n\nHEAVY_CACHE_VERSION = 1\nDEFAULT_PREV_DAYTYPE_WINDOW = 90\nDEFAULT_EMPIRICAL_THRESHOLDS = (0.0001, 0.0005, 0.001)\nDEFAULT_EMPIRICAL_WINDOW = 90\nDEFAULT_EMPIRICAL_MIN_COUNT = 20\nHOURS_PER_YEAR = 24 * 365\n# Standard normal quantiles for 90%, 50%, and 10% (fixed z-scores)\nZ_SCORE_90 = 1.2815515655446004\nZ_SCORE_75 = 0.6744897501960817\nZ_SCORE_25 = -Z_SCORE_75\nZ_SCORE_10 = -Z_SCORE_90\n\n@dataclass\nclass HeavyFeaturePayload:\n    \"\"\"Serialized representation of complex/grouped features.\"\"\"\n\n    prev_cycle_lookup: pd.DataFrame\n    prev_cycle_stats_lookup: pd.DataFrame\n    empirical_lookup: pd.DataFrame\n    metadata: Dict[str, Any]\n\n\nclass HeavyFeatureCache:\n    \"\"\"Persist heavy feature payloads to disk with version awareness.\"\"\"\n\n    def __init__(self, cache_dir: Optional[Path]) -> None:\n        self.cache_dir = Path(cache_dir or Path(\"cache\") / \"heavy_features\")\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        self.payload: Optional[HeavyFeaturePayload] = None\n\n    @property\n    def cache_path(self) -> Path:\n        return self.cache_dir / f\"heavy_features_v{HEAVY_CACHE_VERSION}.pkl\"\n\n    def load(self) -> bool:\n        cache_path = self.cache_path\n        if not cache_path.exists():\n            return False\n        try:\n            with cache_path.open(\"rb\") as fh:\n                payload = pickle.load(fh)\n        except Exception:\n            return False\n        if not isinstance(payload, HeavyFeaturePayload):\n            return False\n        metadata = payload.metadata if isinstance(payload.metadata, dict) else {}\n        if metadata.get(\"version\") != HEAVY_CACHE_VERSION:\n            return False\n        self.payload = payload\n        return True\n\n    def save(self, payload: HeavyFeaturePayload) -> None:\n        cache_path = self.cache_path\n        with cache_path.open(\"wb\") as fh:\n            pickle.dump(payload, fh)\n        self.payload = payload\n\n\n@dataclass\nclass LiveStateCache:\n    \"\"\"Hold incremental feature state for real-time updates.\"\"\"\n\n    features_df: pd.DataFrame\n    price_history: pd.DataFrame\n    rolling_states: Dict[str, Any]\n    ema_states: Dict[str, Any]\n    metadata: Dict[str, Any]\n\n    def append(self, features_row: pd.Series, price_row: pd.Series) -> None:\n        self.features_df = pd.concat([self.features_df, features_row.to_frame().T])\n        self.price_history = pd.concat([self.price_history, price_row.to_frame().T])\n\n\n@dataclass\nclass RollingWindowState:\n    \"\"\"Maintain running statistics for a fixed-length window.\"\"\"\n\n    window: int\n    values: deque = field(default_factory=deque)\n    sum_: float = 0.0\n    sum_sq: float = 0.0\n\n    def append(self, value: float) -> None:\n        self.values.append(value)\n        self.sum_ += value\n        self.sum_sq += value * value\n        if len(self.values) > self.window:\n            old = self.values.popleft()\n            self.sum_ -= old\n            self.sum_sq -= old * old\n\n    def mean(self, min_periods: int = 1) -> float:\n        n = len(self.values)\n        if n < max(1, min_periods):\n            return float(\"nan\")\n        return self.sum_ / n\n\n    def std(self, min_periods: int = 2) -> float:\n        n = len(self.values)\n        if n < max(2, min_periods):\n            return float(\"nan\")\n        mean = self.sum_ / n\n        variance = (self.sum_sq - n * mean * mean) / max(1, n - 1)\n        variance = max(variance, 0.0)\n        return float(np.sqrt(variance))\n\n\nclass StatelessFeatureBlock:\n    \"\"\"Generate row-wise features that only require the most recent bar.\"\"\"\n\n    def __init__(self, expiration_hour: int, include_dst: bool) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_dst = include_dst\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return a DataFrame of strictly causal, per-row features.\"\"\"\n\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Stateless features require a DatetimeIndex\")\n        if df.empty:\n            return pd.DataFrame(index=df.index)\n\n        idx = df.index\n        current_time = idx + pd.Timedelta(hours=1)\n        expiry_today = current_time.normalize() + pd.Timedelta(hours=self.expiration_hour)\n        expiry_tomorrow = expiry_today + pd.Timedelta(days=1)\n        time_diff = np.where(current_time < expiry_today, expiry_today - current_time, expiry_tomorrow - current_time)\n        time_to_exp = pd.Series(\n            [float(delta / pd.Timedelta(hours=1)) for delta in time_diff],\n            index=idx,\n            dtype=\"float64\",\n        )\n        time_to_exp[np.isclose(time_to_exp, 0.0, atol=1e-9)] = 24.0\n\n        stateless = pd.DataFrame(index=idx)\n        stateless[\"time_to_exp1_hr\"] = time_to_exp\n        stateless[\"time_elapsed\"] = 24.0 - time_to_exp\n        stateless[\"hour\"] = current_time.hour\n        stateless[\"day_of_week\"] = current_time.dayofweek\n        stateless[\"is_weekend\"] = stateless[\"day_of_week\"].isin([5, 6]).astype(int)\n\n        hour_of_week = stateless[\"day_of_week\"] * 24 + stateless[\"hour\"]\n        stateless[\"hour_of_week\"] = hour_of_week\n        stateless[\"hour_of_week_sin\"] = np.sin(2 * np.pi * hour_of_week / 168)\n        stateless[\"hour_of_week_cos\"] = np.cos(2 * np.pi * hour_of_week / 168)\n        stateless[\"hours_since_week_start\"] = hour_of_week.astype(float)\n\n        stateless[\"day_type_num\"] = np.select(\n            [stateless[\"day_of_week\"] < 5, stateless[\"day_of_week\"] == 5, stateless[\"day_of_week\"] == 6],\n            [0, 1, 2],\n            default=-1,\n        )\n\n        stateless[\"prev_close\"] = df[\"c\"].shift(1)\n        if \"volCcy\" in df.columns:\n            stateless[\"volCcy_prev\"] = df[\"volCcy\"].shift(1).round()\n        else:\n            stateless[\"volCcy_prev\"] = np.nan\n\n        cycle_start_mask = ((idx + pd.Timedelta(hours=1)).hour == self.expiration_hour)\n        cycle_start_flags = cycle_start_mask.astype(int)\n        cycle_ids = cycle_start_flags.cumsum()\n        stateless[\"cycle_id\"] = cycle_ids\n\n        cycle_anchor_close = df[\"c\"].where(cycle_start_mask)\n        stateless[\"window_prev_close\"] = cycle_anchor_close.ffill()\n        stateless.loc[stateless[\"window_prev_close\"].isna(), \"window_prev_close\"] = stateless.loc[\n            stateless[\"window_prev_close\"].isna(), \"prev_close\"\n        ]\n        stateless[\"_cycle_start_ts\"] = (idx + pd.Timedelta(hours=1)).to_series().where(cycle_start_mask).ffill().values\n\n        close_shift_1 = df[\"c\"].shift(1)\n        close_shift_2 = df[\"c\"].shift(2)\n        safe_close_shift_2 = close_shift_2.replace(0, np.nan)\n\n        stateless[\"returns_1h\"] = ((close_shift_1 / safe_close_shift_2) - 1).fillna(0)\n\n        horizons = [2, 3, 4, 5, 6, 12, 24, 72]\n        for horizon in horizons:\n            denominator = df[\"c\"].shift(horizon + 1).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[f\"returns_{horizon}h\"] = (ratio - 1).fillna(0)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[f\"logret_{horizon}h\"] = np.log(ratio.replace(0, np.nan))\n\n        for window_hours, label in [(24 * 7 + 1, \"returns_1wk\"), (24 * 30 + 1, \"returns_1M\")]:\n            denominator = df[\"c\"].shift(window_hours).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[label] = (ratio - 1).fillna(0)\n\n        if {\"h\", \"l\"}.issubset(df.columns):\n            high_shift_1 = df[\"h\"].shift(1)\n            low_shift_1 = df[\"l\"].shift(1)\n            safe_low = low_shift_1.replace(0, np.nan)\n\n            stateless[\"ret_h_pc\"] = (high_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_l_pc\"] = (low_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_c_pc\"] = (close_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_h_l\"] = (high_shift_1 / safe_low) - 1\n\n            for window in [2, 3, 6, 12, 24]:\n                rolling_high = high_shift_1.rolling(window=window, min_periods=1).max()\n                rolling_low = low_shift_1.rolling(window=window, min_periods=1).min()\n                stateless[f\"range_{window}h\"] = rolling_high - rolling_low\n                stateless[f\"range_pc_{window}h\"] = (\n                    (rolling_high - rolling_low) / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n                )\n\n            trading_range = high_shift_1 - low_shift_1\n            stateless[\"range\"] = trading_range\n            stateless[\"range_pc\"] = trading_range / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            stateless[\"close_to_high\"] = (high_shift_1 - close_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            stateless[\"close_to_low\"] = (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n\n            same_high_low = high_shift_1 == low_shift_1\n            stateless.loc[same_high_low, [\"close_to_high\", \"close_to_low\"]] = 0.5\n\n            stateless[\"close_pos_in_bar\"] = (\n                (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            ).clip(0, 1)\n            stateless.loc[same_high_low, \"close_pos_in_bar\"] = 0.5\n\n            prev_close_shift_1 = stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[\"logret_h_pc\"] = np.log(high_shift_1 / prev_close_shift_1)\n                stateless[\"logret_l_pc\"] = np.log(low_shift_1 / prev_close_shift_1)\n                stateless[\"logret_c_pc\"] = np.log(close_shift_1 / prev_close_shift_1)\n\n        if self.include_dst:\n            stateless[\"is_dst\"] = is_europe_dst(idx).astype(int)\n\n        return stateless.replace([np.inf, -np.inf], np.nan)\n\n\nclass RollingFeatureBlock:\n    \"\"\"Produce fixed-window rolling statistics without duplicating logic elsewhere.\"\"\"\n\n    def __init__(self,\n                 vol_window_sizes: Iterable[int],\n                 vlm_window_sizes: Iterable[int],\n                 vol_types_to_calc: Iterable[str],\n                 vol_trading_periods: int) -> None:\n        self.vol_window_sizes = sorted(set(vol_window_sizes))\n        self.vlm_window_sizes = sorted(set(vlm_window_sizes))\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.stats = stat_tools()\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return combined trend/volatility/liquidity/relative-position features.\"\"\"\n\n        features = []\n\n        if {\"c\", \"h\", \"l\"}.issubset(df.columns):\n            features.append(self._trend_features(df))\n            features.append(self._relative_position_features(df))\n        if \"volCcy_prev\" in df.columns or \"volCcy\" in df.columns:\n            features.append(self._liquidity_features(df))\n        features.append(self._volatility_features(df))\n\n        valid = [f for f in features if f is not None and not f.empty]\n        if not valid:\n            return pd.DataFrame(index=df.index)\n        return pd.concat(valid, axis=1)\n\n    # --- Private helpers -------------------------------------------------\n\n    def _trend_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        trend_df = pd.DataFrame(index=df.index)\n        closes = df[\"c\"].shift(1)\n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n\n            close_w_ago = df[\"c\"].shift(w + 1)\n            momentum = ((closes / close_w_ago.replace(0, np.nan)) - 1).fillna(0)\n\n            trend_df[f\"momentum_{w}h\"] = momentum\n            trend_df[f\"momentum_signed_sqrt_{w}h\"] = np.sign(momentum) * np.sqrt(np.abs(momentum))\n\n        try:\n            macd = ta.trend.MACD(df[\"c\"].shift(1), window_slow=26, window_fast=12, window_sign=9, fillna=True)\n            trend_df[\"macd\"] = macd.macd()\n            trend_df[\"macd_signal\"] = macd.macd_signal()\n            trend_df[\"macd_hist\"] = macd.macd_diff()\n\n            adx = ta.trend.ADXIndicator(df[\"h\"].shift(1), df[\"l\"].shift(1), df[\"c\"].shift(1), window=14, fillna=True)\n            trend_df[\"adx\"] = adx.adx()\n            trend_df[\"adx_pos\"] = adx.adx_pos()\n            trend_df[\"adx_neg\"] = adx.adx_neg()\n        except Exception:\n            for col in [\"macd\", \"macd_signal\", \"macd_hist\", \"adx\", \"adx_pos\", \"adx_neg\"]:\n                trend_df[col] = np.nan\n\n        return trend_df\n\n    def _volatility_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vol_df = pd.DataFrame(index=df.index)\n        prev_close = df[\"prev_close\"].replace(0, np.nan)\n        prev_close_lag = prev_close.shift(1).replace(0, np.nan)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log_ret = np.log(prev_close / prev_close_lag)\n        log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        for w in self.vol_window_sizes:\n            if \"raw\" in self.vol_types_to_calc:\n                min_p = max(3, w // 4)\n                vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_raw_{w}h\"] = vol.fillna(0)\n            if \"gkyz\" in self.vol_types_to_calc:\n                try:\n                    gkyz = self.stats.get_GKYZ(df, w, self.vol_trading_periods)\n                    vol_df[f\"vol_gkyz_{w}h\"] = gkyz.reindex(df.index).ffill()\n                except Exception:\n                    vol_df[f\"vol_gkyz_{w}h\"] = pd.Series(0, index=df.index)\n            if \"atr\" in self.vol_types_to_calc:\n                vol_df[f\"atr_{w}h\"] = self._calculate_atr(df, w)\n            if \"parkinson\" in self.vol_types_to_calc:\n                # Parkinson volatility: range-based estimator using only H/L\n                # Formula:  = [(1/(4*ln(2))) * mean((ln(H/L)))] * (trading_periods)\n                # More efficient than close-to-close, captures intraday volatility\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                safe_low = low_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    hl_ratio = high_shifted / safe_low\n                    log_hl = np.log(hl_ratio.replace([0, np.inf, -np.inf], np.nan))\n                    log_hl_sq = log_hl ** 2\n                \n                min_p = max(3, w // 4)\n                # Parkinson coefficient: 1/(4*ln(2))  0.3607\n                parkinson_coef = 1.0 / (4.0 * np.log(2.0))\n                mean_log_hl_sq = log_hl_sq.rolling(w, min_periods=min_p).mean()\n                vol_parkinson = np.sqrt(parkinson_coef * mean_log_hl_sq) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_parkinson_{w}h\"] = vol_parkinson.fillna(0)\n            if \"vol_zscore\" in self.vol_types_to_calc:\n                # Z-score of volatility: (current_vol - rolling_mean) / rolling_std\n                # Use raw volatility as base, with longer lookback for mean/std calculation\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Use 2x window for mean/std to capture volatility regime\n                zscore_window = min(w * 2, max(self.vol_window_sizes))\n                min_p_zscore = max(w, zscore_window // 2)\n                vol_ma = base_vol.rolling(zscore_window, min_periods=min_p_zscore).mean()\n                vol_std = base_vol.rolling(zscore_window, min_periods=min_p_zscore).std().replace(0, 1e-9)\n                vol_df[f\"vol_zscore_{w}h\"] = ((base_vol - vol_ma) / vol_std).fillna(0)\n            if \"log_vol\" in self.vol_types_to_calc:\n                # Log-volatility: useful for multiplicative volatility models\n                # Use raw volatility as base\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Clip to avoid log(0) and handle very small volatilities\n                vol_clipped = base_vol.clip(lower=1e-6)\n                vol_df[f\"log_vol_{w}h\"] = np.log(vol_clipped).fillna(0)\n\n        if \"skew\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=3).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=3).std()\n            centered = log_ret - ewma\n            skew_num = (centered ** 3).ewm(span=24, min_periods=3).mean()\n            vol_df[\"returns_skew_24h\"] = (skew_num / (ewmstd ** 3 + 1e-9)).fillna(0)\n\n        if \"kurtosis\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=4).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=4).std()\n            centered = log_ret - ewma\n            kurt_num = (centered ** 4).ewm(span=24, min_periods=4).mean()\n            vol_df[\"returns_kurtosis_24h\"] = (kurt_num / (ewmstd ** 4 + 1e-9) - 3).fillna(0)\n\n        def _lookup(col: str) -> Optional[pd.Series]:\n            if col in vol_df.columns:\n                return vol_df[col]\n            if col in df.columns:\n                return df[col]\n            return None\n\n        ## lets use raw vol as thats what blackscholes does and they actually got a noble prize somehow\n        vol_24 = _lookup(\"vol_raw_24h\")\n        vol_144 = _lookup(\"vol_raw_144h\")\n        vol_288 = _lookup(\"vol_raw_288h\")\n\n        vol_df[\"vol_ratio_24h_144h\"] = vol_24 / vol_144.replace(0, np.nan)\n        vol_df[\"vol_ratio_24h_288h\"] = vol_24 / vol_288.replace(0, np.nan)\n\n\n        ## essentially using pas 288 as more stable hour to predict blackscholes.\n        sigma_unit = vol_288 / np.sqrt(float(self.vol_trading_periods))\n        sigma_24h = sigma_unit * np.sqrt(24.0)\n\n        exp_ret_p90_24h = sigma_24h * Z_SCORE_90\n        exp_ret_p75_24h = sigma_24h * Z_SCORE_75\n        exp_ret_p25_24h = sigma_24h * Z_SCORE_25\n        exp_ret_p10_24h = sigma_24h * Z_SCORE_10\n\n        ## expected 24 hour moves based on blackschoels and \n        vol_df[\"exp_ret_p90_24h\"] = exp_ret_p90_24h\n        vol_df[\"exp_ret_p75_24h\"] = exp_ret_p75_24h\n        vol_df[\"exp_ret_p25_24h\"] = exp_ret_p25_24h\n        vol_df[\"exp_ret_p10_24h\"] = exp_ret_p10_24h\n\n        vol_df[\"exp_band_width_24h\"] = exp_ret_p90_24h - exp_ret_p10_24h\n        vol_df[\"exp_logmove_p90_24h\"] = np.log1p(exp_ret_p90_24h.clip(lower=-0.999999))\n        vol_df[\"exp_logmove_p10_24h\"] = np.log1p(exp_ret_p10_24h.clip(lower=-0.999999))\n\n\n\n        tte_series = df.get(\"time_to_exp1_hr\")\n        if vol_24 is not None and tte_series is not None:\n            tte_clipped = tte_series.clip(lower=1e-6)\n            with np.errstate(invalid=\"ignore\"):\n                sigma_tte = sigma_unit * np.sqrt(tte_clipped)\n                exp_ret_p90_tte = sigma_tte * Z_SCORE_90\n                exp_ret_p10_tte = sigma_tte * Z_SCORE_10\n\n            vol_df[\"exp_ret_p90_tte\"] = exp_ret_p90_tte\n            vol_df[\"exp_ret_p10_tte\"] = exp_ret_p10_tte\n            vol_df[\"exp_band_width_tte\"] = exp_ret_p90_tte - exp_ret_p10_tte\n            vol_df[\"exp_logmove_p90_tte\"] = np.log1p(exp_ret_p90_tte.clip(lower=-0.999999))\n            vol_df[\"exp_logmove_p10_tte\"] = np.log1p(exp_ret_p10_tte.clip(lower=-0.999999))\n\n\n        if \"returns_24h\" in df.columns and \"exp_band_width_24h\" in vol_df.columns:\n            band_24 = vol_df[\"exp_band_width_24h\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_24h\"] = df[\"returns_24h\"].abs() / band_24\n        if tte_series is not None and \"returns_1h\" in df.columns and \"exp_band_width_tte\" in vol_df.columns:\n            band_tte = vol_df[\"exp_band_width_tte\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_tte\"] = df[\"returns_1h\"].abs() / band_tte\n\n        return vol_df\n\n    def _liquidity_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vlm_df = pd.DataFrame(index=df.index)\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None:\n            vol_series = df[\"volCcy\"].shift(1)\n        vol_adj = vol_series.replace(0, 1e-6)\n        for w in self.vlm_window_sizes:\n            min_p = max(1, w // 2)\n            ma = vol_adj.rolling(w, min_periods=min_p).mean()\n            std = vol_adj.rolling(w, min_periods=min_p).std().replace(0, 1e-6)\n            vlm_df[f\"vlm_ma_{w}h\"] = ma\n            vlm_df[f\"vlm_zscore_{w}h\"] = (vol_adj - ma) / std\n\n        ratio_frames = []\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_168h\" in vlm_df.columns:\n            if \"vlm_ma_3h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_3h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_3h_168h\",\n                    )\n                )\n            if \"vlm_ma_6h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_6h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_6h_168h\",\n                    )\n                )\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_168h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_720h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_720h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_720h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_2160h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_2160h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_2160h\",\n                )\n            )\n\n        if ratio_frames:\n            vlm_df = pd.concat([vlm_df] + [s.to_frame() for s in ratio_frames], axis=1)\n\n        return vlm_df\n\n    def _relative_position_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        rel_df = pd.DataFrame(index=df.index)\n        high = df[\"h\"].shift(1)\n        low = df[\"l\"].shift(1)\n        close = df[\"c\"].shift(1)\n\n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n            rolling_high = high.rolling(window=w, min_periods=min_p).max()\n            rolling_low = low.rolling(window=w, min_periods=min_p).min()\n            range_w = (rolling_high - rolling_low).replace(0, np.nan)\n            rel_df[f\"stoch_pos_{w}h\"] = ((close - rolling_low) / range_w).clip(0, 1)\n            rel_df[f\"dist_from_high_{w}h\"] = (rolling_high - close) / close.replace(0, np.nan)\n            rel_df[f\"dist_from_low_{w}h\"] = (close - rolling_low) / close.replace(0, np.nan)\n            rel_df[f\"price_rank_{w}h\"] = close.rolling(w).rank(pct=True)\n\n        if 24 in self.vol_window_sizes:\n            rel_df[\"new_24h_high\"] = (high > df[\"h\"].shift(2).rolling(23).max()).astype(int)\n            rel_df[\"new_24h_low\"] = (low < df[\"l\"].shift(2).rolling(23).min()).astype(int)\n\n        return rel_df\n\n    @staticmethod\n    def _calculate_atr(df: pd.DataFrame, window: int) -> pd.Series:\n        prev_close = df[\"prev_close\"]\n        tr_components = pd.concat(\n            [\n                df[\"h\"] - df[\"l\"],\n                (df[\"h\"] - prev_close).abs(),\n                (df[\"l\"] - prev_close).abs(),\n            ],\n            axis=1,\n        )\n        tr = tr_components.max(axis=1)\n        min_p = max(1, window // 2)\n        return tr.rolling(window=window, min_periods=min_p).mean().fillna(0)\n\n\nclass ComplexFeatureBlock:\n    def __init__(self,\n                 prev_daytype_window: int,\n                 empirical_window: int,\n                 empirical_min_count: int,\n                 empirical_thresholds: Iterable[float]) -> None:\n        self.prev_daytype_window = prev_daytype_window\n        self.empirical_window = empirical_window\n        self.empirical_min_count = empirical_min_count\n        self.empirical_thresholds = list(empirical_thresholds)\n        self.expiration_hour: Optional[int] = None\n\n    def build_payload(self, df: pd.DataFrame) -> HeavyFeaturePayload:\n        if self.expiration_hour is None:\n            raise RuntimeError(\"ComplexFeatureBlock requires expiration_hour to be set\")\n        if \"time_to_exp1_hr\" not in df.columns or \"day_type_num\" not in df.columns:\n            raise ValueError(\"Complex features require time_to_exp1_hr and day_type_num columns\")\n\n        working = df.copy()\n        if \"_cycle_start_ts\" not in working.columns:\n            working[\"_cycle_start_ts\"] = df.index.to_series().where((df.index.hour == self.expiration_hour))\n\n        working = self._add_current_cycle_progress_features(working)\n        prev_cycle = self._add_prev_daytype_cycle_slice_features(working)\n        prev_cycle_stats = self._add_rolling_stats_for_prev_daytype_features(prev_cycle)\n        empirical = self._add_empirical_probability_features(prev_cycle_stats)\n\n        time_bucket = self._bucket_time_to_exp(empirical[\"time_to_exp1_hr\"])\n        empirical = empirical.assign(_tte_bucket=time_bucket)\n\n        prev_slice_cols = [col for col in empirical.columns \n                          if col.startswith(\"prev_\") \n                          and not col.endswith(\"_tte_bucket\")\n                          and col != \"prev_close\"]  # Exclude prev_close to avoid duplication\n        stats_cols = [col for col in empirical.columns if any(col.endswith(suffix) for suffix in (\"_med\", \"_p10\", \"_p90\"))]\n        empirical_cols = [col for col in empirical.columns if col.startswith(\"emp_\")]\n\n        prev_cycle_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[prev_slice_cols]\n            .median()\n            .sort_index()\n        )\n\n        prev_cycle_stats_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[stats_cols]\n            .last()\n            .sort_index()\n        )\n\n        empirical_lookup = (\n            empirical.groupby([\"hour\", \"day_type_num\"], dropna=False)[empirical_cols]\n            .last()\n            .sort_index()\n        )\n\n        metadata = {\n            \"version\": HEAVY_CACHE_VERSION,\n            \"prev_daytype_window\": self.prev_daytype_window,\n            \"empirical_window\": self.empirical_window,\n            \"empirical_thresholds\": self.empirical_thresholds,\n            \"empirical_min_count\": self.empirical_min_count,\n        }\n\n        return HeavyFeaturePayload(\n            prev_cycle_lookup=prev_cycle_lookup,\n            prev_cycle_stats_lookup=prev_cycle_stats_lookup,\n            empirical_lookup=empirical_lookup,\n            metadata=metadata,\n        )\n\n    def lookup_for_row(self, row: pd.Series, payload: HeavyFeaturePayload) -> pd.Series:\n        out_parts: List[pd.Series] = []\n        tte_bucket = self._bucket_time_to_exp(pd.Series([row[\"time_to_exp1_hr\"]])).iloc[0]\n        day_type = row.get(\"day_type_num\", np.nan)\n        hour = row.get(\"hour\", np.nan)\n\n        if not np.isnan(day_type) and not np.isnan(tte_bucket):\n            idx = (day_type, tte_bucket)\n            if idx in payload.prev_cycle_lookup.index:\n                out_parts.append(payload.prev_cycle_lookup.loc[idx])\n            if idx in payload.prev_cycle_stats_lookup.index:\n                out_parts.append(payload.prev_cycle_stats_lookup.loc[idx])\n\n        if not np.isnan(day_type) and not np.isnan(hour):\n            idx_emp = (hour, day_type)\n            if idx_emp in payload.empirical_lookup.index:\n                out_parts.append(payload.empirical_lookup.loc[idx_emp])\n\n        if not out_parts:\n            return pd.Series(dtype=\"float64\")\n        return pd.concat(out_parts)\n\n    # --- Heavy feature helpers -------------------------------------------\n\n    @staticmethod\n    def _bucket_time_to_exp(series: pd.Series, precision: int = 2) -> pd.Series:\n        return series.round(precision)\n\n    def _add_current_cycle_progress_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        prog_cols = [\"cCProgActP\", \"cCProgMinP\", \"cCProgMaxP\", \"cCProgMinT\", \"cCProgMaxT\", \"cCProgVlm\"]\n        df = df.copy()\n        df[prog_cols] = np.nan\n\n        expiry_times = df.index[df.index.hour == self.expiration_hour].sort_values()\n        for i in range(len(expiry_times)):\n            cycle_start = expiry_times[i]\n            cycle_end = expiry_times[i + 1] - pd.Timedelta(hours=1) if i + 1 < len(expiry_times) else df.index[-1]\n            cycle_mask = (df.index >= cycle_start) & (df.index <= cycle_end)\n            cycle_df = df.loc[cycle_mask]\n            if cycle_df.empty:\n                continue\n\n            prog_start_price = cycle_df.iloc[0][\"prev_close\"]\n            cum_max = cycle_df[\"h\"].expanding().max()\n            cum_min = cycle_df[\"l\"].expanding().min()\n            idxs = cycle_df.index\n            cum_max_t = cycle_df[\"h\"].expanding().apply(\n                lambda x: (idxs[x.argmax()] - cycle_start).total_seconds() // 3600\n            )\n            cum_min_t = cycle_df[\"l\"].expanding().apply(\n                lambda x: (idxs[x.argmin()] - cycle_start).total_seconds() // 3600\n            )\n            vol_series = cycle_df.get(\"volCcy_prev\")\n            if vol_series is None and \"volCcy\" in cycle_df.columns:\n                # Fallback to shifted live volume if the pre-shifted field is missing.\n                vol_series = cycle_df[\"volCcy\"].shift(1)\n            if vol_series is None:\n                vol_series = pd.Series(0.0, index=cycle_df.index)\n            cum_vlm = vol_series.fillna(0.0).cumsum()\n            prog_actp = (cycle_df[\"c\"] / prog_start_price) - 1\n            prog_maxp = (cum_max / prog_start_price) - 1\n            prog_minp = (cum_min / prog_start_price) - 1\n\n            df.loc[cycle_mask, \"cCProgActP\"] = prog_actp.values\n            df.loc[cycle_mask, \"cCProgMaxP\"] = prog_maxp.values\n            df.loc[cycle_mask, \"cCProgMinP\"] = prog_minp.values\n            df.loc[cycle_mask, \"cCProgMaxT\"] = cum_max_t.values\n            df.loc[cycle_mask, \"cCProgMinT\"] = cum_min_t.values\n            df.loc[cycle_mask, \"cCProgVlm\"] = cum_vlm.values\n\n        return df\n\n    def _add_prev_daytype_cycle_slice_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        feature_types = [\"weekday\", \"saturday\", \"sunday\"]\n        base_names = [\n            \"ProgActP\",\n            \"ProgMinP\",\n            \"ProgMaxP\",\n            \"ProgMinT\",\n            \"ProgMaxT\",\n            \"ProgVlm\",\n            \"RemActP\",\n            \"RemMinP\",\n            \"RemMaxP\",\n            \"RemMinT\",\n            \"RemMaxT\",\n        ]\n        feature_names = [f\"prev_{ftype}_{bname}\" for ftype in feature_types for bname in base_names]\n        results = pd.DataFrame(np.nan, index=df.index, columns=feature_names)\n\n        for idx, row in df.iterrows():\n            stats = self._get_prev_daytype_cycle_stats(row, df)\n            results.loc[idx] = stats\n\n        return pd.concat([df, results], axis=1)\n\n    def _get_prev_daytype_cycle_stats(self, row: pd.Series, historical_df: pd.DataFrame) -> Tuple:\n        t_now = row.name\n        time_elapsed = 24 - row.get(\"time_to_exp1_hr\", 0)\n        nan_stats = (np.nan,) * 33\n\n        def get_prev_cycle_start(ref_time: pd.Timestamp, target_dow: int) -> Optional[pd.Timestamp]:\n            for i in range(1, 8):\n                candidate = (ref_time - pd.Timedelta(days=i)).normalize() + pd.Timedelta(hours=self.expiration_hour)\n                if candidate.dayofweek == target_dow:\n                    return candidate\n            return None\n\n        daytype_map = {\"weekday\": [0, 1, 2, 3, 4], \"saturday\": [5], \"sunday\": [6]}\n        stats: List[float] = []\n        for ftype, dows in daytype_map.items():\n            prev_cycle_start = None\n            for dow in dows:\n                candidate = get_prev_cycle_start(t_now, dow)\n                if candidate is not None and candidate in historical_df.index:\n                    prev_cycle_start = candidate\n                    break\n            if prev_cycle_start is None:\n                stats.extend([np.nan] * 11)\n                continue\n\n            try:\n                prog_end = prev_cycle_start + pd.Timedelta(hours=time_elapsed - 1)\n                prog_data = historical_df.loc[prev_cycle_start:prog_end]\n                rem_start = prev_cycle_start + pd.Timedelta(hours=time_elapsed)\n                rem_end = prev_cycle_start + pd.Timedelta(hours=23)\n                rem_data = historical_df.loc[rem_start:rem_end]\n\n                if prog_data.empty:\n                    prog_stats = [0.0] * 6\n                else:\n                    prog_start_price = prog_data.iloc[0][\"prev_close\"]\n                    prog_end_price = prog_data.iloc[-1][\"c\"]\n                    prog_max = prog_data[\"h\"].max()\n                    prog_min = prog_data[\"l\"].min()\n                    prog_max_t = int((prog_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    prog_min_t = int((prog_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    vol_series = prog_data.get(\"volCcy_prev\")\n                    if vol_series is None and \"volCcy\" in prog_data.columns:\n                        vol_series = prog_data[\"volCcy\"].shift(1)\n                    if vol_series is None:\n                        vol_series = pd.Series(0.0, index=prog_data.index)\n                    prog_vlm = vol_series.fillna(0.0).sum()\n                    prog_actp = (prog_end_price / prog_start_price) - 1\n                    prog_maxp = (prog_max / prog_start_price) - 1\n                    prog_minp = (prog_min / prog_start_price) - 1\n                    prog_stats = [prog_actp, prog_minp, prog_maxp, prog_min_t, prog_max_t, prog_vlm]\n\n                if rem_data.empty:\n                    rem_stats = [np.nan] * 5\n                else:\n                    rem_start_price = rem_data.iloc[0][\"prev_close\"]\n                    rem_end_price = rem_data.iloc[-1][\"c\"]\n                    rem_max = rem_data[\"h\"].max()\n                    rem_min = rem_data[\"l\"].min()\n                    rem_max_t = int((rem_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    rem_min_t = int((rem_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    rem_actp = (rem_end_price / rem_start_price) - 1\n                    rem_maxp = (rem_max / rem_start_price) - 1\n                    rem_minp = (rem_min / rem_start_price) - 1\n                    rem_stats = [rem_actp, rem_minp, rem_maxp, rem_min_t, rem_max_t]\n\n                stats.extend(prog_stats + rem_stats)\n            except Exception:\n                stats.extend([np.nan] * 11)\n\n        if len(stats) != 33:\n            return nan_stats\n        return tuple(stats)\n\n    def _add_rolling_stats_for_prev_daytype_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        stat_cols = [\n            col\n            for col in df.columns\n            if col.startswith(\"prev_\")\n            and (\n                col.endswith(\"_ProgMaxP\")\n                or col.endswith(\"_RemMaxP\")\n                or col.endswith(\"_ProgMinP\")\n                or col.endswith(\"_RemMinP\")\n            )\n        ]\n        grouped = df.groupby([\"day_type_num\", \"time_to_exp1_hr\"], group_keys=False)\n        for col in stat_cols:\n            df[f\"{col}_med_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).median()\n            )\n            df[f\"{col}_p10_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.1)\n            )\n            df[f\"{col}_p90_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.9)\n            )\n        return df\n\n    def _add_empirical_probability_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_cols = {\"logret_h_pc\", \"logret_l_pc\"}\n        if not required_cols.issubset(df.columns):\n            raise ValueError(\"Empirical probability features require logret_h_pc and logret_l_pc\")\n\n        thresholds = self.empirical_thresholds\n        for t in thresholds:\n            df[f\"emp_freq_logret_h_pc_ge_{t}\"] = np.nan\n            df[f\"emp_freq_logret_l_pc_le_-{t}\"] = np.nan\n\n        for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n            df[f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = np.nan\n            df[f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = np.nan\n\n        df[\"emp_median_logret_range\"] = np.nan\n        if \"realized_to_expected_24h\" in df.columns:\n            df[\"emp_median_realized_to_expected_24h\"] = np.nan\n        if \"realized_to_expected_tte\" in df.columns:\n            df[\"emp_median_realized_to_expected_tte\"] = np.nan\n\n        grouped = df.groupby([\"hour\", \"day_type_num\"])\n        for (hour, day_type), group in grouped:\n            idx = group.index\n            for t in thresholds:\n                up_mask = (group[\"logret_h_pc\"] >= t).astype(float)\n                down_mask = (group[\"logret_l_pc\"] <= -t).astype(float)\n                up_prob = up_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                down_prob = down_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                df.loc[idx, f\"emp_freq_logret_h_pc_ge_{t}\"] = up_prob.values\n                df.loc[idx, f\"emp_freq_logret_l_pc_le_-{t}\"] = down_prob.values\n\n            for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n                up_pct = group[\"logret_h_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                down_pct = group[\"logret_l_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = up_pct.values\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = down_pct.values\n\n            logret_range = group[\"logret_h_pc\"] - group[\"logret_l_pc\"]\n            median_range = logret_range.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).median().shift(1)\n            df.loc[idx, \"emp_median_logret_range\"] = median_range.values\n\n            if \"realized_to_expected_24h\" in group.columns:\n                rte24 = group[\"realized_to_expected_24h\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_24h\"] = rte24.values\n\n            if \"realized_to_expected_tte\" in group.columns:\n                rtette = group[\"realized_to_expected_tte\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_tte\"] = rtette.values\n\n        return df\n\n\nclass FeatureEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"High-level orchestrator for the tiered feature pipeline.\"\"\"\n\n    def __init__(self,\n                 expiration_hour: int = 8,\n                 vol_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vlm_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vol_types_to_calc: Iterable[str] = (\"raw\", \"gkyz\", \"parkinson\", \"skew\", \"kurtosis\", \"vol_zscore\", \"log_vol\"),  ## rememebr to manage based on rocket or catboost\n                 vol_trading_periods: int = 24 * 365,\n                 include_price: bool = False,\n                 include_trend: bool = True,\n                 include_volatility: bool = True,\n                 include_relative_position: bool = True,\n                 include_temporal: bool = True,\n                 include_liquidity: bool = True,\n                 include_non_linear: bool = True,\n                 include_custom_interactions: bool = False,\n                 include_prev_week_cycle: bool = True,\n                 include_dst_feature: bool = True,\n                 cache_dir: Optional[Path] = Path(\"cache\") / \"heavy_features\",\n                 verbose: bool = False) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_price = include_price\n        self.include_trend = include_trend\n        self.include_volatility = include_volatility\n        self.include_relative_position = include_relative_position\n        self.include_temporal = include_temporal\n        self.include_liquidity = include_liquidity\n        self.include_non_linear = include_non_linear\n        self.include_custom_interactions = include_custom_interactions\n        self.include_prev_week_cycle = include_prev_week_cycle\n        self.include_dst_feature = include_dst_feature\n        self.verbose = verbose\n        self.vol_window_sizes = list(vol_window_sizes)\n        self.vlm_window_sizes = list(vlm_window_sizes)\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.prev_daytype_window = DEFAULT_PREV_DAYTYPE_WINDOW\n        self.empirical_window = DEFAULT_EMPIRICAL_WINDOW\n        self.empirical_min_count = DEFAULT_EMPIRICAL_MIN_COUNT\n        self.empirical_thresholds = list(DEFAULT_EMPIRICAL_THRESHOLDS)\n\n        self.stateless_block = StatelessFeatureBlock(expiration_hour, include_dst_feature)\n        self.rolling_block = RollingFeatureBlock(self.vol_window_sizes,\n                                                 self.vlm_window_sizes,\n                                                 self.vol_types_to_calc,\n                                                 self.vol_trading_periods)\n        self.complex_block = ComplexFeatureBlock(self.prev_daytype_window,\n                                                 self.empirical_window,\n                                                 self.empirical_min_count,\n                                                 self.empirical_thresholds)\n        self.complex_block.expiration_hour = expiration_hour\n\n        self.heavy_cache = HeavyFeatureCache(cache_dir)\n        self.live_state = None\n        self.feature_names_out_ = None\n        self._full_reference = None\n        self._reference_features = None\n        self._heavy_payload: Optional[HeavyFeaturePayload] = None\n\n    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):\n        reference = self._prepare_reference_frame(X)\n        self._full_reference = reference\n\n        self._log(f\"fit start; rows={len(reference)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(reference, build_heavy=True)\n        self.feature_names_out_ = features.columns.tolist()\n        self._reference_features = features\n        duration = time.perf_counter() - start\n        self._log(\n            f\"fit complete; rows={len(reference)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return self\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        if self._full_reference is None:\n            raise RuntimeError(\"fit() must be called before transform().\")\n        frame = self._prepare_reference_frame(X)\n        self._log(f\"transform start; rows={len(frame)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(frame, build_heavy=False)\n        duration = time.perf_counter() - start\n        self._log(\n            f\"transform complete; rows={len(frame)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return features\n\n    # Live update API -------------------------------------------------\n    def initialize_live_state(self, historical_df: pd.DataFrame) -> LiveStateCache:\n        features = self.transform(historical_df)\n        price_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in historical_df.columns]\n        price_history = historical_df.loc[features.index, price_cols]\n        metadata = {\"max_history\": self._live_history_window()}\n        self.live_state = LiveStateCache(\n            features_df=features.copy(),\n            price_history=price_history.copy(),\n            rolling_states={},\n            ema_states={},\n            metadata=metadata,\n        )\n        return self.live_state\n\n    def compute_next_row(self, new_row: pd.Series, *, commit: bool = False) -> pd.Series:\n        self._ensure_live_state_ready()\n        if not isinstance(new_row.name, pd.Timestamp):\n            raise TypeError(\"New row must have a DatetimeIndex timestamp as its name.\")\n\n        if not self.live_state.price_history.empty:\n            last_index = self.live_state.price_history.index[-1]\n            if new_row.name <= last_index:\n                raise ValueError(\n                    f\"New row timestamp {new_row.name} must be greater than last history index {last_index}.\"\n                )\n\n        return self._append_live_row(new_row, commit=commit)\n\n    def _live_history_window(self) -> int:\n        return max(self.vol_window_sizes + self.vlm_window_sizes + [24 * 30]) + 5\n\n    def update_last_row(self, updated_row: pd.Series, *, commit: bool = True) -> pd.Series:\n        self._ensure_live_state_ready()\n        if self.live_state.price_history.empty:\n            raise RuntimeError(\"Live state history is empty; cannot update last row.\")\n        if not isinstance(updated_row.name, pd.Timestamp):\n            raise TypeError(\"Updated row must have a DatetimeIndex timestamp as its name.\")\n        last_index = self.live_state.price_history.index[-1]\n        if updated_row.name != last_index:\n            raise ValueError(\n                f\"Updated row timestamp {updated_row.name} does not match last history index {last_index}.\"\n            )\n        return self._update_live_last_row(updated_row, commit=commit)\n\n    def ingest_live_row(self, row: pd.Series, *, commit: bool = True) -> pd.Series:\n        \"\"\"Ingest a streaming bar, updating or appending as needed.\n\n        If ``row.name`` (timestamp) matches the most recent entry, the cached\n        features are recomputed for that bar. If the timestamp is newer than the\n        cached history, the bar is appended. Rows older than the last cached bar\n        raise a ``ValueError``.\n        \"\"\"\n\n        self._ensure_live_state_ready()\n        if not isinstance(row.name, pd.Timestamp):\n            raise TypeError(\"Row must have a DatetimeIndex timestamp as its name.\")\n\n        if self.live_state.price_history.empty:\n            return self._append_live_row(row, commit=commit)\n\n        last_index = self.live_state.price_history.index[-1]\n        if row.name > last_index:\n            return self._append_live_row(row, commit=commit)\n        if row.name == last_index:\n            return self._update_live_last_row(row, commit=commit)\n\n        raise ValueError(\n            f\"Row timestamp {row.name} precedes the last cached timestamp {last_index}; \"\n            \"historical backfills are not supported by ingest_live_row().\"\n        )\n\n    def _ensure_live_state_ready(self) -> None:\n        if self.live_state is None:\n            raise RuntimeError(\"Live state not initialized; call initialize_live_state() first.\")\n        if self._heavy_payload is None and self.include_prev_week_cycle:\n            if not self.heavy_cache.load():\n                raise RuntimeError(\"Heavy cache unavailable; run fit() to build heavy features.\")\n            self._heavy_payload = self.heavy_cache.payload\n\n    def _append_live_row(self, new_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_cols = self.live_state.price_history.columns\n        missing_cols = [col for col in price_cols if col not in new_row.index]\n        if missing_cols:\n            raise ValueError(f\"New row missing required columns: {missing_cols}\")\n\n        history_frame = self.live_state.price_history\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) >= max_history:\n            trimmed_history = history_frame.tail(max_history - 1)\n        else:\n            trimmed_history = history_frame\n\n        new_price_frame = new_row[price_cols].to_frame().T\n        candidate_history = pd.concat([trimmed_history, new_price_frame])\n        features = self._compute_all_features(candidate_history, build_heavy=False)\n        new_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.append(new_features, new_row[price_cols])\n        return new_features\n\n    def _update_live_last_row(self, updated_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_history = self.live_state.price_history\n        price_cols = price_history.columns\n        missing_cols = [col for col in price_cols if col not in updated_row.index]\n        if missing_cols:\n            raise ValueError(f\"Updated row missing required columns: {missing_cols}\")\n\n        last_index = price_history.index[-1]\n        history_frame = price_history.copy()\n        history_frame.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) > max_history:\n            trimmed_history = history_frame.tail(max_history)\n        else:\n            trimmed_history = history_frame\n\n        features = self._compute_all_features(trimmed_history, build_heavy=False)\n        updated_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.features_df.loc[last_index] = updated_features\n            self.live_state.price_history.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        return updated_features\n\n    # --- Internal helpers --------------------------------------------\n\n    def _prepare_reference_frame(self, df: pd.DataFrame) -> pd.DataFrame:\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must use a DatetimeIndex.\")\n        frame = df.copy()\n        if frame.index.tz is not None:\n            frame = frame.tz_localize(None)\n        if not frame.index.is_monotonic_increasing:\n            frame = frame.sort_index()\n        return frame\n\n    def _compute_all_features(self, df: pd.DataFrame, *, build_heavy: bool) -> pd.DataFrame:\n        timings: List[Tuple[str, float]] = []\n\n        suppress_warnings = not self.verbose\n        warnings_ctx = warnings.catch_warnings() if suppress_warnings else nullcontext()\n        with warnings_ctx:\n            if suppress_warnings:\n                warnings.simplefilter(\"ignore\", category=pd.errors.PerformanceWarning)\n                warnings.simplefilter(\"ignore\", category=pd.errors.SettingWithCopyWarning)\n\n            t_start = time.perf_counter()\n            stateless = self.stateless_block.compute(df)\n            timings.append((\"stateless\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = pd.concat([df, stateless], axis=1)\n            if \"volCcy\" in working.columns:\n                working[\"volCcy\"] = working[\"volCcy\"].round()\n            timings.append((\"merge_stateless\", time.perf_counter() - t_start))\n\n            if self.include_temporal:\n                t_start = time.perf_counter()\n                working = self._add_temporal_features(working)\n                timings.append((\"temporal\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            rolling = self.rolling_block.compute(working)\n            working = pd.concat([working, rolling], axis=1)\n            timings.append((\"rolling\", time.perf_counter() - t_start))\n\n            if self.include_prev_week_cycle:\n                t_start = time.perf_counter()\n                if build_heavy or self._heavy_payload is None:\n                    payload = self.complex_block.build_payload(working)\n                    self.heavy_cache.save(payload)\n                    self._heavy_payload = payload\n                else:\n                    payload = self._heavy_payload\n                heavy_df = self._render_heavy_features(working, payload)\n                working = pd.concat([working, heavy_df], axis=1)\n                timings.append((\"prev_week_cycle\", time.perf_counter() - t_start))\n\n            # Add current cycle features (fast computation, not cached)\n            t_start = time.perf_counter()\n            working = self._add_current_cycle_features(working)\n            timings.append((\"current_cycle\", time.perf_counter() - t_start))\n\n            if self.include_non_linear:\n                t_start = time.perf_counter()\n                working = self._add_non_linear_features(working)\n                timings.append((\"non_linear\", time.perf_counter() - t_start))\n            if self.include_custom_interactions:\n                t_start = time.perf_counter()\n                working = self._add_custom_interactions(working)\n                timings.append((\"custom_interactions\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = working.replace([np.inf, -np.inf], np.nan)\n            working = self._apply_feature_toggles(working)\n            working = working.copy()\n            timings.append((\"cleanup\", time.perf_counter() - t_start))\n\n            if self.verbose:\n                total = sum(duration for _, duration in timings)\n                summary = \", \".join(\n                    f\"{name}:{duration * 1000:.1f}ms\" for name, duration in timings if duration > 0.0\n                )\n                self._log(\n                    f\"feature build complete; rows={len(df)}, cols={working.shape[1]}, total={total:.2f}s [{summary}]\"\n                )\n            return working\n\n    def _log(self, message: str) -> None:\n        if self.verbose:\n            print(f\"[FeatureEngineer] {message}\")\n\n    def _render_heavy_features(self, df: pd.DataFrame, payload: HeavyFeaturePayload) -> pd.DataFrame:\n        pieces: List[pd.DataFrame] = []\n        tte_bucket = self.complex_block._bucket_time_to_exp(df[\"time_to_exp1_hr\"])\n        day_type = df[\"day_type_num\"]\n        hour = df[\"hour\"]\n\n        if not payload.prev_cycle_lookup.empty:\n            idx = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_lookup.index.names,\n            )\n            prev_cycle = payload.prev_cycle_lookup.reindex(idx)\n            prev_cycle.index = df.index\n            pieces.append(prev_cycle)\n\n        if not payload.prev_cycle_stats_lookup.empty:\n            idx_stats = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_stats_lookup.index.names,\n            )\n            stats_df = payload.prev_cycle_stats_lookup.reindex(idx_stats)\n            stats_df.index = df.index\n            pieces.append(stats_df)\n\n        if not payload.empirical_lookup.empty:\n            idx_emp = pd.MultiIndex.from_arrays(\n                [hour.values, day_type.values],\n                names=payload.empirical_lookup.index.names,\n            )\n            emp_df = payload.empirical_lookup.reindex(idx_emp)\n            emp_df.index = df.index\n            pieces.append(emp_df)\n\n        if not pieces:\n            return pd.DataFrame(index=df.index)\n        heavy_df = pd.concat(pieces, axis=1)\n        return heavy_df\n\n    def _apply_feature_toggles(self, df: pd.DataFrame) -> pd.DataFrame:\n        result = df\n\n        if not self.include_price:\n            drop_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in result.columns]\n            result = result.drop(columns=drop_cols)\n        if not self.include_trend:\n            #trend_prefixes = (\"sma_\", \"ema_\", \"momentum_\", \"macd\", \"adx\")  # dont want sma and ema in features as they are prices \n            trend_prefixes = (\"momentum_\", \"macd\", \"adx\")\n            trend_cols = [col for col in result.columns if col.startswith(trend_prefixes)]\n            result = result.drop(columns=trend_cols, errors=\"ignore\")\n        if not self.include_volatility:\n            vol_prefixes = (\"vol_\", \"returns_skew\", \"returns_kurtosis\", \"atr_\", \"log_vol_\")\n            vol_cols = [col for col in result.columns if col.startswith(vol_prefixes)]\n            result = result.drop(columns=vol_cols, errors=\"ignore\")\n        if not self.include_relative_position:\n            rel_prefixes = (\"stoch_pos_\", \"dist_from_\", \"price_rank_\", \"new_24h\")\n            rel_cols = [col for col in result.columns if col.startswith(rel_prefixes)]\n            result = result.drop(columns=rel_cols, errors=\"ignore\")\n        if not self.include_liquidity:\n            vlm_cols = [col for col in result.columns if col.startswith(\"vlm_\")]\n            result = result.drop(columns=vlm_cols, errors=\"ignore\")\n        if not self.include_temporal:\n            temporal_cols = [col for col in [\"tte_phase_cos\", \"tte_phase_sin\", \"is_dst\"] if col in result.columns]\n            result = result.drop(columns=temporal_cols, errors=\"ignore\")\n        helper_cols = [col for col in [\"cycle_id\", \"_cycle_start_ts\", \"_tte_bucket\"] if col in result.columns]\n        if helper_cols:\n            result = result.drop(columns=helper_cols, errors=\"ignore\")\n        return result\n\n    def _add_temporal_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        df = df.copy()\n        tte = df[\"time_to_exp1_hr\"]\n        df[\"tte_phase_cos\"] = np.cos(2 * np.pi * tte / 24)\n        df[\"tte_phase_sin\"] = np.sin(2 * np.pi * tte / 24)\n        return df\n\n    def _add_non_linear_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_base = {\"c\", \"h\", \"l\"}\n        if not required_base.issubset(df.columns):\n            return df\n\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None and \"volCcy\" in df.columns:\n            vol_series = df[\"volCcy\"].shift(1)\n        if vol_series is None:\n            return df\n\n        working = df.copy()\n        if \"volCcy_prev\" not in working.columns:\n            working[\"volCcy_prev\"] = vol_series\n        if \"vol_gkyz_24h\" not in working.columns:\n            working[\"vol_gkyz_24h\"] = 0.0\n        if \"vlm_ma_24h\" not in working.columns:\n            working[\"vlm_ma_24h\"] = vol_series.rolling(24, min_periods=1).mean()\n\n        working = self._add_vol_volume_interactions(working)\n        working = self._add_higher_order_momentum(working)\n        working = self._add_non_linear_range_features(working)\n        working = self._add_liquidity_shock_features(working, vol_series)\n        working = self._add_time_decay_features(working)\n        working = self._add_tail_specific_features(working)\n        working = self._add_time_to_expiry_interactions(working)\n        return working\n\n    def _add_time_to_expiry_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes scaling: t\n        \n        key_features = [\n            \"vol_gkyz_24h\",\n            \"vlm_ma_24h\",\n            \"returns_kurtosis_24h\",\n            \"returns_skew_24h\",\n            \"extreme_prob\",\n            \"vol_clustering\",\n            \"exp_ret_p90_24h\",\n            \"exp_ret_p10_24h\",\n            \"exp_band_width_24h\",\n            \"exp_ret_p90_tte\",\n            \"exp_ret_p10_tte\",\n            \"exp_band_width_tte\",\n        ]\n        for feat in key_features:\n            if feat in df.columns:\n                # Black-Scholes t scaling (most important for volatility)\n                df[f\"{feat}_x_tte_sqrt\"] = df[feat] * tte_sqrt\n                # Linear scaling (for non-vol features)\n                df[f\"{feat}_x_tte\"] = df[feat] * tte\n                # Higher order terms for capturing non-linear time decay\n                df[f\"{feat}_x_tte_sq\"] = df[feat] * (tte ** 2)\n                df[f\"{feat}_x_tte_cu\"] = df[feat] * (tte ** 3)\n        return df\n\n    def _add_vol_volume_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        cols = [\"vol_gkyz_24h\", \"vlm_ma_24h\", \"returns_1h\"]\n        if not all(col in df.columns for col in cols):\n            return df\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"vol_weighted_vol\"] = safe_vol * np.log1p(safe_vlm)\n        df[\"vol_vlm_ratio_change\"] = (safe_vol / safe_vlm).pct_change().fillna(0)\n        df[\"asym_vol_vlm_impact\"] = np.sign(df[\"returns_1h\"]) * (safe_vol ** 2) * np.sqrt(safe_vlm)\n        return df\n\n    def _add_current_cycle_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add current cycle progress features to transform pipeline.\n        \n        Fast computation of current cycle state for 'where we are now' context.\n        Complements previous cycle features with current positioning.\n        \"\"\"\n        # Only compute if we have the required OHLC data\n        required_cols = [\"h\", \"l\", \"c\", \"prev_close\"]\n        if not all(col in df.columns for col in required_cols):\n            if self.verbose:\n                missing = [col for col in required_cols if col not in df.columns]\n                print(f\"Skipping current cycle features - missing columns: {missing}\")\n            return df\n        \n        return self.complex_block._add_current_cycle_progress_features(df)\n\n    def _add_higher_order_momentum(self, df: pd.DataFrame) -> pd.DataFrame:\n        for w in [6, 12, 24]:\n            col = f\"momentum_{w}h\"\n            if col in df.columns:\n                df[f\"momentum_accel_{w}h\"] = df[col] * df[col].diff()\n        if \"momentum_24h\" in df.columns:\n            momentum_24 = df[\"momentum_24h\"]\n            df[\"signed_momentum_power\"] = np.sign(momentum_24) * np.abs(momentum_24) ** 1.5\n            if \"vol_gkyz_24h\" in df.columns:\n                df[\"mom_vol_interaction\"] = momentum_24 * df[\"vol_gkyz_24h\"].rolling(6, min_periods=1).std()\n        return df\n\n    def _add_non_linear_range_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"range_pc\" not in df.columns:\n            df[\"range_pc\"] = (df[\"h\"].shift(1) - df[\"l\"].shift(1)) / df[\"prev_close\"].replace(0, np.nan)\n        if \"vol_gkyz_24h\" not in df.columns:\n            df[\"vol_gkyz_24h\"] = 0.0\n        if \"close_pos_in_bar\" not in df.columns:\n            range_bar = df[\"h\"].shift(1) - df[\"l\"].shift(1)\n            df[\"close_pos_in_bar\"] = np.where(\n                range_bar.abs() > 1e-9,\n                (df[\"c\"].shift(1) - df[\"l\"].shift(1)) / range_bar,\n                0.5,\n            )\n\n        range_pc = df[\"range_pc\"]\n        vol_24 = df[\"vol_gkyz_24h\"]\n        close_pos = df[\"close_pos_in_bar\"].clip(0, 1)\n        range_ma = range_pc.rolling(24, min_periods=1).mean().clip(lower=1e-9)\n        df[\"compressed_range_vol\"] = np.sqrt(range_pc.clip(lower=0)) * vol_24\n        df[\"range_expansion\"] = (range_pc / range_ma) ** 2\n        df[\"nl_pos_in_range\"] = np.sin(np.pi * close_pos) * vol_24\n        return df\n\n    def _add_liquidity_shock_features(self, df: pd.DataFrame, vol_series: pd.Series) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"vlm_ma_24h\"}\n        if not required.issubset(df.columns):\n            return df\n\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        df[\"volume_surprise\"] = (vol_series - df[\"vlm_ma_24h\"]) / (safe_vlm * safe_vol)\n        df[\"liq_vol\"] = vol_series.rolling(6, min_periods=2).std() / safe_vlm\n        df[\"liq_vol_ratio_change\"] = (safe_vlm / safe_vol).pct_change().rolling(6, min_periods=2).mean()\n        trend_std = safe_vlm.rolling(24, min_periods=5).std().clip(lower=1e-6)\n        df[\"volume_trend_z\"] = (vol_series - safe_vlm) / trend_std\n        return df\n\n    def _add_time_decay_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"returns_1h\" in df.columns:\n            returns = df[\"returns_1h\"]\n            for w in [6, 12, 24]:\n                weights = np.exp(-np.linspace(0, 1, w))\n                weights /= weights.sum()\n                df[f\"exp_decay_ret_{w}h\"] = returns.rolling(w).apply(\n                    lambda x, wts=weights[::-1]: float(np.dot(x, wts)), raw=True\n                )\n        if \"vol_gkyz_24h\" in df.columns and \"time_to_exp1_hr\" in df.columns:\n            df[\"time_adj_vol\"] = df[\"vol_gkyz_24h\"] * (1 + df[\"time_to_exp1_hr\"] / 24)\n        if {\"vol_gkyz_24h\", \"tte_phase_sin\", \"tte_phase_cos\"}.issubset(df.columns):\n            df[\"cyclical_vol_compression\"] = (\n                df[\"tte_phase_sin\"] * df[\"vol_gkyz_24h\"] +\n                df[\"tte_phase_cos\"] * df[\"vol_gkyz_24h\"].diff()\n            )\n        return df\n\n    def _add_tail_specific_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"returns_kurtosis_24h\", \"returns_skew_24h\"}\n        if not required.issubset(df.columns):\n            return df\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"extreme_prob\"] = (\n            df[\"returns_kurtosis_24h\"] * df[\"returns_skew_24h\"] * safe_vol\n        ).rolling(12, min_periods=3).mean()\n        df[\"vol_clustering\"] = (df[\"vol_gkyz_24h\"].diff() > 0).rolling(24, min_periods=6).sum() * safe_vol\n        return df\n\n    def _add_custom_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        def safe_div(a: pd.Series, b: pd.Series, eps: float = 1e-8) -> pd.Series:\n            denom = b.replace(0, np.nan).fillna(eps)\n            return a / denom\n\n        # Original interactions\n        if {\"pWRemMaxP_p90_vs_median_spread\", \"vol_gkyz_24h_x_tte\"}.issubset(df.columns):\n            df[\"pWRem_spread_to_vol\"] = safe_div(\n                df[\"pWRemMaxP_p90_vs_median_spread\"],\n                df[\"vol_gkyz_24h_x_tte\"].abs() + 1e-6,\n            )\n        if {\"cWProgMaxP_vs_p90_upside\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"progmax_vs_vol\"] = safe_div(df[\"cWProgMaxP_vs_p90_upside\"], df[\"vol_gkyz_24h\"].abs() + 1e-6)\n        if {\"returns_1h\", \"vol_gkyz_24h\", \"vlm_ma_24h\"}.issubset(df.columns):\n            df[\"shock_absorption\"] = df[\"returns_1h\"] * safe_div(df[\"vol_gkyz_24h\"], df[\"vlm_ma_24h\"])\n        \n        # Critical new interactions for direct target optimization\n        df = self._add_tte_volatility_interactions(df)\n        df = self._add_weekend_regime_interactions(df)\n        df = self._add_cycle_progress_interactions(df) \n        df = self._add_extreme_event_interactions(df)\n        \n        return df\n    \n    def _add_tte_volatility_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add time-to-expiry  volatility interactions crucial for return prediction\"\"\"\n        \n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n            \n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes: t\n        tte_normalized = tte / 168  # Normalize by week\n        \n        # Core TTE  volatility combinations\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\", \"vol_gkyz_288h\",\n                       \"vol_raw_24h\", \"vol_raw_288h\"]  # Include raw vol for consistency\n        \n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                # Black-Scholes t scaling (PRIMARY for volatility  expected move)\n                df[f\"{vol_feat}_x_tte_sqrt\"] = df[vol_feat] * tte_sqrt\n                \n                # Linear TTE (for regime/level effects)\n                df[f\"{vol_feat}_x_tte\"] = df[vol_feat] * tte\n                \n                # Squared TTE (for strong time decay near expiry)\n                df[f\"{vol_feat}_x_tte_sq\"] = df[vol_feat] * (tte_normalized ** 2)\n                \n                # Cyclical TTE effects (captures intraday patterns)\n                if \"tte_phase_sin\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_sin\"] = df[vol_feat] * df[\"tte_phase_sin\"]\n                if \"tte_phase_cos\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_cos\"] = df[vol_feat] * df[\"tte_phase_cos\"]\n        \n        # Volatility term structure  TTE (all three scalings)\n        if {\"vol_gkyz_3h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            vol_term_slope = df[\"vol_gkyz_24h\"] - df[\"vol_gkyz_3h\"]\n            df[\"vol_term_x_tte_sqrt\"] = vol_term_slope * tte_sqrt  # Black-Scholes scaling\n            df[\"vol_term_x_tte\"] = vol_term_slope * tte\n            df[\"vol_term_x_tte_sq\"] = vol_term_slope * (tte_normalized ** 2)\n        \n        return df\n    \n    def _add_weekend_regime_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add weekend/weekday regime-specific interactions\"\"\"\n        \n        if \"is_weekend\" not in df.columns:\n            return df\n            \n        # Weekend-specific volatility behavior\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                df[f\"{vol_feat}_weekend\"] = df[vol_feat] * df[\"is_weekend\"]\n                df[f\"{vol_feat}_weekday\"] = df[vol_feat] * (1 - df[\"is_weekend\"])\n        \n        # Weekend  previous cycle progress (leveraging historical weekend patterns)\n        prev_weekend_cycles = ['prev_saturday', 'prev_sunday'] \n        prev_cycle_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        \n        for weekend_cycle in prev_weekend_cycles:\n            for metric in prev_cycle_metrics:\n                prev_feat = f\"{weekend_cycle}_{metric}\"\n                if prev_feat in df.columns:\n                    df[f\"{prev_feat}_weekend\"] = df[prev_feat] * df[\"is_weekend\"]\n        \n        # Weekend  volume effects\n        if \"vlm_ma_24h\" in df.columns:\n            df[\"volume_weekend_effect\"] = df[\"vlm_ma_24h\"] * df[\"is_weekend\"]\n        \n        return df\n        \n    def _add_cycle_progress_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add previous cycle progress  market condition interactions\n        \n        Note: Uses 'prev_' cycle features (weekday/saturday/sunday) which track \n        complete historical cycles, not current incomplete cycle progress.\n        This is superior for prediction as it uses complete cycle information.\n        \"\"\"\n        \n        # Previous cycle progress features (complete historical cycles)\n        prev_cycle_types = ['prev_weekday', 'prev_saturday', 'prev_sunday']\n        prog_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        vol_features = [\"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        \n        # Previous cycle progress  volatility interactions\n        for cycle_type in prev_cycle_types:\n            for prog_metric in prog_metrics:\n                prog_feature = f\"{cycle_type}_{prog_metric}\"\n                if prog_feature in df.columns:\n                    for vol_feat in vol_features:\n                        if vol_feat in df.columns:\n                            # Use simpler naming pattern to match existing interactions\n                            interaction_name = f\"{prog_feature}_x_{vol_feat.replace('vol_gkyz_', 'vol')}\"\n                            df[interaction_name] = df[prog_feature] * df[vol_feat]\n        \n        # Previous cycle range  volatility (more stable than current cycle)\n        for cycle_type in prev_cycle_types:\n            max_feat = f\"{cycle_type}_ProgMaxP\"\n            min_feat = f\"{cycle_type}_ProgMinP\"\n            if {max_feat, min_feat, \"vol_gkyz_12h\"}.issubset(df.columns):\n                cycle_range = df[max_feat] - df[min_feat]\n                df[f\"{cycle_type}_range_x_vol\"] = cycle_range * df[\"vol_gkyz_12h\"]\n        \n        # Cross-regime cycle comparisons (weekday vs weekend behavior)\n        if {\"prev_weekday_ProgActP\", \"prev_saturday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_saturday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_saturday_ProgActP\"]\n        \n        if {\"prev_weekday_ProgActP\", \"prev_sunday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_sunday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_sunday_ProgActP\"]\n        \n        # Previous cycle activity  time effects\n        if {\"prev_weekday_ProgActP\", \"hour_of_week_sin\"}.issubset(df.columns):\n            df[\"prev_cycle_progress_x_hour\"] = df[\"prev_weekday_ProgActP\"] * df[\"hour_of_week_sin\"]\n            \n        return df\n    \n    def _add_extreme_event_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add interactions specifically designed for extreme event prediction\"\"\"\n        \n        # Compressed range  volatility for tail events\n        if {\"compressed_range_vol\", \"vol_gkyz_3h\"}.issubset(df.columns):\n            df[\"extreme_range_vol\"] = df[\"compressed_range_vol\"] * df[\"vol_gkyz_3h\"]\n        \n        # Skewness  volatility for asymmetric moves\n        if {\"returns_skew_24h\", \"vol_gkyz_6h\"}.issubset(df.columns):\n            df[\"skew_vol_extreme\"] = df[\"returns_skew_24h\"] * df[\"vol_gkyz_6h\"]\n        \n        # Kurtosis  volatility for fat-tail events\n        if {\"returns_kurtosis_24h\", \"vol_gkyz_12h\"}.issubset(df.columns):\n            df[\"kurtosis_vol_extreme\"] = df[\"returns_kurtosis_24h\"] * df[\"vol_gkyz_12h\"]\n        \n        # Distance from highs  volatility for reversal prediction\n        if {\"dist_from_high_144h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"distance_vol_extreme\"] = df[\"dist_from_high_144h\"] * df[\"vol_gkyz_24h\"]\n        \n        # Volume surprise  volatility clustering\n        if {\"volume_surprise\", \"vol_clustering\"}.issubset(df.columns):\n            df[\"vol_surprise_clustering\"] = df[\"volume_surprise\"] * df[\"vol_clustering\"]\n            \n        return df\n","epoch":14,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Validates input and stores column names.\"\"\"\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        \"\"\"Calculate expiration timestamps.\"\"\"\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        \"\"\"Helper method to compute all price targets without tail indicators\"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n\n        # Pre-calculate expiration timestamps aligned to the bar close (current_ts + 1h)\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            # SAFER REFERENCE PRICE HANDLING\n            try:\n                reference_price = row['prev_close']\n                # Handle case where reference_price might be a Series (duplicate columns)\n                if isinstance(reference_price, pd.Series):\n                    if reference_price.empty or reference_price.isna().all() or (reference_price <= 1e-9).all():\n                        continue\n                    reference_price = reference_price.iloc[0]  # Take first value\n                elif pd.isna(reference_price) or reference_price <= 1e-9:\n                    continue\n            except KeyError:\n                continue  # Skip if reference price not available\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts:\n                    continue\n\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                \n                if not prices1_h.empty:\n                    # Basic price targets\n\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n\n                    # Peak/trough timing\n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    peak_offset = (max_idx - current_bar_end).total_seconds() / 3600.0\n                    trough_offset = (min_idx - current_bar_end).total_seconds() / 3600.0\n                    results['exp1_peak_frac'] = peak_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_trough_frac'] = trough_offset / window_length if window_length > 0 else np.nan\n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    # Close return\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError:\n                        pass\n                    \n                    for k, v in results.items():\n                        targets_df.at[current_ts, k] = v\n\n        return targets_df\n\n\n\n    def _calculate_absolute_expiry_targets(self, X):\n        \"\"\"\n        For each expiry window, compute the absolute peak/trough and their times.\n        Assign these to all rows in the window.\n        Also computes absolute min/max for the following expiry window (exp2).\n        \"\"\"\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        prev_close = X['prev_close']\n\n        # Map each timestamp to its expiry window start and end\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp2_times = pd.Series({ts: exp[1] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0:\n                continue\n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            # Use the close from the row immediately before the window start (even if exp_start is not in index)\n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx >= 0:\n                prev_close_ts = X.index[prev_idx]\n                window_prev_close = X.loc[prev_close_ts, 'c']\n            else:\n                window_prev_close = np.nan\n\n            if window_h.empty or pd.isna(window_prev_close) or window_prev_close <= 1e-9:\n                continue\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n\n            # Absolute peak/trough and their times for expiry 1\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            abs_max_ret = (abs_max / window_prev_close) - 1.0\n            abs_min_ret = (abs_min / window_prev_close) - 1.0\n            max_idx = window_h.idxmax()\n            min_idx = window_l.idxmin()\n            window_length = (exp_end - exp_start).total_seconds() / 3600.0\n            peak_offset = (max_idx - exp_start).total_seconds() / 3600.0\n            trough_offset = (min_idx - exp_start).total_seconds() / 3600.0\n            abs_peak_frac = peak_offset / window_length if window_length > 0 else np.nan\n            abs_trough_frac = trough_offset / window_length if window_length > 0 else np.nan\n            abs_peak_hours_to_expiry = (exp_end - max_idx).total_seconds() / 3600.0\n            abs_trough_hours_to_expiry = (exp_end - min_idx).total_seconds() / 3600.0\n\n            # Absolute mean reversion targets for expiry 1\n            if not window_c.empty:\n                close_at_expiry = window_c.iloc[-1]\n                abs_peak_to_close_ret = (close_at_expiry / abs_max) - 1.0 if abs_max > 1e-9 else np.nan\n                abs_trough_to_close_ret = (close_at_expiry / abs_min) - 1.0 if abs_min > 1e-9 else np.nan\n            else:\n                abs_peak_to_close_ret = np.nan\n                abs_trough_to_close_ret = np.nan\n\n            # abs_targets.loc[window_idx, 'window_prev_close'] = window_prev_close\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = abs_max_ret\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = abs_min_ret\n            abs_targets.loc[window_idx, 'abs_exp1_peak_frac'] = abs_peak_frac\n            abs_targets.loc[window_idx, 'abs_exp1_trough_frac'] = abs_trough_frac\n            abs_targets.loc[window_idx, 'abs_exp1_peak_hours_to_expiry'] = abs_peak_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_trough_hours_to_expiry'] = abs_trough_hours_to_expiry\n            abs_targets.loc[window_idx, 'abs_exp1_peak_to_close_ret'] = abs_peak_to_close_ret\n            abs_targets.loc[window_idx, 'abs_exp1_trough_to_close_ret'] = abs_trough_to_close_ret\n\n            # --- NEW: Absolute min/max for the following expiry window (exp2) ---\n            # Find exp2 window for this expiry\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_idx = timestamps[mask2]\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            window2_c = prices_c[mask2]\n\n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_exp2_max_ret = (abs_max_p2 / window_prev_close) - 1.0\n                abs_exp2_min_ret = (abs_min_p2 / window_prev_close) - 1.0\n                max2_idx = window2_h.idxmax()\n                min2_idx = window2_l.idxmin()\n                # Mean reversion for exp2\n                if not window2_c.empty:\n                    close_at_expiry2 = window2_c.iloc[-1]\n                    abs_peak_to_close_ret2 = (close_at_expiry2 / abs_max_p2) - 1.0 if abs_max_p2 > 1e-9 else np.nan\n                    abs_trough_to_close_ret2 = (close_at_expiry2 / abs_min_p2) - 1.0 if abs_min_p2 > 1e-9 else np.nan\n                else:\n                    abs_peak_to_close_ret2 = np.nan\n                    abs_trough_to_close_ret2 = np.nan\n\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = abs_exp2_max_ret\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = abs_exp2_min_ret\n                abs_targets.loc[window_idx, 'abs_exp2_peak_to_close_ret'] = abs_peak_to_close_ret2\n                abs_targets.loc[window_idx, 'abs_exp2_trough_to_close_ret'] = abs_trough_to_close_ret2\n\n        return abs_targets\n\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n    \n        # --- Engineered logrets ---\n        engineered_targets = [\n            'logret_up_1h', 'logret_down_1h',\n            'logret_up_3h', 'logret_down_3h',\n            'logret_up_6h', 'logret_down_6h',\n            'logret_up_12h', 'logret_down_12h',   \n            'logret_up_24h', 'logret_down_24h',\n            'next_24h_vol'    # Add realized volatility target\n        ]\n        \n        # Engineered logrets: all compare future high/low to current close\n        df['logret_up_1h'] = np.log(df['h'].shift(-1) / df['c'])\n        df['logret_down_1h'] = np.log(df['l'].shift(-1) / df['c'])\n        \n        # For 3h: max high and min low over the next 3 hours (including the next hour, not current)\n        df['logret_up_3h'] = np.log(df['h'].shift(-3).rolling(window=3, min_periods=3).max() / df['c'])\n        df['logret_down_3h'] = np.log(df['l'].shift(-3).rolling(window=3, min_periods=3).min() / df['c'])\n        \n        # For 6h: max high and min low over the next 6 hours\n        df['logret_up_6h'] = np.log(df['h'].shift(-6).rolling(window=6, min_periods=6).max() / df['c'])\n        df['logret_down_6h'] = np.log(df['l'].shift(-6).rolling(window=6, min_periods=6).min() / df['c'])\n    \n            # For 12h: max high and min low over the next 12 hours\n        df['logret_up_12h'] = np.log(df['h'].shift(-12).rolling(window=12, min_periods=12).max() / df['c'])\n        df['logret_down_12h'] = np.log(df['l'].shift(-12).rolling(window=12, min_periods=12).min() / df['c'])\n\n        # For 24h: max high and min low over the next 24 hours\n        df['logret_up_24h'] = np.log(df['h'].shift(-24).rolling(window=24, min_periods=24).max() / df['c'])\n        df['logret_down_24h'] = np.log(df['l'].shift(-24).rolling(window=24, min_periods=24).min() / df['c'])\n        \n        # --- Next 24-hour realized volatility ---\n        # Calculate close-to-close log returns for the next 24 hours\n        # This is the realized volatility that will occur over the next 24 hours\n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        # Rolling std of future returns over next 24 hours, annualized\n        # Use shift(-24) to look forward, then rolling to get the window\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n\n        # --- Calculate price targets ---\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n    \n        # Merge all targets\n        df_targets = pd.concat([price_targets, abs_targets, df[engineered_targets]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n\n        # Always filter, even if empty\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Classifies market regimes by normalizing returns into Time-Adjusted Z-Scores.\n    \n    The logic compares the 'Realized Z-Score' against your threshold parameters.\n    \n    Z-Score Formula: \n        Z = LogReturn / (1_Hour_Vol * Sqrt(Time_Window_Hours))\n        \n    Parameters\n    ----------\n    lookback_window : int, default=24\n        Hours to look back for calculating baseline volatility.\n    \n    forward_window : int, default=12\n        Hours to look forward for Trend detection.\n        \n    trend_std : float, default=1.5\n        Z-Score threshold for Trend. \n        (e.g., 1.5 means the move is 1.5x larger than a normal random walk over forward_window).\n        \n    jump_std : float, default=3.5\n        Z-Score threshold for Jump.\n        (e.g., 3.5 means the move is 3.5x larger than a normal random walk over jump_speed_window).\n        \n    jump_speed_window : int, default=3\n        Sub-window (hours) to detect fast shock moves.\n        \n    retracement_threshold : float, default=0.5\n        To qualify as a Trend, price must not retrace more than this % from the high/low.\n    \"\"\"\n    \n    def __init__(self, \n                 lookback_window: int = 24,\n                 forward_window: int = 12,\n                 trend_std: float = 1.5,\n                 jump_std: float = 3.5,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5):\n        self.lookback_window = lookback_window\n        self.forward_window = forward_window\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self._feature_names_out = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Validates input.\"\"\"\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        \n        return self\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n            \"\"\"\n            Calculate Baseline Volatility using Rogers-Satchell Estimator.\n            This provides a robust volatility estimate even with a short (24h) window.\n            \"\"\"\n            df = pd.DataFrame(index=X.index)\n            \n            # 1. Handle Zero/NaNs safely\n            safe_open = X['o'].replace(0, np.nan)\n            safe_high = X['h'].replace(0, np.nan)\n            safe_low = X['l'].replace(0, np.nan)\n            safe_close = X['c'].replace(0, np.nan)\n            \n            # 2. Compute Log Terms (The RS Formula components)\n            # Term 1: ln(High/Close) * ln(High/Open)\n            term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n            \n            # Term 2: ln(Low/Close) * ln(Low/Open)\n            term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n            \n            # 3. Calculate Variance per bar\n            rs_variance = term1 + term2\n            \n            # 4. Rolling Mean of Variance (Average Variance over 24h)\n            # We assume mean=0 for short term returns (standard RS assumption)\n            rolling_variance = rs_variance.rolling(\n                window=self.lookback_window,\n                min_periods=int(self.lookback_window * 0.75)\n            ).mean()\n            \n            # 5. Convert to Volatility (Standard Deviation)\n            # Square root of the average variance\n            box_std = np.sqrt(rolling_variance)\n            \n            df['box_std'] = box_std\n            df['reference_price'] = safe_close\n            \n            return df\n    \n    def _assign_regime_labels(self, X: pd.DataFrame, box_df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Assign regime labels and calculate realized Z-Scores.\n        \"\"\"\n        # Prepare output DataFrame\n        results = pd.DataFrame(index=X.index)\n        results['regime_label'] = pd.Series(dtype='Int64')\n        results['max_fwd_z_score'] = np.nan  # Alpha feature for XGBoost\n        results['max_jump_z_score'] = np.nan # Alpha feature for XGBoost\n        \n        safe_close = X['c'].replace(0, np.nan)\n        high = X['h']\n        low = X['l']\n        \n        # Pre-calculate time scaling factors\n        sqrt_fwd = np.sqrt(self.forward_window)\n        sqrt_jump = np.sqrt(self.jump_speed_window)\n        \n        for idx in X.index:\n            # 1. Validation\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0:\n                continue\n                \n            # 2. Get Forward Window\n            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            \n            if fwd_end_pos <= idx_pos + 1:\n                continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            fwd_closes = safe_close.loc[fwd_indices]\n            \n            if fwd_highs.empty:\n                continue\n\n            # 3. Calculate Forward Returns (Log)\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            final_close = fwd_closes.iloc[-1]\n            \n            # Max excursion from reference price\n            ret_max = np.log(max_high / ref_price)\n            ret_min = np.log(min_low / ref_price)\n            max_abs_ret = max(abs(ret_max), abs(ret_min))\n            \n            # ---------------------------------------------------------\n            # LOGIC A: CALCULATE REALIZED Z-SCORES (Time Adjusted)\n            # ---------------------------------------------------------\n            \n            # Z-Score of the full Forward Window\n            # How many sigmas did we move relative to a 12h walk?\n            # Formula: Return / (1h_Vol * sqrt(12))\n            fwd_z_score = max_abs_ret / (box_std * sqrt_fwd)\n            results.at[idx, 'max_fwd_z_score'] = fwd_z_score\n            \n            # Z-Score of the Jump Window (Scan for fastest sub-move)\n            max_jump_z = 0.0\n            \n            for i in range(len(fwd_indices) - self.jump_speed_window + 1):\n                sub_indices = fwd_indices[i : i + self.jump_speed_window]\n                s_high = high.loc[sub_indices].max()\n                s_low = low.loc[sub_indices].min()\n                \n                s_ret = max(abs(np.log(s_high/ref_price)), abs(np.log(s_low/ref_price)))\n                \n                # Formula: Return / (1h_Vol * sqrt(3))\n                current_z = s_ret / (box_std * sqrt_jump)\n                \n                if current_z > max_jump_z:\n                    max_jump_z = current_z\n            \n            results.at[idx, 'max_jump_z_score'] = max_jump_z\n\n            # ---------------------------------------------------------\n            # LOGIC B: CLASSIFICATION (Hierarchy: Jump > Trend > Chop)\n            # ---------------------------------------------------------\n            \n            # Class 2: Jump\n            # Did we move X sigmas relative to the short timeframe?\n            if max_jump_z > self.jump_std:\n                results.at[idx, 'regime_label'] = 2\n                continue\n                \n            # Class 1: Trend\n            # Did we move Y sigmas relative to the long timeframe?\n            if fwd_z_score > self.trend_std:\n                \n                # Retracement Check (Persistence)\n                # If we went up, did we close near the high?\n                if ret_max > abs(ret_min): # Uptrend\n                    dist_to_high = np.log(max_high / final_close)\n                    if dist_to_high / ret_max <= (1 - self.retracement_threshold):\n                        results.at[idx, 'regime_label'] = 1\n                else: # Downtrend\n                    dist_to_low = np.log(final_close / min_low)\n                    if dist_to_low / abs(ret_min) <= (1 - self.retracement_threshold):\n                        results.at[idx, 'regime_label'] = 1\n                        \n                # If label was assigned, break loop\n                if not pd.isna(results.at[idx, 'regime_label']):\n                    continue\n            \n            # Class 0: Chop (Default)\n            results.at[idx, 'regime_label'] = 0\n            \n        return results\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_feature_names_out')\n        \n        box_df = self._calculate_lookback_box(X)\n        results = self._assign_regime_labels(X, box_df)\n        \n        # Merge results\n        output = pd.concat([results, box_df['box_std']], axis=1)\n        output['box_std_annualized'] = output['box_std'] * np.sqrt(24 * 365)\n        \n        self._feature_names_out = list(output.columns)\n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        transformed = self.transform(X)\n        regime_counts = transformed['regime_label'].value_counts().sort_index()\n        regime_names = {\n            0: 'Class 0: Chop/Mean Reversion',\n            1: 'Class 1: Trending',\n            2: 'Class 2: Jump/Event'\n        }\n        regime_counts.index = regime_counts.index.map(lambda x: regime_names.get(x, f'Class {x}'))\n        return regime_counts\n\n\n\n","epoch":23,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb::request_bddfb2ab-dc09-4ed4-8c50-3bba87d11d28",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","scheme":"file"},"requestId":"request_bddfb2ab-dc09-4ed4-8c50-3bba87d11d28","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick smoke test that mirrors production: build features, derive targets, combine them, and prepare time-based splits.\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"65dc8abb\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":2,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"64fdc9cd-bf4b-440f-ab4a-2d62fd16c71f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L2hvbWUvZWFzdC9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvdHFkbS9hdXRvLnB5OjIxOiBUcWRtV2FybmluZzogSVByb2dyZXNzIG5vdCBmb3VuZC4gUGxlYXNlIHVwZGF0ZSBqdXB5dGVyIGFuZCBpcHl3aWRnZXRzLiBTZWUgaHR0cHM6Ly9pcHl3aWRnZXRzLnJlYWR0aGVkb2NzLmlvL2VuL3N0YWJsZS91c2VyX2luc3RhbGwuaHRtbAogIGZyb20gLmF1dG9ub3RlYm9vayBpbXBvcnQgdHFkbSBhcyBub3RlYm9va190cWRtCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"4a425eb6-ec89-4e0e-8221-0c2ead3f82c3\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkhlYXZ5IGNhY2hlIHJlYWR5OiBoZWF2eV9mZWF0dXJlc192MS5wa2wgKHRvdGFsIDEpIGluIGNhY2hlL2hlYXZ5X2ZlYXR1cmVzCkhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGUgb3IgZmFpbGVkIHRvIGxvYWQ7IHJ1bm5pbmcgZnVsbCBmaXQuCmRlcml2ZWRfcHJvYmFfY29uZmlnOiB7J2VuYWJsZWQnOiBGYWxzZSwgJ21vZGVsc19kaXJlY3RvcnknOiAncmVzZWFyY2hfdm9sL3RyYWluZWRfbW9kZWxzJywgJ2ZpbGVfcGF0dGVybic6ICdjYXRib29zdF8qX2hwdF9idW5kbGUucGtsJywgJ21vZGVsc190b191c2UnOiB7fX0KWydvJywgJ2gnLCAnbCcsICdjJywgJ3ZvbENjeScsICd0aW1lX3RvX2V4cDFfaHInLCAndGltZV9lbGFwc2VkJywgJ2hvdXInLCAnZGF5X29mX3dlZWsnLCAnaXNfd2Vla2VuZCcsICdob3VyX29mX3dlZWsnLCAnaG91cl9vZl93ZWVrX3NpbicsICdob3VyX29mX3dlZWtfY29zJywgJ2hvdXJzX3NpbmNlX3dlZWtfc3RhcnQnLCAnZGF5X3R5cGVfbnVtJywgJ3ByZXZfY2xvc2UnLCAndm9sQ2N5X3ByZXYnLCAnd2luZG93X3ByZXZfY2xvc2UnLCAncmV0dXJuc18xaCcsICdyZXR1cm5zXzJoJywgJ2xvZ3JldF8yaCcsICdyZXR1cm5zXzNoJywgJ2xvZ3JldF8zaCcsICdyZXR1cm5zXzRoJywgJ2xvZ3JldF80aCcsICdyZXR1cm5zXzVoJywgJ2xvZ3JldF81aCcsICdyZXR1cm5zXzZoJywgJ2xvZ3JldF82aCcsICdyZXR1cm5zXzEyaCcsICdsb2dyZXRfMTJoJywgJ3JldHVybnNfMjRoJywgJ2xvZ3JldF8yNGgnLCAncmV0dXJuc183MmgnLCAnbG9ncmV0XzcyaCcsICdyZXR1cm5zXzF3aycsICdyZXR1cm5zXzFNJywgJ3JldF9oX3BjJywgJ3JldF9sX3BjJywgJ3JldF9jX3BjJywgJ3JldF9oX2wnLCAncmFuZ2VfMmgnLCAncmFuZ2VfcGNfMmgnLCAncmFuZ2VfM2gnLCAncmFuZ2VfcGNfM2gnLCAncmFuZ2VfNmgnLCAncmFuZ2VfcGNfNmgnLCAncmFuZ2VfMTJoJywgJ3JhbmdlX3BjXzEyaCcsICdyYW5nZV8yNGgnLCAncmFuZ2VfcGNfMjRoJywgJ3JhbmdlJywgJ3JhbmdlX3BjJywgJ2Nsb3NlX3RvX2hpZ2gnLCAnY2xvc2VfdG9fbG93JywgJ2Nsb3NlX3Bvc19pbl9iYXInLCAnbG9ncmV0X2hfcGMnLCAnbG9ncmV0X2xfcGMnLCAnbG9ncmV0X2NfcGMnLCAnaXNfZHN0JywgJ3R0ZV9waGFzZV9jb3MnLCAndHRlX3BoYXNlX3NpbicsICdtb21lbnR1bV8zaCcsICdtb21lbnR1bV9zaWduZWRfc3FydF8zaCcsICd0cmVuZF9zdHJlbmd0aF8zaCcsICdtb21lbnR1bV82aCcsICdtb21lbnR1bV9zaWduZWRfc3FydF82aCcsICd0cmVuZF9zdHJlbmd0aF82aCcsICdtb21lbnR1bV8xMmgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfMTJoJywgJ3RyZW5kX3N0cmVuZ3RoXzEyaCcsICdtb21lbnR1bV8yNGgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfMjRoJywgJ3RyZW5kX3N0cmVuZ3RoXzI0aCcsICdtb21lbnR1bV83MmgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfNzJoJywgJ3RyZW5kX3N0cmVuZ3RoXzcyaCcsICdtb21lbnR1bV8xNDRoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzE0NGgnLCAndHJlbmRfc3RyZW5ndGhfMTQ0aCcsICdtb21lbnR1bV8yODhoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzI4OGgnLCAndHJlbmRfc3RyZW5ndGhfMjg4aCcsICdtYWNkJywgJ21hY2Rfc2lnbmFsJywgJ21hY2RfaGlzdCcsICdhZHgnLCAnYWR4X3BvcycsICdhZHhfbmVnJywgJ3N0b2NoX3Bvc18zaCcsICdkaXN0X2Zyb21faGlnaF8zaCcsICdkaXN0X2Zyb21fbG93XzNoJywgJ3ByaWNlX3JhbmtfM2gnLCAnc3RvY2hfcG9zXzZoJywgJ2Rpc3RfZnJvbV9oaWdoXzZoJywgJ2Rpc3RfZnJvbV9sb3dfNmgnLCAncHJpY2VfcmFua182aCcsICdzdG9jaF9wb3NfMTJoJywgJ2Rpc3RfZnJvbV9oaWdoXzEyaCcsICdkaXN0X2Zyb21fbG93XzEyaCcsICdwcmljZV9yYW5rXzEyaCcsICdzdG9jaF9wb3NfMjRoJywgJ2Rpc3RfZnJvbV9oaWdoXzI0aCcsICdkaXN0X2Zyb21fbG93XzI0aCcsICdwcmljZV9yYW5rXzI0aCcsICdzdG9jaF9wb3NfNzJoJywgJ2Rpc3RfZnJvbV9oaWdoXzcyaCcsICdkaXN0X2Zyb21fbG93XzcyaCcsICdwcmljZV9yYW5rXzcyaCcsICdzdG9jaF9wb3NfMTQ0aCcsICdkaXN0X2Zyb21faGlnaF8xNDRoJywgJ2Rpc3RfZnJvbV9sb3dfMTQ0aCcsICdwcmljZV9yYW5rXzE0NGgnLCAnc3RvY2hfcG9zXzI4OGgnLCAnZGlzdF9mcm9tX2hpZ2hfMjg4aCcsICdkaXN0X2Zyb21fbG93XzI4OGgnLCAncHJpY2VfcmFua18yODhoJywgJ25ld18yNGhfaGlnaCcsICduZXdfMjRoX2xvdycsICd2bG1fbWFfM2gnLCAndmxtX3pzY29yZV8zaCcsICd2bG1fbWFfNmgnLCAndmxtX3pzY29yZV82aCcsICd2bG1fbWFfMTJoJywgJ3ZsbV96c2NvcmVfMTJoJywgJ3ZsbV9tYV8yNGgnLCAndmxtX3pzY29yZV8yNGgnLCAndmxtX21hXzcyaCcsICd2bG1fenNjb3JlXzcyaCcsICd2bG1fbWFfMTQ0aCcsICd2bG1fenNjb3JlXzE0NGgnLCAndmxtX21hXzI4OGgnLCAndmxtX3pzY29yZV8yODhoJywgJ3ZvbF9yYXdfM2gnLCAndm9sX2dreXpfM2gnLCAndm9sX3BhcmtpbnNvbl8zaCcsICd2b2xfenNjb3JlXzNoJywgJ2xvZ192b2xfM2gnLCAndm9sX3Jhd182aCcsICd2b2xfZ2t5el82aCcsICd2b2xfcGFya2luc29uXzZoJywgJ3ZvbF96c2NvcmVfNmgnLCAnbG9nX3ZvbF82aCcsICd2b2xfcmF3XzEyaCcsICd2b2xfZ2t5el8xMmgnLCAndm9sX3BhcmtpbnNvbl8xMmgnLCAndm9sX3pzY29yZV8xMmgnLCAnbG9nX3ZvbF8xMmgnLCAndm9sX3Jhd18yNGgnLCAndm9sX2dreXpfMjRoJywgJ3ZvbF9wYXJraW5zb25fMjRoJywgJ3ZvbF96c2NvcmVfMjRoJywgJ2xvZ192b2xfMjRoJywgJ3ZvbF9yYXdfNzJoJywgJ3ZvbF9na3l6XzcyaCcsICd2b2xfcGFya2luc29uXzcyaCcsICd2b2xfenNjb3JlXzcyaCcsICdsb2dfdm9sXzcyaCcsICd2b2xfcmF3XzE0NGgnLCAndm9sX2dreXpfMTQ0aCcsICd2b2xfcGFya2luc29uXzE0NGgnLCAndm9sX3pzY29yZV8xNDRoJywgJ2xvZ192b2xfMTQ0aCcsICd2b2xfcmF3XzI4OGgnLCAndm9sX2dreXpfMjg4aCcsICd2b2xfcGFya2luc29uXzI4OGgnLCAndm9sX3pzY29yZV8yODhoJywgJ2xvZ192b2xfMjg4aCcsICdyZXR1cm5zX3NrZXdfMjRoJywgJ3JldHVybnNfa3VydG9zaXNfMjRoJywgJ3ZvbF9yYXRpb18yNGhfMTQ0aCcsICd2b2xfcmF0aW9fMjRoXzI4OGgnLCAnZXhwX3JldF9wOTBfMjRoJywgJ2V4cF9yZXRfcDc1XzI0aCcsICdleHBfcmV0X3AyNV8yNGgnLCAnZXhwX3JldF9wMTBfMjRoJywgJ2V4cF9iYW5kX3dpZHRoXzI0aCcsICdleHBfbG9nbW92ZV9wOTBfMjRoJywgJ2V4cF9sb2dtb3ZlX3AxMF8yNGgnLCAnZXhwX3JldF9wOTBfdHRlJywgJ2V4cF9yZXRfcDEwX3R0ZScsICdleHBfYmFuZF93aWR0aF90dGUnLCAnZXhwX2xvZ21vdmVfcDkwX3R0ZScsICdleHBfbG9nbW92ZV9wMTBfdHRlJywgJ3JlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCcsICdyZWFsaXplZF90b19leHBlY3RlZF90dGUnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFAnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5UJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4VCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbScsICdwcmV2X3dlZWtkYXlfUmVtQWN0UCcsICdwcmV2X3dlZWtkYXlfUmVtTWluUCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4UCcsICdwcmV2X3dlZWtkYXlfUmVtTWluVCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4VCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNaW5UJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFQnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtJywgJ3ByZXZfc2F0dXJkYXlfUmVtQWN0UCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblAnLCAncHJldl9zYXR1cmRheV9SZW1NYXhQJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWluVCcsICdwcmV2X3NhdHVyZGF5X1JlbU1heFQnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFAnLCAncHJldl9zdW5kYXlfUHJvZ01pblAnLCAncHJldl9zdW5kYXlfUHJvZ01heFAnLCAncHJldl9zdW5kYXlfUHJvZ01pblQnLCAncHJldl9zdW5kYXlfUHJvZ01heFQnLCAncHJldl9zdW5kYXlfUHJvZ1ZsbScsICdwcmV2X3N1bmRheV9SZW1BY3RQJywgJ3ByZXZfc3VuZGF5X1JlbU1pblAnLCAncHJldl9zdW5kYXlfUmVtTWF4UCcsICdwcmV2X3N1bmRheV9SZW1NaW5UJywgJ3ByZXZfc3VuZGF5X1JlbU1heFQnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5QX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfcDEwXzkwJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfcDEwXzkwJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1pblBfbWVkXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NaW5QX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1heFBfbWVkXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NYXhQX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4UF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9wMTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9wMTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NaW5QX21lZF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NYXhQX21lZF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1heFBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWF4UF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01pblBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3AxMF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQX3AxMF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9tZWRfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9tZWRfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9wOTBfOTAnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDAxJywgJ2VtcF9mcmVxX2xvZ3JldF9sX3BjX2xlXy0wLjAwMDEnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDA1JywgJ2VtcF9mcmVxX2xvZ3JldF9sX3BjX2xlXy0wLjAwMDUnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDEnLCAnZW1wX2ZyZXFfbG9ncmV0X2xfcGNfbGVfLTAuMDAxJywgJ2VtcF9wY3RfNV9sb2dyZXRfaF9wYycsICdlbXBfcGN0XzVfbG9ncmV0X2xfcGMnLCAnZW1wX3BjdF8zMF9sb2dyZXRfaF9wYycsICdlbXBfcGN0XzMwX2xvZ3JldF9sX3BjJywgJ2VtcF9wY3RfNTBfbG9ncmV0X2hfcGMnLCAnZW1wX3BjdF81MF9sb2dyZXRfbF9wYycsICdlbXBfcGN0XzcwX2xvZ3JldF9oX3BjJywgJ2VtcF9wY3RfNzBfbG9ncmV0X2xfcGMnLCAnZW1wX3BjdF85NV9sb2dyZXRfaF9wYycsICdlbXBfcGN0Xzk1X2xvZ3JldF9sX3BjJywgJ2VtcF9tZWRpYW5fbG9ncmV0X3JhbmdlJywgJ2VtcF9tZWRpYW5fcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfMjRoJywgJ2VtcF9tZWRpYW5fcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlJywgJ2NDUHJvZ0FjdFAnLCAnY0NQcm9nTWluUCcsICdjQ1Byb2dNYXhQJywgJ2NDUHJvZ01pblQnLCAnY0NQcm9nTWF4VCcsICdjQ1Byb2dWbG0nLCAndm9sX3dlaWdodGVkX3ZvbCcsICd2b2xfdmxtX3JhdGlvX2NoYW5nZScsICdhc3ltX3ZvbF92bG1faW1wYWN0JywgJ21vbWVudHVtX2FjY2VsXzZoJywgJ21vbWVudHVtX2FjY2VsXzEyaCcsICdtb21lbnR1bV9hY2NlbF8yNGgnLCAnc2lnbmVkX21vbWVudHVtX3Bvd2VyJywgJ21vbV92b2xfaW50ZXJhY3Rpb24nLCAnY29tcHJlc3NlZF9yYW5nZV92b2wnLCAncmFuZ2VfZXhwYW5zaW9uJywgJ25sX3Bvc19pbl9yYW5nZScsICd2b2x1bWVfc3VycHJpc2UnLCAnbGlxX3ZvbCcsICdsaXFfdm9sX3JhdGlvX2NoYW5nZScsICd2b2x1bWVfdHJlbmRfeicsICdleHBfZGVjYXlfcmV0XzZoJywgJ2V4cF9kZWNheV9yZXRfMTJoJywgJ2V4cF9kZWNheV9yZXRfMjRoJywgJ3RpbWVfYWRqX3ZvbCcsICdjeWNsaWNhbF92b2xfY29tcHJlc3Npb24nLCAnZXh0cmVtZV9wcm9iJywgJ3ZvbF9jbHVzdGVyaW5nJywgJ3ZvbF9na3l6XzI0aF94X3R0ZV9zcXJ0JywgJ3ZvbF9na3l6XzI0aF94X3R0ZScsICd2b2xfZ2t5el8yNGhfeF90dGVfc3EnLCAndm9sX2dreXpfMjRoX3hfdHRlX2N1JywgJ3ZsbV9tYV8yNGhfeF90dGVfc3FydCcsICd2bG1fbWFfMjRoX3hfdHRlJywgJ3ZsbV9tYV8yNGhfeF90dGVfc3EnLCAndmxtX21hXzI0aF94X3R0ZV9jdScsICdyZXR1cm5zX2t1cnRvc2lzXzI0aF94X3R0ZV9zcXJ0JywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlJywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlX3NxJywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlX2N1JywgJ3JldHVybnNfc2tld18yNGhfeF90dGVfc3FydCcsICdyZXR1cm5zX3NrZXdfMjRoX3hfdHRlJywgJ3JldHVybnNfc2tld18yNGhfeF90dGVfc3EnLCAncmV0dXJuc19za2V3XzI0aF94X3R0ZV9jdScsICdleHRyZW1lX3Byb2JfeF90dGVfc3FydCcsICdleHRyZW1lX3Byb2JfeF90dGUnLCAnZXh0cmVtZV9wcm9iX3hfdHRlX3NxJywgJ2V4dHJlbWVfcHJvYl94X3R0ZV9jdScsICd2b2xfY2x1c3RlcmluZ194X3R0ZV9zcXJ0JywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlJywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlX3NxJywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDkwXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDkwXzI0aF94X3R0ZScsICdleHBfcmV0X3A5MF8yNGhfeF90dGVfc3EnLCAnZXhwX3JldF9wOTBfMjRoX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDEwXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDEwXzI0aF94X3R0ZScsICdleHBfcmV0X3AxMF8yNGhfeF90dGVfc3EnLCAnZXhwX3JldF9wMTBfMjRoX3hfdHRlX2N1JywgJ2V4cF9iYW5kX3dpZHRoXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9iYW5kX3dpZHRoXzI0aF94X3R0ZScsICdleHBfYmFuZF93aWR0aF8yNGhfeF90dGVfc3EnLCAnZXhwX2JhbmRfd2lkdGhfMjRoX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDkwX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDkwX3R0ZV94X3R0ZScsICdleHBfcmV0X3A5MF90dGVfeF90dGVfc3EnLCAnZXhwX3JldF9wOTBfdHRlX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDEwX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDEwX3R0ZV94X3R0ZScsICdleHBfcmV0X3AxMF90dGVfeF90dGVfc3EnLCAnZXhwX3JldF9wMTBfdHRlX3hfdHRlX2N1JywgJ2V4cF9iYW5kX3dpZHRoX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9iYW5kX3dpZHRoX3R0ZV94X3R0ZScsICdleHBfYmFuZF93aWR0aF90dGVfeF90dGVfc3EnLCAnZXhwX2JhbmRfd2lkdGhfdHRlX3hfdHRlX2N1JywgJ3Nob2NrX2Fic29ycHRpb24nLCAndm9sX2dreXpfM2hfeF90dGVfc3FydCcsICd2b2xfZ2t5el8zaF94X3R0ZScsICd2b2xfZ2t5el8zaF94X3R0ZV9zcScsICd2b2xfZ2t5el8zaF94X3R0ZV9zaW4nLCAndm9sX2dreXpfM2hfeF90dGVfY29zJywgJ3ZvbF9na3l6XzZoX3hfdHRlX3NxcnQnLCAndm9sX2dreXpfNmhfeF90dGUnLCAndm9sX2dreXpfNmhfeF90dGVfc3EnLCAndm9sX2dreXpfNmhfeF90dGVfc2luJywgJ3ZvbF9na3l6XzZoX3hfdHRlX2NvcycsICd2b2xfZ2t5el8xMmhfeF90dGVfc3FydCcsICd2b2xfZ2t5el8xMmhfeF90dGUnLCAndm9sX2dreXpfMTJoX3hfdHRlX3NxJywgJ3ZvbF9na3l6XzEyaF94X3R0ZV9zaW4nLCAndm9sX2dreXpfMTJoX3hfdHRlX2NvcycsICd2b2xfZ2t5el8yNGhfeF90dGVfc2luJywgJ3ZvbF9na3l6XzI0aF94X3R0ZV9jb3MnLCAndm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0JywgJ3ZvbF9na3l6XzI4OGhfeF90dGUnLCAndm9sX2dreXpfMjg4aF94X3R0ZV9zcScsICd2b2xfZ2t5el8yODhoX3hfdHRlX3NpbicsICd2b2xfZ2t5el8yODhoX3hfdHRlX2NvcycsICd2b2xfcmF3XzI0aF94X3R0ZV9zcXJ0JywgJ3ZvbF9yYXdfMjRoX3hfdHRlJywgJ3ZvbF9yYXdfMjRoX3hfdHRlX3NxJywgJ3ZvbF9yYXdfMjRoX3hfdHRlX3NpbicsICd2b2xfcmF3XzI0aF94X3R0ZV9jb3MnLCAndm9sX3Jhd18yODhoX3hfdHRlX3NxcnQnLCAndm9sX3Jhd18yODhoX3hfdHRlJywgJ3ZvbF9yYXdfMjg4aF94X3R0ZV9zcScsICd2b2xfcmF3XzI4OGhfeF90dGVfc2luJywgJ3ZvbF9yYXdfMjg4aF94X3R0ZV9jb3MnLCAndm9sX3Rlcm1feF90dGVfc3FydCcsICd2b2xfdGVybV94X3R0ZScsICd2b2xfdGVybV94X3R0ZV9zcScsICd2b2xfZ2t5el8zaF93ZWVrZW5kJywgJ3ZvbF9na3l6XzNoX3dlZWtkYXknLCAndm9sX2dreXpfNmhfd2Vla2VuZCcsICd2b2xfZ2t5el82aF93ZWVrZGF5JywgJ3ZvbF9na3l6XzEyaF93ZWVrZW5kJywgJ3ZvbF9na3l6XzEyaF93ZWVrZGF5JywgJ3ZvbF9na3l6XzI0aF93ZWVrZW5kJywgJ3ZvbF9na3l6XzI0aF93ZWVrZGF5JywgJ3ByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfd2Vla2VuZCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3dlZWtlbmQnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF93ZWVrZW5kJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ1ZsbV93ZWVrZW5kJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3dlZWtlbmQnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfd2Vla2VuZCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF93ZWVrZW5kJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1fd2Vla2VuZCcsICd2b2x1bWVfd2Vla2VuZF9lZmZlY3QnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQX3hfdm9sMTJoJywgJ3ByZXZfd2Vla2RheV9Qcm9nQWN0UF94X3ZvbDI0aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wxMmgnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX3hfdm9sMjRoJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF94X3ZvbDEyaCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGgnLCAncHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDEyaCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDEyaCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sMjRoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMTJoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2wyNGgnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfeF92b2wxMmgnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dWbG1feF92b2wxMmgnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtX3hfdm9sMjRoJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wxMmgnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGgnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDEyaCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3hfdm9sMTJoJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3hfdm9sMjRoJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMTJoJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGgnLCAncHJldl93ZWVrZGF5X3JhbmdlX3hfdm9sJywgJ3ByZXZfc2F0dXJkYXlfcmFuZ2VfeF92b2wnLCAncHJldl9zdW5kYXlfcmFuZ2VfeF92b2wnLCAnd2Vla2RheV92c19zYXR1cmRheV9wcm9nJywgJ3dlZWtkYXlfdnNfc3VuZGF5X3Byb2cnLCAncHJldl9jeWNsZV9wcm9ncmVzc194X2hvdXInLCAnZXh0cmVtZV9yYW5nZV92b2wnLCAnc2tld192b2xfZXh0cmVtZScsICdrdXJ0b3Npc192b2xfZXh0cmVtZScsICdkaXN0YW5jZV92b2xfZXh0cmVtZScsICd2b2xfc3VycHJpc2VfY2x1c3RlcmluZyddCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\n\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\n\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\n\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nhistory_slice = raw_history[-1000:]\\\\n\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n# existing_fe: Optional[FeatureEngineer] = None\\\\n# if \\\\\\\"feature_engineer\\\\\\\" in globals() and isinstance(feature_engineer, FeatureEngineer):\\\\n#     existing_fe = feature_engineer\\\\n\\\\n# if existing_fe is not None:\\\\n#     print(\\\\\\\"Reusing existing FeatureEngineer instance.\\\\\\\")\\\\n#     fe = existing_fe\\\\n# else:\\\\n#     print(\\\\\\\"Instantiating new FeatureEngineer instance.\\\\\\\")\\\\n#     fe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\nfe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n\\\\ncache_ready = False  # Force rebuild for testing\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"Loaded heavy cache payload from disk; skipping rebuild.\\\\\\\")\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\nelse:\\\\n    print(\\\\\\\"Heavy cache not available or failed to load; running full fit.\\\\\\\")\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=verbose_flag, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## Add tarrgets\\\\ntarget_engineer = ExpirationTargetEngineer(**CONFIG[\\\\\\\"targets\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\ntarget_engineer.fit(features)\\\\ntargets = target_engineer.transform(features)\\\\n\\\\n\\\\n\\\\n# --- 2b. Adding Derived Probability Features (from pre-trained models) ---\\\\nderived_proba_config = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"derived_probability_features\\\\\\\", {})\\\\nprint(f'derived_proba_config: {derived_proba_config}')\\\\nif derived_proba_config.get(\\\\\\\"enabled\\\\\\\", False):\\\\n    print(\\\\\\\"\\\\\\\\n2b. Adding Derived Probability Features\\\\\\\")\\\\n    features, newly_added_proba_features = generate_and_add_derived_probability_features(\\\\n        features.copy(),\\\\n        derived_proba_config,\\\\n        paths\\\\n    )\\\\n    if newly_added_proba_features:\\\\n        print(f\\\\\\\"  Successfully added derived probability features: {newly_added_proba_features}\\\\\\\")\\\\n        # Check for NaNs in each new feature\\\\n        for feat in newly_added_proba_features:\\\\n            if feat in features.columns:\\\\n                n_nans = features[feat].isna().sum()\\\\n                print(f\\\\\\\"    [NaN check] {feat}: {n_nans} NaNs ({n_nans/len(features):.2%} of rows)\\\\\\\")\\\\n            else:\\\\n                print(f\\\\\\\"    [NaN check] {feat}: not found in features DataFrame!\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"  No new derived probability features were added (or generation was disabled).\\\\\\\")\\\\n\\\\ninitial_feature_names = list(features.columns)\\\\n\\\\n# Generate targets (your existing logic)\\\\nprint(initial_feature_names)\\\\n\\\\n\\\\n## deop pice columns from features\\\\n# drop_cols = [col for col in ['o', 'h', 'l', 'c'] if col in features.columns]\\\\n# if drop_cols: features = features.drop(columns=drop_cols)\\\\n\\\\n\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":2,\\\"executionId\\\":\\\"06e5b921-6d6e-479c-9fc3-2361400257bc\\\",\\\"runStartTime\\\":1764168698156,\\\"runEndTime\\\":1764168703756,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"4dddeab0\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":9,\\\"id\\\":\\\"a4c09e20\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"from targetEngineer import VolatilityRegimeEngineer\\\\ndf_train = features.copy()\\\\n\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*7,    # 1 week for deseasonalized vol\\\\n    seasonal_window=24*30,    # 30 days to learn patterns\\\\n    forward_window=24,      # 12h forward classification\\\\n    trend_std=1.2,\\\\n    jump_std=4.6,\\\\n    jump_speed_window=6  # Jump must occur within 3 time units\\\\n\\\\n)\\\\n\\\\nregime_engineer.fit(df_train)\\\\ntargets = regime_engineer.transform(df_train)\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"11ca7280-6751-49f1-97d3-529f03c4ccbc\\\",\\\"runStartTime\\\":1764168900752,\\\"runEndTime\\\":1764168906514,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"2e4c675a\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"d494db24\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"48a5ba93-b1e7-4999-8639-29491d6a7600\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"cmVnaW1lX2xhYmVsCjAgICAgNjYyCjEgICAgMTQ5CjIgICAgMTA1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Check distribution\\\\ndistribution = regime_engineer.get_regime_distribution(df_train)\\\\nprint(distribution)\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":10,\\\"executionId\\\":\\\"b724e3cc-fad8-45a3-a46d-5ff440bab5d6\\\",\\\"runStartTime\\\":1764168906518,\\\"runEndTime\\\":1764168912311,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"a83da7b5\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"a9f4c760\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1537a6e6-b248-49d7-b8ea-46caa25e52ff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":10,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX2FubnVhbGl6ZWQ8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjA6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjE6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjI6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjM6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTYgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40MDE3Mzk8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDM3PC90ZD4KICAgICAgPHRkPjAuNjk2MDU5PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA4OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDE4ODA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMxPC90ZD4KICAgICAgPHRkPjAuNjk1NTE4PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wNzA3MzA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMwPC90ZD4KICAgICAgPHRkPjAuNjk1NDIwPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTkyNjU8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMwPC90ZD4KICAgICAgPHRkPjAuNjk1MzkyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDExOjAwOjAwPC90aD4KICAgICAgPHRkPiZsdDtOQSZndDs8L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD4wLjAwNzQyMTwvdGQ+CiAgICAgIDx0ZD4wLjY5NDU5MDwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjEwMDAgcm93cyDDlyA1IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgcmVnaW1lX2xhYmVsICBtYXhfZndkX3pfc2NvcmUgIG1heF9qdW1wX3pfc2NvcmUgIFwKMjAyNS0xMC0xNSAyMDowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMTowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMjowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMzowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNiAwMDowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAuLi4gICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC40MDE3MzkgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4yNDE4ODAgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4wNzA3MzAgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4wMTkyNjUgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKCiAgICAgICAgICAgICAgICAgICAgICBib3hfc3RkICBib3hfc3RkX2FubnVhbGl6ZWQgIAoyMDI1LTEwLTE1IDIwOjAwOjAwICAgICAgIE5hTiAgICAgICAgICAgICAgICAgTmFOICAKMjAyNS0xMC0xNSAyMTowMDowMCAgICAgICBOYU4gICAgICAgICAgICAgICAgIE5hTiAgCjIwMjUtMTAtMTUgMjI6MDA6MDAgICAgICAgTmFOICAgICAgICAgICAgICAgICBOYU4gIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAgICAgIE5hTiAgICAgICAgICAgICAgICAgTmFOICAKMjAyNS0xMC0xNiAwMDowMDowMCAgICAgICBOYU4gICAgICAgICAgICAgICAgIE5hTiAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgICAuLi4gIAoyMDI1LTExLTI2IDA3OjAwOjAwICAwLjAwNzQzNyAgICAgICAgICAgIDAuNjk2MDU5ICAKMjAyNS0xMS0yNiAwODowMDowMCAgMC4wMDc0MzEgICAgICAgICAgICAwLjY5NTUxOCAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDAuMDA3NDMwICAgICAgICAgICAgMC42OTU0MjAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAwLjAwNzQzMCAgICAgICAgICAgIDAuNjk1MzkyICAKMjAyNS0xMS0yNiAxMTowMDowMCAgMC4wMDc0MjEgICAgICAgICAgICAwLjY5NDU5MCAgCgpbMTAwMCByb3dzIHggNSBjb2x1bW5zXQ==\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"source\\\":\\\"targets\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"71afb8a5-ca2a-45e3-b46c-361707ac6238\\\",\\\"runStartTime\\\":1764166812504,\\\"runEndTime\\\":1764166812506,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"b63ab08c\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"526b7630\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"source\\\":\\\"\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"14c2ed1c-196c-4138-97a2-e1226911718c\\\",\\\"internalId\\\":\\\"ebc332a8\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":28,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb::request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","scheme":"file"},"requestId":"request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick smoke test that mirrors production: build features, derive targets, combine them, and prepare time-based splits.\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"65dc8abb\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":2,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"64fdc9cd-bf4b-440f-ab4a-2d62fd16c71f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L2hvbWUvZWFzdC9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvdHFkbS9hdXRvLnB5OjIxOiBUcWRtV2FybmluZzogSVByb2dyZXNzIG5vdCBmb3VuZC4gUGxlYXNlIHVwZGF0ZSBqdXB5dGVyIGFuZCBpcHl3aWRnZXRzLiBTZWUgaHR0cHM6Ly9pcHl3aWRnZXRzLnJlYWR0aGVkb2NzLmlvL2VuL3N0YWJsZS91c2VyX2luc3RhbGwuaHRtbAogIGZyb20gLmF1dG9ub3RlYm9vayBpbXBvcnQgdHFkbSBhcyBub3RlYm9va190cWRtCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"4a425eb6-ec89-4e0e-8221-0c2ead3f82c3\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkhlYXZ5IGNhY2hlIHJlYWR5OiBoZWF2eV9mZWF0dXJlc192MS5wa2wgKHRvdGFsIDEpIGluIGNhY2hlL2hlYXZ5X2ZlYXR1cmVzCkhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGUgb3IgZmFpbGVkIHRvIGxvYWQ7IHJ1bm5pbmcgZnVsbCBmaXQuCmRlcml2ZWRfcHJvYmFfY29uZmlnOiB7J2VuYWJsZWQnOiBGYWxzZSwgJ21vZGVsc19kaXJlY3RvcnknOiAncmVzZWFyY2hfdm9sL3RyYWluZWRfbW9kZWxzJywgJ2ZpbGVfcGF0dGVybic6ICdjYXRib29zdF8qX2hwdF9idW5kbGUucGtsJywgJ21vZGVsc190b191c2UnOiB7fX0KWydvJywgJ2gnLCAnbCcsICdjJywgJ3ZvbENjeScsICd0aW1lX3RvX2V4cDFfaHInLCAndGltZV9lbGFwc2VkJywgJ2hvdXInLCAnZGF5X29mX3dlZWsnLCAnaXNfd2Vla2VuZCcsICdob3VyX29mX3dlZWsnLCAnaG91cl9vZl93ZWVrX3NpbicsICdob3VyX29mX3dlZWtfY29zJywgJ2hvdXJzX3NpbmNlX3dlZWtfc3RhcnQnLCAnZGF5X3R5cGVfbnVtJywgJ3ByZXZfY2xvc2UnLCAndm9sQ2N5X3ByZXYnLCAnd2luZG93X3ByZXZfY2xvc2UnLCAncmV0dXJuc18xaCcsICdyZXR1cm5zXzJoJywgJ2xvZ3JldF8yaCcsICdyZXR1cm5zXzNoJywgJ2xvZ3JldF8zaCcsICdyZXR1cm5zXzRoJywgJ2xvZ3JldF80aCcsICdyZXR1cm5zXzVoJywgJ2xvZ3JldF81aCcsICdyZXR1cm5zXzZoJywgJ2xvZ3JldF82aCcsICdyZXR1cm5zXzEyaCcsICdsb2dyZXRfMTJoJywgJ3JldHVybnNfMjRoJywgJ2xvZ3JldF8yNGgnLCAncmV0dXJuc183MmgnLCAnbG9ncmV0XzcyaCcsICdyZXR1cm5zXzF3aycsICdyZXR1cm5zXzFNJywgJ3JldF9oX3BjJywgJ3JldF9sX3BjJywgJ3JldF9jX3BjJywgJ3JldF9oX2wnLCAncmFuZ2VfMmgnLCAncmFuZ2VfcGNfMmgnLCAncmFuZ2VfM2gnLCAncmFuZ2VfcGNfM2gnLCAncmFuZ2VfNmgnLCAncmFuZ2VfcGNfNmgnLCAncmFuZ2VfMTJoJywgJ3JhbmdlX3BjXzEyaCcsICdyYW5nZV8yNGgnLCAncmFuZ2VfcGNfMjRoJywgJ3JhbmdlJywgJ3JhbmdlX3BjJywgJ2Nsb3NlX3RvX2hpZ2gnLCAnY2xvc2VfdG9fbG93JywgJ2Nsb3NlX3Bvc19pbl9iYXInLCAnbG9ncmV0X2hfcGMnLCAnbG9ncmV0X2xfcGMnLCAnbG9ncmV0X2NfcGMnLCAnaXNfZHN0JywgJ3R0ZV9waGFzZV9jb3MnLCAndHRlX3BoYXNlX3NpbicsICdtb21lbnR1bV8zaCcsICdtb21lbnR1bV9zaWduZWRfc3FydF8zaCcsICd0cmVuZF9zdHJlbmd0aF8zaCcsICdtb21lbnR1bV82aCcsICdtb21lbnR1bV9zaWduZWRfc3FydF82aCcsICd0cmVuZF9zdHJlbmd0aF82aCcsICdtb21lbnR1bV8xMmgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfMTJoJywgJ3RyZW5kX3N0cmVuZ3RoXzEyaCcsICdtb21lbnR1bV8yNGgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfMjRoJywgJ3RyZW5kX3N0cmVuZ3RoXzI0aCcsICdtb21lbnR1bV83MmgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfNzJoJywgJ3RyZW5kX3N0cmVuZ3RoXzcyaCcsICdtb21lbnR1bV8xNDRoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzE0NGgnLCAndHJlbmRfc3RyZW5ndGhfMTQ0aCcsICdtb21lbnR1bV8yODhoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzI4OGgnLCAndHJlbmRfc3RyZW5ndGhfMjg4aCcsICdtYWNkJywgJ21hY2Rfc2lnbmFsJywgJ21hY2RfaGlzdCcsICdhZHgnLCAnYWR4X3BvcycsICdhZHhfbmVnJywgJ3N0b2NoX3Bvc18zaCcsICdkaXN0X2Zyb21faGlnaF8zaCcsICdkaXN0X2Zyb21fbG93XzNoJywgJ3ByaWNlX3JhbmtfM2gnLCAnc3RvY2hfcG9zXzZoJywgJ2Rpc3RfZnJvbV9oaWdoXzZoJywgJ2Rpc3RfZnJvbV9sb3dfNmgnLCAncHJpY2VfcmFua182aCcsICdzdG9jaF9wb3NfMTJoJywgJ2Rpc3RfZnJvbV9oaWdoXzEyaCcsICdkaXN0X2Zyb21fbG93XzEyaCcsICdwcmljZV9yYW5rXzEyaCcsICdzdG9jaF9wb3NfMjRoJywgJ2Rpc3RfZnJvbV9oaWdoXzI0aCcsICdkaXN0X2Zyb21fbG93XzI0aCcsICdwcmljZV9yYW5rXzI0aCcsICdzdG9jaF9wb3NfNzJoJywgJ2Rpc3RfZnJvbV9oaWdoXzcyaCcsICdkaXN0X2Zyb21fbG93XzcyaCcsICdwcmljZV9yYW5rXzcyaCcsICdzdG9jaF9wb3NfMTQ0aCcsICdkaXN0X2Zyb21faGlnaF8xNDRoJywgJ2Rpc3RfZnJvbV9sb3dfMTQ0aCcsICdwcmljZV9yYW5rXzE0NGgnLCAnc3RvY2hfcG9zXzI4OGgnLCAnZGlzdF9mcm9tX2hpZ2hfMjg4aCcsICdkaXN0X2Zyb21fbG93XzI4OGgnLCAncHJpY2VfcmFua18yODhoJywgJ25ld18yNGhfaGlnaCcsICduZXdfMjRoX2xvdycsICd2bG1fbWFfM2gnLCAndmxtX3pzY29yZV8zaCcsICd2bG1fbWFfNmgnLCAndmxtX3pzY29yZV82aCcsICd2bG1fbWFfMTJoJywgJ3ZsbV96c2NvcmVfMTJoJywgJ3ZsbV9tYV8yNGgnLCAndmxtX3pzY29yZV8yNGgnLCAndmxtX21hXzcyaCcsICd2bG1fenNjb3JlXzcyaCcsICd2bG1fbWFfMTQ0aCcsICd2bG1fenNjb3JlXzE0NGgnLCAndmxtX21hXzI4OGgnLCAndmxtX3pzY29yZV8yODhoJywgJ3ZvbF9yYXdfM2gnLCAndm9sX2dreXpfM2gnLCAndm9sX3BhcmtpbnNvbl8zaCcsICd2b2xfenNjb3JlXzNoJywgJ2xvZ192b2xfM2gnLCAndm9sX3Jhd182aCcsICd2b2xfZ2t5el82aCcsICd2b2xfcGFya2luc29uXzZoJywgJ3ZvbF96c2NvcmVfNmgnLCAnbG9nX3ZvbF82aCcsICd2b2xfcmF3XzEyaCcsICd2b2xfZ2t5el8xMmgnLCAndm9sX3BhcmtpbnNvbl8xMmgnLCAndm9sX3pzY29yZV8xMmgnLCAnbG9nX3ZvbF8xMmgnLCAndm9sX3Jhd18yNGgnLCAndm9sX2dreXpfMjRoJywgJ3ZvbF9wYXJraW5zb25fMjRoJywgJ3ZvbF96c2NvcmVfMjRoJywgJ2xvZ192b2xfMjRoJywgJ3ZvbF9yYXdfNzJoJywgJ3ZvbF9na3l6XzcyaCcsICd2b2xfcGFya2luc29uXzcyaCcsICd2b2xfenNjb3JlXzcyaCcsICdsb2dfdm9sXzcyaCcsICd2b2xfcmF3XzE0NGgnLCAndm9sX2dreXpfMTQ0aCcsICd2b2xfcGFya2luc29uXzE0NGgnLCAndm9sX3pzY29yZV8xNDRoJywgJ2xvZ192b2xfMTQ0aCcsICd2b2xfcmF3XzI4OGgnLCAndm9sX2dreXpfMjg4aCcsICd2b2xfcGFya2luc29uXzI4OGgnLCAndm9sX3pzY29yZV8yODhoJywgJ2xvZ192b2xfMjg4aCcsICdyZXR1cm5zX3NrZXdfMjRoJywgJ3JldHVybnNfa3VydG9zaXNfMjRoJywgJ3ZvbF9yYXRpb18yNGhfMTQ0aCcsICd2b2xfcmF0aW9fMjRoXzI4OGgnLCAnZXhwX3JldF9wOTBfMjRoJywgJ2V4cF9yZXRfcDc1XzI0aCcsICdleHBfcmV0X3AyNV8yNGgnLCAnZXhwX3JldF9wMTBfMjRoJywgJ2V4cF9iYW5kX3dpZHRoXzI0aCcsICdleHBfbG9nbW92ZV9wOTBfMjRoJywgJ2V4cF9sb2dtb3ZlX3AxMF8yNGgnLCAnZXhwX3JldF9wOTBfdHRlJywgJ2V4cF9yZXRfcDEwX3R0ZScsICdleHBfYmFuZF93aWR0aF90dGUnLCAnZXhwX2xvZ21vdmVfcDkwX3R0ZScsICdleHBfbG9nbW92ZV9wMTBfdHRlJywgJ3JlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCcsICdyZWFsaXplZF90b19leHBlY3RlZF90dGUnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFAnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5UJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4VCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbScsICdwcmV2X3dlZWtkYXlfUmVtQWN0UCcsICdwcmV2X3dlZWtkYXlfUmVtTWluUCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4UCcsICdwcmV2X3dlZWtkYXlfUmVtTWluVCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4VCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNaW5UJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFQnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtJywgJ3ByZXZfc2F0dXJkYXlfUmVtQWN0UCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblAnLCAncHJldl9zYXR1cmRheV9SZW1NYXhQJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWluVCcsICdwcmV2X3NhdHVyZGF5X1JlbU1heFQnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFAnLCAncHJldl9zdW5kYXlfUHJvZ01pblAnLCAncHJldl9zdW5kYXlfUHJvZ01heFAnLCAncHJldl9zdW5kYXlfUHJvZ01pblQnLCAncHJldl9zdW5kYXlfUHJvZ01heFQnLCAncHJldl9zdW5kYXlfUHJvZ1ZsbScsICdwcmV2X3N1bmRheV9SZW1BY3RQJywgJ3ByZXZfc3VuZGF5X1JlbU1pblAnLCAncHJldl9zdW5kYXlfUmVtTWF4UCcsICdwcmV2X3N1bmRheV9SZW1NaW5UJywgJ3ByZXZfc3VuZGF5X1JlbU1heFQnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5QX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfcDEwXzkwJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfcDEwXzkwJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1pblBfbWVkXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NaW5QX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1heFBfbWVkXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NYXhQX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4UF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9wMTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9wMTBfOTAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NaW5QX21lZF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NYXhQX21lZF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1heFBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWF4UF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01pblBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3AxMF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQX3AxMF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9tZWRfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWluUF9wOTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9tZWRfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUmVtTWF4UF9wOTBfOTAnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDAxJywgJ2VtcF9mcmVxX2xvZ3JldF9sX3BjX2xlXy0wLjAwMDEnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDA1JywgJ2VtcF9mcmVxX2xvZ3JldF9sX3BjX2xlXy0wLjAwMDUnLCAnZW1wX2ZyZXFfbG9ncmV0X2hfcGNfZ2VfMC4wMDEnLCAnZW1wX2ZyZXFfbG9ncmV0X2xfcGNfbGVfLTAuMDAxJywgJ2VtcF9wY3RfNV9sb2dyZXRfaF9wYycsICdlbXBfcGN0XzVfbG9ncmV0X2xfcGMnLCAnZW1wX3BjdF8zMF9sb2dyZXRfaF9wYycsICdlbXBfcGN0XzMwX2xvZ3JldF9sX3BjJywgJ2VtcF9wY3RfNTBfbG9ncmV0X2hfcGMnLCAnZW1wX3BjdF81MF9sb2dyZXRfbF9wYycsICdlbXBfcGN0XzcwX2xvZ3JldF9oX3BjJywgJ2VtcF9wY3RfNzBfbG9ncmV0X2xfcGMnLCAnZW1wX3BjdF85NV9sb2dyZXRfaF9wYycsICdlbXBfcGN0Xzk1X2xvZ3JldF9sX3BjJywgJ2VtcF9tZWRpYW5fbG9ncmV0X3JhbmdlJywgJ2VtcF9tZWRpYW5fcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfMjRoJywgJ2VtcF9tZWRpYW5fcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlJywgJ2NDUHJvZ0FjdFAnLCAnY0NQcm9nTWluUCcsICdjQ1Byb2dNYXhQJywgJ2NDUHJvZ01pblQnLCAnY0NQcm9nTWF4VCcsICdjQ1Byb2dWbG0nLCAndm9sX3dlaWdodGVkX3ZvbCcsICd2b2xfdmxtX3JhdGlvX2NoYW5nZScsICdhc3ltX3ZvbF92bG1faW1wYWN0JywgJ21vbWVudHVtX2FjY2VsXzZoJywgJ21vbWVudHVtX2FjY2VsXzEyaCcsICdtb21lbnR1bV9hY2NlbF8yNGgnLCAnc2lnbmVkX21vbWVudHVtX3Bvd2VyJywgJ21vbV92b2xfaW50ZXJhY3Rpb24nLCAnY29tcHJlc3NlZF9yYW5nZV92b2wnLCAncmFuZ2VfZXhwYW5zaW9uJywgJ25sX3Bvc19pbl9yYW5nZScsICd2b2x1bWVfc3VycHJpc2UnLCAnbGlxX3ZvbCcsICdsaXFfdm9sX3JhdGlvX2NoYW5nZScsICd2b2x1bWVfdHJlbmRfeicsICdleHBfZGVjYXlfcmV0XzZoJywgJ2V4cF9kZWNheV9yZXRfMTJoJywgJ2V4cF9kZWNheV9yZXRfMjRoJywgJ3RpbWVfYWRqX3ZvbCcsICdjeWNsaWNhbF92b2xfY29tcHJlc3Npb24nLCAnZXh0cmVtZV9wcm9iJywgJ3ZvbF9jbHVzdGVyaW5nJywgJ3ZvbF9na3l6XzI0aF94X3R0ZV9zcXJ0JywgJ3ZvbF9na3l6XzI0aF94X3R0ZScsICd2b2xfZ2t5el8yNGhfeF90dGVfc3EnLCAndm9sX2dreXpfMjRoX3hfdHRlX2N1JywgJ3ZsbV9tYV8yNGhfeF90dGVfc3FydCcsICd2bG1fbWFfMjRoX3hfdHRlJywgJ3ZsbV9tYV8yNGhfeF90dGVfc3EnLCAndmxtX21hXzI0aF94X3R0ZV9jdScsICdyZXR1cm5zX2t1cnRvc2lzXzI0aF94X3R0ZV9zcXJ0JywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlJywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlX3NxJywgJ3JldHVybnNfa3VydG9zaXNfMjRoX3hfdHRlX2N1JywgJ3JldHVybnNfc2tld18yNGhfeF90dGVfc3FydCcsICdyZXR1cm5zX3NrZXdfMjRoX3hfdHRlJywgJ3JldHVybnNfc2tld18yNGhfeF90dGVfc3EnLCAncmV0dXJuc19za2V3XzI0aF94X3R0ZV9jdScsICdleHRyZW1lX3Byb2JfeF90dGVfc3FydCcsICdleHRyZW1lX3Byb2JfeF90dGUnLCAnZXh0cmVtZV9wcm9iX3hfdHRlX3NxJywgJ2V4dHJlbWVfcHJvYl94X3R0ZV9jdScsICd2b2xfY2x1c3RlcmluZ194X3R0ZV9zcXJ0JywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlJywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlX3NxJywgJ3ZvbF9jbHVzdGVyaW5nX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDkwXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDkwXzI0aF94X3R0ZScsICdleHBfcmV0X3A5MF8yNGhfeF90dGVfc3EnLCAnZXhwX3JldF9wOTBfMjRoX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDEwXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDEwXzI0aF94X3R0ZScsICdleHBfcmV0X3AxMF8yNGhfeF90dGVfc3EnLCAnZXhwX3JldF9wMTBfMjRoX3hfdHRlX2N1JywgJ2V4cF9iYW5kX3dpZHRoXzI0aF94X3R0ZV9zcXJ0JywgJ2V4cF9iYW5kX3dpZHRoXzI0aF94X3R0ZScsICdleHBfYmFuZF93aWR0aF8yNGhfeF90dGVfc3EnLCAnZXhwX2JhbmRfd2lkdGhfMjRoX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDkwX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDkwX3R0ZV94X3R0ZScsICdleHBfcmV0X3A5MF90dGVfeF90dGVfc3EnLCAnZXhwX3JldF9wOTBfdHRlX3hfdHRlX2N1JywgJ2V4cF9yZXRfcDEwX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9yZXRfcDEwX3R0ZV94X3R0ZScsICdleHBfcmV0X3AxMF90dGVfeF90dGVfc3EnLCAnZXhwX3JldF9wMTBfdHRlX3hfdHRlX2N1JywgJ2V4cF9iYW5kX3dpZHRoX3R0ZV94X3R0ZV9zcXJ0JywgJ2V4cF9iYW5kX3dpZHRoX3R0ZV94X3R0ZScsICdleHBfYmFuZF93aWR0aF90dGVfeF90dGVfc3EnLCAnZXhwX2JhbmRfd2lkdGhfdHRlX3hfdHRlX2N1JywgJ3Nob2NrX2Fic29ycHRpb24nLCAndm9sX2dreXpfM2hfeF90dGVfc3FydCcsICd2b2xfZ2t5el8zaF94X3R0ZScsICd2b2xfZ2t5el8zaF94X3R0ZV9zcScsICd2b2xfZ2t5el8zaF94X3R0ZV9zaW4nLCAndm9sX2dreXpfM2hfeF90dGVfY29zJywgJ3ZvbF9na3l6XzZoX3hfdHRlX3NxcnQnLCAndm9sX2dreXpfNmhfeF90dGUnLCAndm9sX2dreXpfNmhfeF90dGVfc3EnLCAndm9sX2dreXpfNmhfeF90dGVfc2luJywgJ3ZvbF9na3l6XzZoX3hfdHRlX2NvcycsICd2b2xfZ2t5el8xMmhfeF90dGVfc3FydCcsICd2b2xfZ2t5el8xMmhfeF90dGUnLCAndm9sX2dreXpfMTJoX3hfdHRlX3NxJywgJ3ZvbF9na3l6XzEyaF94X3R0ZV9zaW4nLCAndm9sX2dreXpfMTJoX3hfdHRlX2NvcycsICd2b2xfZ2t5el8yNGhfeF90dGVfc2luJywgJ3ZvbF9na3l6XzI0aF94X3R0ZV9jb3MnLCAndm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0JywgJ3ZvbF9na3l6XzI4OGhfeF90dGUnLCAndm9sX2dreXpfMjg4aF94X3R0ZV9zcScsICd2b2xfZ2t5el8yODhoX3hfdHRlX3NpbicsICd2b2xfZ2t5el8yODhoX3hfdHRlX2NvcycsICd2b2xfcmF3XzI0aF94X3R0ZV9zcXJ0JywgJ3ZvbF9yYXdfMjRoX3hfdHRlJywgJ3ZvbF9yYXdfMjRoX3hfdHRlX3NxJywgJ3ZvbF9yYXdfMjRoX3hfdHRlX3NpbicsICd2b2xfcmF3XzI0aF94X3R0ZV9jb3MnLCAndm9sX3Jhd18yODhoX3hfdHRlX3NxcnQnLCAndm9sX3Jhd18yODhoX3hfdHRlJywgJ3ZvbF9yYXdfMjg4aF94X3R0ZV9zcScsICd2b2xfcmF3XzI4OGhfeF90dGVfc2luJywgJ3ZvbF9yYXdfMjg4aF94X3R0ZV9jb3MnLCAndm9sX3Rlcm1feF90dGVfc3FydCcsICd2b2xfdGVybV94X3R0ZScsICd2b2xfdGVybV94X3R0ZV9zcScsICd2b2xfZ2t5el8zaF93ZWVrZW5kJywgJ3ZvbF9na3l6XzNoX3dlZWtkYXknLCAndm9sX2dreXpfNmhfd2Vla2VuZCcsICd2b2xfZ2t5el82aF93ZWVrZGF5JywgJ3ZvbF9na3l6XzEyaF93ZWVrZW5kJywgJ3ZvbF9na3l6XzEyaF93ZWVrZGF5JywgJ3ZvbF9na3l6XzI0aF93ZWVrZW5kJywgJ3ZvbF9na3l6XzI0aF93ZWVrZGF5JywgJ3ByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfd2Vla2VuZCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3dlZWtlbmQnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF93ZWVrZW5kJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ1ZsbV93ZWVrZW5kJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3dlZWtlbmQnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfd2Vla2VuZCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF93ZWVrZW5kJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1fd2Vla2VuZCcsICd2b2x1bWVfd2Vla2VuZF9lZmZlY3QnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl93ZWVrZGF5X1Byb2dBY3RQX3hfdm9sMTJoJywgJ3ByZXZfd2Vla2RheV9Qcm9nQWN0UF94X3ZvbDI0aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wxMmgnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX3hfdm9sMjRoJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF94X3ZvbDEyaCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGgnLCAncHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDEyaCcsICdwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDEyaCcsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sMjRoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMTJoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2wyNGgnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfeF92b2wxMmgnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dWbG1feF92b2wxMmgnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtX3hfdm9sMjRoJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sNmgnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wxMmgnLCAncHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGgnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2w2aCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDEyaCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF94X3ZvbDZoJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3hfdm9sMTJoJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX3hfdm9sMjRoJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1feF92b2w2aCcsICdwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMTJoJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGgnLCAncHJldl93ZWVrZGF5X3JhbmdlX3hfdm9sJywgJ3ByZXZfc2F0dXJkYXlfcmFuZ2VfeF92b2wnLCAncHJldl9zdW5kYXlfcmFuZ2VfeF92b2wnLCAnd2Vla2RheV92c19zYXR1cmRheV9wcm9nJywgJ3dlZWtkYXlfdnNfc3VuZGF5X3Byb2cnLCAncHJldl9jeWNsZV9wcm9ncmVzc194X2hvdXInLCAnZXh0cmVtZV9yYW5nZV92b2wnLCAnc2tld192b2xfZXh0cmVtZScsICdrdXJ0b3Npc192b2xfZXh0cmVtZScsICdkaXN0YW5jZV92b2xfZXh0cmVtZScsICd2b2xfc3VycHJpc2VfY2x1c3RlcmluZyddCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\n\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\n\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\n\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nhistory_slice = raw_history[-1000:]\\\\n\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n# existing_fe: Optional[FeatureEngineer] = None\\\\n# if \\\\\\\"feature_engineer\\\\\\\" in globals() and isinstance(feature_engineer, FeatureEngineer):\\\\n#     existing_fe = feature_engineer\\\\n\\\\n# if existing_fe is not None:\\\\n#     print(\\\\\\\"Reusing existing FeatureEngineer instance.\\\\\\\")\\\\n#     fe = existing_fe\\\\n# else:\\\\n#     print(\\\\\\\"Instantiating new FeatureEngineer instance.\\\\\\\")\\\\n#     fe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\nfe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n\\\\ncache_ready = False  # Force rebuild for testing\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"Loaded heavy cache payload from disk; skipping rebuild.\\\\\\\")\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\nelse:\\\\n    print(\\\\\\\"Heavy cache not available or failed to load; running full fit.\\\\\\\")\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=verbose_flag, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## Add tarrgets\\\\ntarget_engineer = ExpirationTargetEngineer(**CONFIG[\\\\\\\"targets\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\ntarget_engineer.fit(features)\\\\ntargets = target_engineer.transform(features)\\\\n\\\\n\\\\n\\\\n# --- 2b. Adding Derived Probability Features (from pre-trained models) ---\\\\nderived_proba_config = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"derived_probability_features\\\\\\\", {})\\\\nprint(f'derived_proba_config: {derived_proba_config}')\\\\nif derived_proba_config.get(\\\\\\\"enabled\\\\\\\", False):\\\\n    print(\\\\\\\"\\\\\\\\n2b. Adding Derived Probability Features\\\\\\\")\\\\n    features, newly_added_proba_features = generate_and_add_derived_probability_features(\\\\n        features.copy(),\\\\n        derived_proba_config,\\\\n        paths\\\\n    )\\\\n    if newly_added_proba_features:\\\\n        print(f\\\\\\\"  Successfully added derived probability features: {newly_added_proba_features}\\\\\\\")\\\\n        # Check for NaNs in each new feature\\\\n        for feat in newly_added_proba_features:\\\\n            if feat in features.columns:\\\\n                n_nans = features[feat].isna().sum()\\\\n                print(f\\\\\\\"    [NaN check] {feat}: {n_nans} NaNs ({n_nans/len(features):.2%} of rows)\\\\\\\")\\\\n            else:\\\\n                print(f\\\\\\\"    [NaN check] {feat}: not found in features DataFrame!\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"  No new derived probability features were added (or generation was disabled).\\\\\\\")\\\\n\\\\ninitial_feature_names = list(features.columns)\\\\n\\\\n# Generate targets (your existing logic)\\\\nprint(initial_feature_names)\\\\n\\\\n\\\\n## deop pice columns from features\\\\n# drop_cols = [col for col in ['o', 'h', 'l', 'c'] if col in features.columns]\\\\n# if drop_cols: features = features.drop(columns=drop_cols)\\\\n\\\\n\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":2,\\\"executionId\\\":\\\"06e5b921-6d6e-479c-9fc3-2361400257bc\\\",\\\"runStartTime\\\":1764168698156,\\\"runEndTime\\\":1764168703756,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"4dddeab0\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":9,\\\"id\\\":\\\"a4c09e20\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"from targetEngineer import VolatilityRegimeEngineer\\\\ndf_train = features.copy()\\\\n\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*7,    # 1 week for deseasonalized vol\\\\n    seasonal_window=24*30,    # 30 days to learn patterns\\\\n    forward_window=24,      # 12h forward classification\\\\n    trend_std=1.2,\\\\n    jump_std=4.6,\\\\n    jump_speed_window=6  # Jump must occur within 3 time units\\\\n\\\\n)\\\\n\\\\nregime_engineer.fit(df_train)\\\\ntargets = regime_engineer.transform(df_train)\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"11ca7280-6751-49f1-97d3-529f03c4ccbc\\\",\\\"runStartTime\\\":1764168900752,\\\"runEndTime\\\":1764168906514,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"2e4c675a\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"d494db24\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"48a5ba93-b1e7-4999-8639-29491d6a7600\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"cmVnaW1lX2xhYmVsCjAgICAgNjYyCjEgICAgMTQ5CjIgICAgMTA1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Check distribution\\\\ndistribution = regime_engineer.get_regime_distribution(df_train)\\\\nprint(distribution)\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":10,\\\"executionId\\\":\\\"b724e3cc-fad8-45a3-a46d-5ff440bab5d6\\\",\\\"runStartTime\\\":1764168906518,\\\"runEndTime\\\":1764168912311,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"a83da7b5\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"a9f4c760\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1537a6e6-b248-49d7-b8ea-46caa25e52ff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":10,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX2FubnVhbGl6ZWQ8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjA6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjE6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjI6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjM6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTYgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+Jmx0O05BJmd0OzwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40MDE3Mzk8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDM3PC90ZD4KICAgICAgPHRkPjAuNjk2MDU5PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA4OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDE4ODA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMxPC90ZD4KICAgICAgPHRkPjAuNjk1NTE4PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wNzA3MzA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMwPC90ZD4KICAgICAgPHRkPjAuNjk1NDIwPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTkyNjU8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjAuMDA3NDMwPC90ZD4KICAgICAgPHRkPjAuNjk1MzkyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDExOjAwOjAwPC90aD4KICAgICAgPHRkPiZsdDtOQSZndDs8L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD4wLjAwNzQyMTwvdGQ+CiAgICAgIDx0ZD4wLjY5NDU5MDwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjEwMDAgcm93cyDDlyA1IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgcmVnaW1lX2xhYmVsICBtYXhfZndkX3pfc2NvcmUgIG1heF9qdW1wX3pfc2NvcmUgIFwKMjAyNS0xMC0xNSAyMDowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMTowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMjowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMzowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNiAwMDowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAuLi4gICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC40MDE3MzkgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4yNDE4ODAgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4wNzA3MzAgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAwICAgICAgICAgMC4wMTkyNjUgICAgICAgICAgICAgICAwLjAgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICA8TkE+ICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICBOYU4gICAKCiAgICAgICAgICAgICAgICAgICAgICBib3hfc3RkICBib3hfc3RkX2FubnVhbGl6ZWQgIAoyMDI1LTEwLTE1IDIwOjAwOjAwICAgICAgIE5hTiAgICAgICAgICAgICAgICAgTmFOICAKMjAyNS0xMC0xNSAyMTowMDowMCAgICAgICBOYU4gICAgICAgICAgICAgICAgIE5hTiAgCjIwMjUtMTAtMTUgMjI6MDA6MDAgICAgICAgTmFOICAgICAgICAgICAgICAgICBOYU4gIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAgICAgIE5hTiAgICAgICAgICAgICAgICAgTmFOICAKMjAyNS0xMC0xNiAwMDowMDowMCAgICAgICBOYU4gICAgICAgICAgICAgICAgIE5hTiAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgICAuLi4gIAoyMDI1LTExLTI2IDA3OjAwOjAwICAwLjAwNzQzNyAgICAgICAgICAgIDAuNjk2MDU5ICAKMjAyNS0xMS0yNiAwODowMDowMCAgMC4wMDc0MzEgICAgICAgICAgICAwLjY5NTUxOCAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDAuMDA3NDMwICAgICAgICAgICAgMC42OTU0MjAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAwLjAwNzQzMCAgICAgICAgICAgIDAuNjk1MzkyICAKMjAyNS0xMS0yNiAxMTowMDowMCAgMC4wMDc0MjEgICAgICAgICAgICAwLjY5NDU5MCAgCgpbMTAwMCByb3dzIHggNSBjb2x1bW5zXQ==\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"source\\\":\\\"targets\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"71afb8a5-ca2a-45e3-b46c-361707ac6238\\\",\\\"runStartTime\\\":1764166812504,\\\"runEndTime\\\":1764166812506,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"b63ab08c\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":12,\\\"id\\\":\\\"526b7630\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ce8e1855-1bae-4baa-b63a-293bcd5da09f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"display_data\\\",\\\"transient\\\":{},\\\"metadata\\\":{},\\\"__displayOpenPlotIcon\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"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05P//vuP4sWL2x1LuiVIegQEBGCxWLh58ybBwcF2x65du5bm9AwGAx07duSrr77i119/pW/fvsycORNN0+jSpYstnrWNkssjLCzMLl5yRo8eTVxcHP/884/DXdM7d+603VGdlfTq1YvZs2czbdo0vv32W37++Wf8/f1p06ZNutP08vKiTp06LF++nPLly9O1a1dOnTplWyi2tmNERAR+fn6ppufv75+h/eJhWctfuXJl/v33X5fO8fb2ZtSoUYwaNYpz586xceNGpk6dyrfffktMTAw//vjjoyyyEEIIIcRjI3uiCyGEEEKILKNq1arExcWxefPmFOOVLl0af39//v3334fej/vMmTOULl3aYQE9NDSUs2fPPlTaABUqVADgn3/+cTjmLMwV1n3PZ8yYwa5duzh69Ch169a12/fauoXHli1bUErZna+UYsuWLXbxknPmzBmyZ8/usIB+79499u7d6xDfuv994rvxM5Ir6VevXp3y5cvzyy+/sGbNGk6dOsVbb72VIXdGlypVij59+nD16lUmTpxoC69WrRrwYFuX1Fj7xbZt2xyObd++/aHLmVZ+fn6ULl2aY8eO2W1H5KrChQvTtWtXNm/ejK+vL0uWLMn4QgohhBBCZBJZRBdCCCGEEFlGnz59gISHdlq3x7AymUy2O3QNBgO9e/fmwoULfPDBB04X0g8fPsz169dTzbNgwYKcPn3a7u7f2NhYevfunSEPzOzQoQMAI0eOtNsK48qVK3z77bfpSrNUqVLUrFmTffv28f777wPY9v+2KlCgAHXr1uXIkSO2h45a/fTTTxw7dox69eqluh96wYIFuXPnjt22OWazmQ8++MC293xi1oe0pvbA0vRyNf2ePXty+/Zt29356dnKJTmDBw/Gy8uL8ePH27bDeeeddzAYDPTr14+LFy86nBMeHs6+fftsr9966y0goV/ExMTYwsPCwtLdLx7Wu+++y7179+jRo4fTrZDOnTvH+fPngYTnDhw+fNghzp07d4iLi8PT0/NRF1cIIYQQ4rGR7VyEEEIIIUSW0ahRIz744APGjx9P8eLFadGiBTlz5uTKlSusX7+eDz74gP79+wMwYsQI9u7dy3fffcfy5cupVauWLe6hQ4c4cOAAO3bsIGfOnCnm2a9fP/r160elSpVo3bo1JpOJtWvXopSiQoUKD71dSd26denSpQsz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8L5evXqpatWqAX+8Ro4cqddee833etOmTVq3bp1GjhwpSZo9e7a6dOmihx56SG3atFGXLl30wgsvaNmyZdq0Ke8fajt27KgpU6aoZcuWGjVqlLp37+67btWunfuZmpycrJSUFN/r0sAz0QEAAAAAKCfufvDusOvz/+/1BWnboa3v73VTcv8X/P1796tho4b6/bff9a+r/hXQvkfPHnpu9nMBy7qf0j3gdc+eJ+vr79f5Xi9a9IHOPOtM2Ww2eTzugLZjxlyhF198WY0apSoz84iGnHGG/nvskSReP/74k1atWq0HH3g4d4FhyO12KysrS0eOHtUJCQn6bOVKzZg9Wxv/+ENp6ely5VsvSSckJKi53//KX69eivbu3auCzJ8zR61btNCGjRt1+8MPatb/zfI9j3zD+g1atXyVmiUHF0u3/rlVzVs11wXDL9Bt192mh2c/rLi4OL392tsadskw3/OtN6zfoG+++ibgznOP25Mb/5EjOuHYM5I7dQv8IdYrrr1CV11ylX76/iedduZpGnLuEJ1zauDd/l6///a7evbsKcMwfMt69OqhzIxM7dy+U/Wa1ZMUmA9S7j/aRDJGCDZhwjhNmDCuyO+PjY3ViR1P9L3+9edf5Xa71evEXgHtcrJzVK9W3uMzEk5IUJPmTXyv69arq/17cx9/kXY4TXt27VHXHl196x0Ohzp161TgtaNjxw6+vxuGoZSUvNzYuHGTOnZsr/j4vCeRdzmpSyH29vh1w113acPGjVr+7rsByx+8885S26b/eV6rTi0lnJCgxs0a+5bVrVtHX61dG/Cebj26BVw/evbsqccee0xut1t2u12ff/656tSpE/T88wULFqht28Dritdll12m2267TWvWrNEpp5yiefPmqWvXrmpz7B8TfvzxRy1btiyg8O71xx9/qFWr3P/To2PHjgHr6tWrF5XrFkV0AAAAAABKWY1aNWS327Vv776A5fv27CvUD0S2atVSkrT5t83q3rN7Aa0V8OOU3gJJ/ud3F9d7732gOx4MXRAaOfIy3X77XZo69QFdfvkIORzBZYiMjAzdd99kndv7NEmSo27ujx669hxUfFyctm7bpmFXXqlrL79c0/79b9VITtaqb77RNbfeqpycHF8RPf8PcRqGEdE/OjSsX18tmzVTy2bNdLCKR2MuHqPlPyxXXFycMjMyNfCcgbrn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Cy+8oG3btsnj8YRs53a7yzgyAAAAAAAAAEA0UET3c+211+qll17SKaecovPOO09JSUnRDgkAAAAAAAAAEEUU0f28+eabuvzyyzV37txohwIAAAAAAAAAKAds0Q6gPDnhhBN0yimnRDsMAAAAAAAAAEA5QRHdz/Dhw/XBBx9EOwwAAAAAAAAAQDnB41z8PPLIIxozZozOOeccjRkzRqmpqbLb7UHtunbtGoXoAAAAAAAAAABljSK6n+zsbHk8Hn388cf6+OOPg9abpinDMOR2u6MQHQAAAAAAAACgrFFE9zNmzBi9++67uuyyy3TyyScrKSkp2iEBAAAAAAAAAKKIIrqfJUuW6IYbbtDjjz8e7VAAAAAAAAAAAOUAPyzqJzExUS1atIh2GAAAAAAAAACAcoIiup+rr75ar732Gs88BwAAAAAAAABI4nEuAU488UQtWrRIXbt21RVXXKHU1FTZ7fagdhdccEEUogMAAAAAAAAAlDWK6H4uvfRS399vu+22kG0Mw+BOdQAAAAAAAAA4TlBE97Ns2bJohwAAAAAAAAAAKEcoovs57bTToh0CAAAAAAAAAKAcoYhehrKzs5Wdne17nZaWFsVoAAAAAAAAAAAFOa6L6P369ZPNZtOSJUvkcDh0xhlnFPgewzD02WefFWl706dP13333Vek9wIAAAAAAAAAyp4t2gFEk2ma8ng8vtcej0emaYb949++sO68804dPnzY92fbtm0lsRsAAAAAAAAAgFJyXN+Jvnz58rCvS1pcXJzi4uJKdRsAAAAAAAAAgJJzXN+JDgAAAAAAAABAOMf1nej5/f3332HXG4ah+Ph41apVS4ZhlFFUAAAAAAAAAIBooYjup0mTJhEVx+Pj49W3b19NnjxZvXv3LoPIAAAAAAAAAADRQBHdz//93//pySef1LZt2zRy5Ei1aNFCkvT7779r/vz5aty4sUaPHq3Nmzfr1Vdf1RlnnKHFixerX79+UY4cAAAAAAAAAFAaKKL72blzp3JycrR582YlJycHrJs6dar69Omjo0eP6oknntDkyZPVrVs33XfffRTRAQAAAAAAAKCS4odF/Tz99NO66qqrggroklSjRg1dddVVmj17tiSpZs2aGjNmjNatW1fGUQIAAAAAAAAAygpFdD///POPjhw5Yrk+MzNT+/bt871OSUmRaZplERoAAAAAAAAA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rlKlSkT9o/iO1/yMJGa+G4VHER0oYStWrND48eO1Zs0aLV26VE6nUwMHDlRmZqavzc0336z3339fb775plasWKGdO3fqggsu8K1ft26d6tSpo1dffVUbNmzQ3XffrTvvvFOzZ88O2t7GjRu1a9cu3586deqEjS8zM1N9+vTRjBkzLNsUFF8oX331lTp27Ki3335b69ev1+jRozVq1Ch98MEHAe0SExMD4v3rr7/C9ouSRX5a5+c999yjZ555Rk899ZR++eUXXXfddTr//PP1/fffh+27IqgMx/3IkSMaPHiw7rrrroj32+126+yzz1ZOTo6++uorvfTSS5o7d67uvfdeX5vs7GzVrl1b99xzjzp16hRx3yg55Kd1fhY1ZpQMctM6N+fMmaM777xTU6dO1YYNG3Tfffdp/Pjxev/99yPeDorneM1PrzFjxujSSy8NuS4mJkajRo3SJ598oo0bN+qJJ57Qc889pylTphR6Oyga8tM6P2+77baAWHft2qUTTzxRF198caG3g6I5XvMzkpj5blQAE0Cp2rt3rynJXLFihWmapnno0CEzJibGfPPNN31tfv31V1OSuXr1ast+rr/+erNfv36+18uWLTMlmQcPHixSXFu2bDElmd9//33A8qLGF8pZZ51ljh492vf6xRdfNJOSkooUL0oH+ZmXn/Xq1TNnz54d0OaCCy4wR44cWfgdKOcq2nH3V5htfPTRR6bNZjN3797tWzZnzhwzMTHRzM7ODmp/2mmnmTfddFMRIkdJIj/z8rO4MaNkkZt5udmzZ0/ztttuC3jfLbfcYvbu3btI+4DiO17y09+UKVPMTp06RdT25ptvNvv06VOo/lFyyE9rP/zwgynJXLlyZaH6R8k5HvPTK3/M/vhuFIw70YFSdvjwYUlSjRo1JOX+65/T6dSAAQN8bdq0aaNGjRpp9erVYfvx9uGvc+fOqlevns4880ytWrWq2PEWNb5IY87IyFDjxo2VmpqqYcOGacOGDcWOGUVHfubFnJ2dHfR4oYSEBH355ZfFC7ocqmjHvahWr16tDh06qG7dur5lgwYNUlpaGteecoz8DM7P8hLz8Y7czMtNq8/Mr7/+mkdmRMnxkp9FsXnzZi1evFinnXZatEM5bpGf1p5//nm1atVKffv2jXYox63jOT+tYkZoFNGBUuTxeDRx4kT17t1b7du3lyTt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\\\"},\\\"mime\\\":\\\"image/png\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PEZpZ3VyZSBzaXplIDE1MDB4ODAwIHdpdGggMiBBeGVzPg==\\\"},\\\"mime\\\":\\\"text/plain\\\"}]},{\\\"outputId\\\":\\\"fe920696-3209-4c0d-b453-1ac0fcd28894\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ClBlcmlvZDogMjAyNS0xMC0yMiAxOTowMDowMCB0byAyMDI1LTExLTIxIDE4OjAwOjAwClJlZ2ltZSBkaXN0cmlidXRpb246CiAgQ2xhc3MgMCAoQ2hvcC9NZWFuIFJldmVyc2lvbik6IDQ5MSBob3VycyAoNjguMiUpCiAgQ2xhc3MgMSAoVHJlbmRpbmcpOiAxMzMgaG91cnMgKDE4LjUlKQogIENsYXNzIDIgKEp1bXAvRXZlbnQpOiA5NiBob3VycyAoMTMuMyUpCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import matplotlib.pyplot as plt\\\\nimport numpy as np\\\\n\\\\n# Pick a random 1-month period (720 hours)\\\\ntotal_rows = len(targets)\\\\nif total_rows > 720:\\\\n    start_idx = np.random.randint(0, total_rows - 720)\\\\n    end_idx = start_idx + 720\\\\nelse:\\\\n    start_idx = 0\\\\n    end_idx = total_rows\\\\n\\\\n# Slice data for the period\\\\nperiod_data = features.iloc[start_idx:end_idx].copy()\\\\nperiod_targets = targets.iloc[start_idx:end_idx].copy()\\\\n\\\\n# Get price and regime\\\\nprice = period_data['c'] if 'c' in period_data.columns else period_data.index.to_series()\\\\nregime = period_targets['regime_label']\\\\n\\\\n# Create figure with 2 subplots\\\\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)\\\\n\\\\n# Plot 1: Price with regime background colors\\\\nax1.plot(price.index, price.values, color='black', linewidth=1.5, label='Close Price')\\\\nax1.set_ylabel('Price', fontsize=12)\\\\nax1.set_title(f'Price and Volatility Regimes\\\\\\\\n{price.index[0]} to {price.index[-1]}', fontsize=14)\\\\nax1.grid(True, alpha=0.3)\\\\nax1.legend(loc='upper left')\\\\n\\\\n# Add colored background for regimes\\\\nregime_colors = {0: 'lightgreen', 1: 'lightyellow', 2: 'lightcoral'}\\\\nregime_labels = {0: 'Chop/Mean Reversion', 1: 'Trending', 2: 'Jump/Event'}\\\\n\\\\ny_min, y_max = ax1.get_ylim()\\\\ncurrent_regime = None\\\\nstart_x = None\\\\n\\\\nfor i, (idx, reg) in enumerate(regime.items()):\\\\n    if pd.notna(reg):\\\\n        reg = int(reg)\\\\n        if reg != current_regime:\\\\n            # End previous regime block\\\\n            if current_regime is not None and start_x is not None:\\\\n                ax1.axvspan(start_x, idx, alpha=0.2, color=regime_colors.get(current_regime, 'white'))\\\\n            # Start new regime block\\\\n            current_regime = reg\\\\n            start_x = idx\\\\n            \\\\n# Fill last regime block\\\\nif current_regime is not None and start_x is not None:\\\\n    ax1.axvspan(start_x, regime.index[-1], alpha=0.2, color=regime_colors.get(current_regime, 'white'))\\\\n\\\\n# Plot 2: Regime as colored bars\\\\nregime_numeric = regime.fillna(-1)\\\\ncolors = [regime_colors.get(int(r), 'gray') if r >= 0 else 'gray' for r in regime_numeric]\\\\n\\\\nax2.bar(regime.index, [1]*len(regime), color=colors, width=0.04, edgecolor='none')\\\\nax2.set_ylabel('Regime', fontsize=12)\\\\nax2.set_yticks([0.5])\\\\nax2.set_yticklabels([''])\\\\nax2.set_ylim(0, 1)\\\\nax2.grid(True, alpha=0.3, axis='x')\\\\n\\\\n# Add legend for regimes\\\\nfrom matplotlib.patches import Patch\\\\nlegend_elements = [Patch(facecolor=regime_colors[0], label='0: Chop/Mean Reversion'),\\\\n                   Patch(facecolor=regime_colors[1], label='1: Trending'),\\\\n                   Patch(facecolor=regime_colors[2], label='2: Jump/Event')]\\\\nax2.legend(handles=legend_elements, loc='upper right', ncol=3)\\\\n\\\\nplt.xlabel('Time', fontsize=12)\\\\nplt.tight_layout()\\\\nplt.show()\\\\n\\\\n# Print some stats for this period\\\\nprint(f\\\\\\\"\\\\\\\\nPeriod: {price.index[0]} to {price.index[-1]}\\\\\\\")\\\\nprint(f\\\\\\\"Regime distribution:\\\\\\\")\\\\nregime_counts = regime.value_counts().sort_index()\\\\nfor reg, count in regime_counts.items():\\\\n    if pd.notna(reg):\\\\n        reg_int = int(reg)\\\\n        pct = count / len(regime) * 100\\\\n        print(f\\\\\\\"  Class {reg_int} ({regime_labels.get(reg_int, 'Unknown')}): {count} hours ({pct:.1f}%)\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":12,\\\"executionId\\\":\\\"5ff41ce4-b6a5-42e1-8982-b62bfac22de3\\\",\\\"runStartTime\\\":1764169054514,\\\"runEndTime\\\":1764169055240,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"jupyter-notebook-renderer\\\":2,\\\"vscode.builtin-renderer\\\":1},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"ebc332a8\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":31,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_49631ab7-9ad2-4700-9e9e-b32efabc7177",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_49631ab7-9ad2-4700-9e9e-b32efabc7177","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"98541d13-06b5-427a-b953-dbb166eedf10\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkhlYXZ5IGNhY2hlIHJlYWR5OiBoZWF2eV9mZWF0dXJlc192MS5wa2wgKHRvdGFsIDEpIGluIGNhY2hlL2hlYXZ5X2ZlYXR1cmVzCkhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGUgb3IgZmFpbGVkIHRvIGxvYWQ7IHJ1bm5pbmcgZnVsbCBmaXQuCnJlZ2ltZV9sYWJlbAowICAgIDc3MAoxICAgIDEzNQoyICAgICA1OQpOYW1lOiBjb3VudCwgZHR5cGU6IEludDY0ClsnbycsICdoJywgJ2wnLCAnYycsICd2b2xDY3knLCAndGltZV90b19leHAxX2hyJywgJ3RpbWVfZWxhcHNlZCcsICdob3VyJywgJ2RheV9vZl93ZWVrJywgJ2lzX3dlZWtlbmQnLCAnaG91cl9vZl93ZWVrJywgJ2hvdXJfb2Zfd2Vla19zaW4nLCAnaG91cl9vZl93ZWVrX2NvcycsICdob3Vyc19zaW5jZV93ZWVrX3N0YXJ0JywgJ2RheV90eXBlX251bScsICdwcmV2X2Nsb3NlJywgJ3ZvbENjeV9wcmV2JywgJ3dpbmRvd19wcmV2X2Nsb3NlJywgJ3JldHVybnNfMWgnLCAncmV0dXJuc18yaCcsICdsb2dyZXRfMmgnLCAncmV0dXJuc18zaCcsICdsb2dyZXRfM2gnLCAncmV0dXJuc180aCcsICdsb2dyZXRfNGgnLCAncmV0dXJuc181aCcsICdsb2dyZXRfNWgnLCAncmV0dXJuc182aCcsICdsb2dyZXRfNmgnLCAncmV0dXJuc18xMmgnLCAnbG9ncmV0XzEyaCcsICdyZXR1cm5zXzI0aCcsICdsb2dyZXRfMjRoJywgJ3JldHVybnNfNzJoJywgJ2xvZ3JldF83MmgnLCAncmV0dXJuc18xd2snLCAncmV0dXJuc18xTScsICdyZXRfaF9wYycsICdyZXRfbF9wYycsICdyZXRfY19wYycsICdyZXRfaF9sJywgJ3JhbmdlXzJoJywgJ3JhbmdlX3BjXzJoJywgJ3JhbmdlXzNoJywgJ3JhbmdlX3BjXzNoJywgJ3JhbmdlXzZoJywgJ3JhbmdlX3BjXzZoJywgJ3JhbmdlXzEyaCcsICdyYW5nZV9wY18xMmgnLCAncmFuZ2VfMjRoJywgJ3JhbmdlX3BjXzI0aCcsICdyYW5nZScsICdyYW5nZV9wYycsICdjbG9zZV90b19oaWdoJywgJ2Nsb3NlX3RvX2xvdycsICdjbG9zZV9wb3NfaW5fYmFyJywgJ2xvZ3JldF9oX3BjJywgJ2xvZ3JldF9sX3BjJywgJ2xvZ3JldF9jX3BjJywgJ2lzX2RzdCcsICd0dGVfcGhhc2VfY29zJywgJ3R0ZV9waGFzZV9zaW4nLCAnbW9tZW50dW1fM2gnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfM2gnLCAndHJlbmRfc3RyZW5ndGhfM2gnLCAnbW9tZW50dW1fNmgnLCAnbW9tZW50dW1fc2lnbmVkX3NxcnRfNmgnLCAndHJlbmRfc3RyZW5ndGhfNmgnLCAnbW9tZW50dW1fMTJoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzEyaCcsICd0cmVuZF9zdHJlbmd0aF8xMmgnLCAnbW9tZW50dW1fMjRoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzI0aCcsICd0cmVuZF9zdHJlbmd0aF8yNGgnLCAnbW9tZW50dW1fNzJoJywgJ21vbWVudHVtX3NpZ25lZF9zcXJ0XzcyaCcsICd0cmVuZF9zdHJlbmd0aF83MmgnLCAnbW9tZW50dW1fMTQ0aCcsICdtb21lbnR1bV9zaWduZWRfc3FydF8xNDRoJywgJ3RyZW5kX3N0cmVuZ3RoXzE0NGgnLCAnbW9tZW50dW1fMjg4aCcsICdtb21lbnR1bV9zaWduZWRfc3FydF8yODhoJywgJ3RyZW5kX3N0cmVuZ3RoXzI4OGgnLCAnbWFjZCcsICdtYWNkX3NpZ25hbCcsICdtYWNkX2hpc3QnLCAnYWR4JywgJ2FkeF9wb3MnLCAnYWR4X25lZycsICdzdG9jaF9wb3NfM2gnLCAnZGlzdF9mcm9tX2hpZ2hfM2gnLCAnZGlzdF9mcm9tX2xvd18zaCcsICdwcmljZV9yYW5rXzNoJywgJ3N0b2NoX3Bvc182aCcsICdkaXN0X2Zyb21faGlnaF82aCcsICdkaXN0X2Zyb21fbG93XzZoJywgJ3ByaWNlX3JhbmtfNmgnLCAnc3RvY2hfcG9zXzEyaCcsICdkaXN0X2Zyb21faGlnaF8xMmgnLCAnZGlzdF9mcm9tX2xvd18xMmgnLCAncHJpY2VfcmFua18xMmgnLCAnc3RvY2hfcG9zXzI0aCcsICdkaXN0X2Zyb21faGlnaF8yNGgnLCAnZGlzdF9mcm9tX2xvd18yNGgnLCAncHJpY2VfcmFua18yNGgnLCAnc3RvY2hfcG9zXzcyaCcsICdkaXN0X2Zyb21faGlnaF83MmgnLCAnZGlzdF9mcm9tX2xvd183MmgnLCAncHJpY2VfcmFua183MmgnLCAnc3RvY2hfcG9zXzE0NGgnLCAnZGlzdF9mcm9tX2hpZ2hfMTQ0aCcsICdkaXN0X2Zyb21fbG93XzE0NGgnLCAncHJpY2VfcmFua18xNDRoJywgJ3N0b2NoX3Bvc18yODhoJywgJ2Rpc3RfZnJvbV9oaWdoXzI4OGgnLCAnZGlzdF9mcm9tX2xvd18yODhoJywgJ3ByaWNlX3JhbmtfMjg4aCcsICduZXdfMjRoX2hpZ2gnLCAnbmV3XzI0aF9sb3cnLCAndmxtX21hXzNoJywgJ3ZsbV96c2NvcmVfM2gnLCAndmxtX21hXzZoJywgJ3ZsbV96c2NvcmVfNmgnLCAndmxtX21hXzEyaCcsICd2bG1fenNjb3JlXzEyaCcsICd2bG1fbWFfMjRoJywgJ3ZsbV96c2NvcmVfMjRoJywgJ3ZsbV9tYV83MmgnLCAndmxtX3pzY29yZV83MmgnLCAndmxtX21hXzE0NGgnLCAndmxtX3pzY29yZV8xNDRoJywgJ3ZsbV9tYV8yODhoJywgJ3ZsbV96c2NvcmVfMjg4aCcsICd2b2xfcmF3XzNoJywgJ3ZvbF9na3l6XzNoJywgJ3ZvbF9wYXJraW5zb25fM2gnLCAndm9sX3pzY29yZV8zaCcsICdsb2dfdm9sXzNoJywgJ3ZvbF9yYXdfNmgnLCAndm9sX2dreXpfNmgnLCAndm9sX3BhcmtpbnNvbl82aCcsICd2b2xfenNjb3JlXzZoJywgJ2xvZ192b2xfNmgnLCAndm9sX3Jhd18xMmgnLCAndm9sX2dreXpfMTJoJywgJ3ZvbF9wYXJraW5zb25fMTJoJywgJ3ZvbF96c2NvcmVfMTJoJywgJ2xvZ192b2xfMTJoJywgJ3ZvbF9yYXdfMjRoJywgJ3ZvbF9na3l6XzI0aCcsICd2b2xfcGFya2luc29uXzI0aCcsICd2b2xfenNjb3JlXzI0aCcsICdsb2dfdm9sXzI0aCcsICd2b2xfcmF3XzcyaCcsICd2b2xfZ2t5el83MmgnLCAndm9sX3BhcmtpbnNvbl83MmgnLCAndm9sX3pzY29yZV83MmgnLCAnbG9nX3ZvbF83MmgnLCAndm9sX3Jhd18xNDRoJywgJ3ZvbF9na3l6XzE0NGgnLCAndm9sX3BhcmtpbnNvbl8xNDRoJywgJ3ZvbF96c2NvcmVfMTQ0aCcsICdsb2dfdm9sXzE0NGgnLCAndm9sX3Jhd18yODhoJywgJ3ZvbF9na3l6XzI4OGgnLCAndm9sX3BhcmtpbnNvbl8yODhoJywgJ3ZvbF96c2NvcmVfMjg4aCcsICdsb2dfdm9sXzI4OGgnLCAncmV0dXJuc19za2V3XzI0aCcsICdyZXR1cm5zX2t1cnRvc2lzXzI0aCcsICd2b2xfcmF0aW9fMjRoXzE0NGgnLCAndm9sX3JhdGlvXzI0aF8yODhoJywgJ2V4cF9yZXRfcDkwXzI0aCcsICdleHBfcmV0X3A3NV8yNGgnLCAnZXhwX3JldF9wMjVfMjRoJywgJ2V4cF9yZXRfcDEwXzI0aCcsICdleHBfYmFuZF93aWR0aF8yNGgnLCAnZXhwX2xvZ21vdmVfcDkwXzI0aCcsICdleHBfbG9nbW92ZV9wMTBfMjRoJywgJ2V4cF9yZXRfcDkwX3R0ZScsICdleHBfcmV0X3AxMF90dGUnLCAnZXhwX2JhbmRfd2lkdGhfdHRlJywgJ2V4cF9sb2dtb3ZlX3A5MF90dGUnLCAnZXhwX2xvZ21vdmVfcDEwX3R0ZScsICdyZWFsaXplZF90b19leHBlY3RlZF8yNGgnLCAncmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlJywgJ3ByZXZfd2Vla2RheV9Qcm9nQWN0UCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblAnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluVCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFQnLCAncHJldl93ZWVrZGF5X1Byb2dWbG0nLCAncHJldl93ZWVrZGF5X1JlbUFjdFAnLCAncHJldl93ZWVrZGF5X1JlbU1pblAnLCAncHJldl93ZWVrZGF5X1JlbU1heFAnLCAncHJldl93ZWVrZGF5X1JlbU1pblQnLCAncHJldl93ZWVrZGF5X1JlbU1heFQnLCAncHJldl9zYXR1cmRheV9Qcm9nQWN0UCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNaW5QJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFAnLCAncHJldl9zYXR1cmRheV9Qcm9nTWluVCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhUJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ1ZsbScsICdwcmV2X3NhdHVyZGF5X1JlbUFjdFAnLCAncHJldl9zYXR1cmRheV9SZW1NaW5QJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWF4UCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblQnLCAncHJldl9zYXR1cmRheV9SZW1NYXhUJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5UJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhUJywgJ3ByZXZfc3VuZGF5X1Byb2dWbG0nLCAncHJldl9zdW5kYXlfUmVtQWN0UCcsICdwcmV2X3N1bmRheV9SZW1NaW5QJywgJ3ByZXZfc3VuZGF5X1JlbU1heFAnLCAncHJldl9zdW5kYXlfUmVtTWluVCcsICdwcmV2X3N1bmRheV9SZW1NYXhUJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWluUF9tZWRfOTAnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5QX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfcDkwXzkwJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4UF9tZWRfOTAnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX3AxMF85MCcsICdwcmV2X3dlZWtkYXlfUHJvZ01heFBfcDkwXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NaW5QX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWluUF9wMTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1pblBfcDkwXzkwJywgJ3ByZXZfd2Vla2RheV9SZW1NYXhQX21lZF85MCcsICdwcmV2X3dlZWtkYXlfUmVtTWF4UF9wMTBfOTAnLCAncHJldl93ZWVrZGF5X1JlbU1heFBfcDkwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfbWVkXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfcDkwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfbWVkXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfcDEwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01heFBfcDkwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWluUF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NaW5QX3AxMF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1pblBfcDkwXzkwJywgJ3ByZXZfc2F0dXJkYXlfUmVtTWF4UF9tZWRfOTAnLCAncHJldl9zYXR1cmRheV9SZW1NYXhQX3AxMF85MCcsICdwcmV2X3NhdHVyZGF5X1JlbU1heFBfcDkwXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNaW5QX21lZF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01pblBfcDkwXzkwJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQX21lZF85MCcsICdwcmV2X3N1bmRheV9Qcm9nTWF4UF9wMTBfOTAnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfcDkwXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1pblBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1pblBfcDEwXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1pblBfcDkwXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1heFBfbWVkXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1heFBfcDEwXzkwJywgJ3ByZXZfc3VuZGF5X1JlbU1heFBfcDkwXzkwJywgJ2VtcF9mcmVxX2xvZ3JldF9oX3BjX2dlXzAuMDAwMScsICdlbXBfZnJlcV9sb2dyZXRfbF9wY19sZV8tMC4wMDAxJywgJ2VtcF9mcmVxX2xvZ3JldF9oX3BjX2dlXzAuMDAwNScsICdlbXBfZnJlcV9sb2dyZXRfbF9wY19sZV8tMC4wMDA1JywgJ2VtcF9mcmVxX2xvZ3JldF9oX3BjX2dlXzAuMDAxJywgJ2VtcF9mcmVxX2xvZ3JldF9sX3BjX2xlXy0wLjAwMScsICdlbXBfcGN0XzVfbG9ncmV0X2hfcGMnLCAnZW1wX3BjdF81X2xvZ3JldF9sX3BjJywgJ2VtcF9wY3RfMzBfbG9ncmV0X2hfcGMnLCAnZW1wX3BjdF8zMF9sb2dyZXRfbF9wYycsICdlbXBfcGN0XzUwX2xvZ3JldF9oX3BjJywgJ2VtcF9wY3RfNTBfbG9ncmV0X2xfcGMnLCAnZW1wX3BjdF83MF9sb2dyZXRfaF9wYycsICdlbXBfcGN0XzcwX2xvZ3JldF9sX3BjJywgJ2VtcF9wY3RfOTVfbG9ncmV0X2hfcGMnLCAnZW1wX3BjdF85NV9sb2dyZXRfbF9wYycsICdlbXBfbWVkaWFuX2xvZ3JldF9yYW5nZScsICdlbXBfbWVkaWFuX3JlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCcsICdlbXBfbWVkaWFuX3JlYWxpemVkX3RvX2V4cGVjdGVkX3R0ZScsICdjQ1Byb2dBY3RQJywgJ2NDUHJvZ01pblAnLCAnY0NQcm9nTWF4UCcsICdjQ1Byb2dNaW5UJywgJ2NDUHJvZ01heFQnLCAnY0NQcm9nVmxtJywgJ3ZvbF93ZWlnaHRlZF92b2wnLCAndm9sX3ZsbV9yYXRpb19jaGFuZ2UnLCAnYXN5bV92b2xfdmxtX2ltcGFjdCcsICdtb21lbnR1bV9hY2NlbF82aCcsICdtb21lbnR1bV9hY2NlbF8xMmgnLCAnbW9tZW50dW1fYWNjZWxfMjRoJywgJ3NpZ25lZF9tb21lbnR1bV9wb3dlcicsICdtb21fdm9sX2ludGVyYWN0aW9uJywgJ2NvbXByZXNzZWRfcmFuZ2Vfdm9sJywgJ3JhbmdlX2V4cGFuc2lvbicsICdubF9wb3NfaW5fcmFuZ2UnLCAndm9sdW1lX3N1cnByaXNlJywgJ2xpcV92b2wnLCAnbGlxX3ZvbF9yYXRpb19jaGFuZ2UnLCAndm9sdW1lX3RyZW5kX3onLCAnZXhwX2RlY2F5X3JldF82aCcsICdleHBfZGVjYXlfcmV0XzEyaCcsICdleHBfZGVjYXlfcmV0XzI0aCcsICd0aW1lX2Fkal92b2wnLCAnY3ljbGljYWxfdm9sX2NvbXByZXNzaW9uJywgJ2V4dHJlbWVfcHJvYicsICd2b2xfY2x1c3RlcmluZycsICd2b2xfZ2t5el8yNGhfeF90dGVfc3FydCcsICd2b2xfZ2t5el8yNGhfeF90dGUnLCAndm9sX2dreXpfMjRoX3hfdHRlX3NxJywgJ3ZvbF9na3l6XzI0aF94X3R0ZV9jdScsICd2bG1fbWFfMjRoX3hfdHRlX3NxcnQnLCAndmxtX21hXzI0aF94X3R0ZScsICd2bG1fbWFfMjRoX3hfdHRlX3NxJywgJ3ZsbV9tYV8yNGhfeF90dGVfY3UnLCAncmV0dXJuc19rdXJ0b3Npc18yNGhfeF90dGVfc3FydCcsICdyZXR1cm5zX2t1cnRvc2lzXzI0aF94X3R0ZScsICdyZXR1cm5zX2t1cnRvc2lzXzI0aF94X3R0ZV9zcScsICdyZXR1cm5zX2t1cnRvc2lzXzI0aF94X3R0ZV9jdScsICdyZXR1cm5zX3NrZXdfMjRoX3hfdHRlX3NxcnQnLCAncmV0dXJuc19za2V3XzI0aF94X3R0ZScsICdyZXR1cm5zX3NrZXdfMjRoX3hfdHRlX3NxJywgJ3JldHVybnNfc2tld18yNGhfeF90dGVfY3UnLCAnZXh0cmVtZV9wcm9iX3hfdHRlX3NxcnQnLCAnZXh0cmVtZV9wcm9iX3hfdHRlJywgJ2V4dHJlbWVfcHJvYl94X3R0ZV9zcScsICdleHRyZW1lX3Byb2JfeF90dGVfY3UnLCAndm9sX2NsdXN0ZXJpbmdfeF90dGVfc3FydCcsICd2b2xfY2x1c3RlcmluZ194X3R0ZScsICd2b2xfY2x1c3RlcmluZ194X3R0ZV9zcScsICd2b2xfY2x1c3RlcmluZ194X3R0ZV9jdScsICdleHBfcmV0X3A5MF8yNGhfeF90dGVfc3FydCcsICdleHBfcmV0X3A5MF8yNGhfeF90dGUnLCAnZXhwX3JldF9wOTBfMjRoX3hfdHRlX3NxJywgJ2V4cF9yZXRfcDkwXzI0aF94X3R0ZV9jdScsICdleHBfcmV0X3AxMF8yNGhfeF90dGVfc3FydCcsICdleHBfcmV0X3AxMF8yNGhfeF90dGUnLCAnZXhwX3JldF9wMTBfMjRoX3hfdHRlX3NxJywgJ2V4cF9yZXRfcDEwXzI0aF94X3R0ZV9jdScsICdleHBfYmFuZF93aWR0aF8yNGhfeF90dGVfc3FydCcsICdleHBfYmFuZF93aWR0aF8yNGhfeF90dGUnLCAnZXhwX2JhbmRfd2lkdGhfMjRoX3hfdHRlX3NxJywgJ2V4cF9iYW5kX3dpZHRoXzI0aF94X3R0ZV9jdScsICdleHBfcmV0X3A5MF90dGVfeF90dGVfc3FydCcsICdleHBfcmV0X3A5MF90dGVfeF90dGUnLCAnZXhwX3JldF9wOTBfdHRlX3hfdHRlX3NxJywgJ2V4cF9yZXRfcDkwX3R0ZV94X3R0ZV9jdScsICdleHBfcmV0X3AxMF90dGVfeF90dGVfc3FydCcsICdleHBfcmV0X3AxMF90dGVfeF90dGUnLCAnZXhwX3JldF9wMTBfdHRlX3hfdHRlX3NxJywgJ2V4cF9yZXRfcDEwX3R0ZV94X3R0ZV9jdScsICdleHBfYmFuZF93aWR0aF90dGVfeF90dGVfc3FydCcsICdleHBfYmFuZF93aWR0aF90dGVfeF90dGUnLCAnZXhwX2JhbmRfd2lkdGhfdHRlX3hfdHRlX3NxJywgJ2V4cF9iYW5kX3dpZHRoX3R0ZV94X3R0ZV9jdScsICdzaG9ja19hYnNvcnB0aW9uJywgJ3ZvbF9na3l6XzNoX3hfdHRlX3NxcnQnLCAndm9sX2dreXpfM2hfeF90dGUnLCAndm9sX2dreXpfM2hfeF90dGVfc3EnLCAndm9sX2dreXpfM2hfeF90dGVfc2luJywgJ3ZvbF9na3l6XzNoX3hfdHRlX2NvcycsICd2b2xfZ2t5el82aF94X3R0ZV9zcXJ0JywgJ3ZvbF9na3l6XzZoX3hfdHRlJywgJ3ZvbF9na3l6XzZoX3hfdHRlX3NxJywgJ3ZvbF9na3l6XzZoX3hfdHRlX3NpbicsICd2b2xfZ2t5el82aF94X3R0ZV9jb3MnLCAndm9sX2dreXpfMTJoX3hfdHRlX3NxcnQnLCAndm9sX2dreXpfMTJoX3hfdHRlJywgJ3ZvbF9na3l6XzEyaF94X3R0ZV9zcScsICd2b2xfZ2t5el8xMmhfeF90dGVfc2luJywgJ3ZvbF9na3l6XzEyaF94X3R0ZV9jb3MnLCAndm9sX2dreXpfMjRoX3hfdHRlX3NpbicsICd2b2xfZ2t5el8yNGhfeF90dGVfY29zJywgJ3ZvbF9na3l6XzI4OGhfeF90dGVfc3FydCcsICd2b2xfZ2t5el8yODhoX3hfdHRlJywgJ3ZvbF9na3l6XzI4OGhfeF90dGVfc3EnLCAndm9sX2dreXpfMjg4aF94X3R0ZV9zaW4nLCAndm9sX2dreXpfMjg4aF94X3R0ZV9jb3MnLCAndm9sX3Jhd18yNGhfeF90dGVfc3FydCcsICd2b2xfcmF3XzI0aF94X3R0ZScsICd2b2xfcmF3XzI0aF94X3R0ZV9zcScsICd2b2xfcmF3XzI0aF94X3R0ZV9zaW4nLCAndm9sX3Jhd18yNGhfeF90dGVfY29zJywgJ3ZvbF9yYXdfMjg4aF94X3R0ZV9zcXJ0JywgJ3ZvbF9yYXdfMjg4aF94X3R0ZScsICd2b2xfcmF3XzI4OGhfeF90dGVfc3EnLCAndm9sX3Jhd18yODhoX3hfdHRlX3NpbicsICd2b2xfcmF3XzI4OGhfeF90dGVfY29zJywgJ3ZvbF90ZXJtX3hfdHRlX3NxcnQnLCAndm9sX3Rlcm1feF90dGUnLCAndm9sX3Rlcm1feF90dGVfc3EnLCAndm9sX2dreXpfM2hfd2Vla2VuZCcsICd2b2xfZ2t5el8zaF93ZWVrZGF5JywgJ3ZvbF9na3l6XzZoX3dlZWtlbmQnLCAndm9sX2dreXpfNmhfd2Vla2RheScsICd2b2xfZ2t5el8xMmhfd2Vla2VuZCcsICd2b2xfZ2t5el8xMmhfd2Vla2RheScsICd2b2xfZ2t5el8yNGhfd2Vla2VuZCcsICd2b2xfZ2t5el8yNGhfd2Vla2RheScsICdwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3dlZWtlbmQnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF93ZWVrZW5kJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfd2Vla2VuZCcsICdwcmV2X3NhdHVyZGF5X1Byb2dWbG1fd2Vla2VuZCcsICdwcmV2X3N1bmRheV9Qcm9nQWN0UF93ZWVrZW5kJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQX3dlZWtlbmQnLCAncHJldl9zdW5kYXlfUHJvZ01pblBfd2Vla2VuZCcsICdwcmV2X3N1bmRheV9Qcm9nVmxtX3dlZWtlbmQnLCAndm9sdW1lX3dlZWtlbmRfZWZmZWN0JywgJ3ByZXZfd2Vla2RheV9Qcm9nQWN0UF94X3ZvbDZoJywgJ3ByZXZfd2Vla2RheV9Qcm9nQWN0UF94X3ZvbDEyaCcsICdwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGgnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX3hfdm9sNmgnLCAncHJldl93ZWVrZGF5X1Byb2dNYXhQX3hfdm9sMTJoJywgJ3ByZXZfd2Vla2RheV9Qcm9nTWF4UF94X3ZvbDI0aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2w2aCcsICdwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wxMmgnLCAncHJldl93ZWVrZGF5X1Byb2dNaW5QX3hfdm9sMjRoJywgJ3ByZXZfd2Vla2RheV9Qcm9nVmxtX3hfdm9sNmgnLCAncHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2wxMmgnLCAncHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2wyNGgnLCAncHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDZoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfeF92b2wxMmgnLCAncHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDI0aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sNmgnLCAncHJldl9zYXR1cmRheV9Qcm9nTWF4UF94X3ZvbDEyaCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfeF92b2w2aCcsICdwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMTJoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ01pblBfeF92b2wyNGgnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtX3hfdm9sNmgnLCAncHJldl9zYXR1cmRheV9Qcm9nVmxtX3hfdm9sMTJoJywgJ3ByZXZfc2F0dXJkYXlfUHJvZ1ZsbV94X3ZvbDI0aCcsICdwcmV2X3N1bmRheV9Qcm9nQWN0UF94X3ZvbDZoJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sMTJoJywgJ3ByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sMjRoJywgJ3ByZXZfc3VuZGF5X1Byb2dNYXhQX3hfdm9sNmgnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wxMmgnLCAncHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGgnLCAncHJldl9zdW5kYXlfUHJvZ01pblBfeF92b2w2aCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF94X3ZvbDEyaCcsICdwcmV2X3N1bmRheV9Qcm9nTWluUF94X3ZvbDI0aCcsICdwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sNmgnLCAncHJldl9zdW5kYXlfUHJvZ1ZsbV94X3ZvbDEyaCcsICdwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoJywgJ3ByZXZfd2Vla2RheV9yYW5nZV94X3ZvbCcsICdwcmV2X3NhdHVyZGF5X3JhbmdlX3hfdm9sJywgJ3ByZXZfc3VuZGF5X3JhbmdlX3hfdm9sJywgJ3dlZWtkYXlfdnNfc2F0dXJkYXlfcHJvZycsICd3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nJywgJ3ByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyJywgJ2V4dHJlbWVfcmFuZ2Vfdm9sJywgJ3NrZXdfdm9sX2V4dHJlbWUnLCAna3VydG9zaXNfdm9sX2V4dHJlbWUnLCAnZGlzdGFuY2Vfdm9sX2V4dHJlbWUnLCAndm9sX3N1cnByaXNlX2NsdXN0ZXJpbmcnXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\n\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\n\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\n\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nhistory_slice = raw_history[-1000:]\\\\n\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n# existing_fe: Optional[FeatureEngineer] = None\\\\n# if \\\\\\\"feature_engineer\\\\\\\" in globals() and isinstance(feature_engineer, FeatureEngineer):\\\\n#     existing_fe = feature_engineer\\\\n\\\\n# if existing_fe is not None:\\\\n#     print(\\\\\\\"Reusing existing FeatureEngineer instance.\\\\\\\")\\\\n#     fe = existing_fe\\\\n# else:\\\\n#     print(\\\\\\\"Instantiating new FeatureEngineer instance.\\\\\\\")\\\\n#     fe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\nfe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n\\\\ncache_ready = False  # Force rebuild for testing\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"Loaded heavy cache payload from disk; skipping rebuild.\\\\\\\")\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\nelse:\\\\n    print(\\\\\\\"Heavy cache not available or failed to load; running full fit.\\\\\\\")\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=verbose_flag, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## Add targets standard expiration targets\\\\n# target_engineer = ExpirationTargetEngineer(**CONFIG[\\\\\\\"targets\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\n# target_engineer.fit(features)\\\\n# targets = target_engineer.transform(features)\\\\n\\\\n## 2a. Volatility Regime Target Engineering Test ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\ndf_train = features.copy()\\\\n\\\\n# Instantiate with your parameters\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas (scaled internally for 6h window)\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n\\\\n    # Hardening Parameters\\\\n    trend_min_efficiency=0.15, # Allows looser/messier trends\\\\n    trend_min_r2=0.6           # Requires moderate linear fit\\\\n)\\\\n\\\\n# Run Fit/Transform\\\\nregime_engineer.fit(df_train)\\\\ntargets = regime_engineer.transform(df_train)\\\\n\\\\n# Check the distribution\\\\ndist = regime_engineer.get_regime_distribution(df_train)\\\\nprint(dist)\\\\n\\\\n\\\\n\\\\n\\\\n# --- 2b. Adding Derived Probability Features (from pre-trained models) ---\\\\n# derived_proba_config = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"derived_probability_features\\\\\\\", {})\\\\n# print(f'derived_proba_config: {derived_proba_config}')\\\\n# if derived_proba_config.get(\\\\\\\"enabled\\\\\\\", False):\\\\n#     print(\\\\\\\"\\\\\\\\n2b. Adding Derived Probability Features\\\\\\\")\\\\n#     features, newly_added_proba_features = generate_and_add_derived_probability_features(\\\\n#         features.copy(),\\\\n#         derived_proba_config,\\\\n#         paths\\\\n#     )\\\\n#     if newly_added_proba_features:\\\\n#         print(f\\\\\\\"  Successfully added derived probability features: {newly_added_proba_features}\\\\\\\")\\\\n#         # Check for NaNs in each new feature\\\\n#         for feat in newly_added_proba_features:\\\\n#             if feat in features.columns:\\\\n#                 n_nans = features[feat].isna().sum()\\\\n#                 print(f\\\\\\\"    [NaN check] {feat}: {n_nans} NaNs ({n_nans/len(features):.2%} of rows)\\\\\\\")\\\\n#             else:\\\\n#                 print(f\\\\\\\"    [NaN check] {feat}: not found in features DataFrame!\\\\\\\")\\\\n#     else:\\\\n#         print(\\\\\\\"  No new derived probability features were added (or generation was disabled).\\\\\\\")\\\\n\\\\ninitial_feature_names = list(features.columns)\\\\n\\\\n# Generate targets (your existing logic)\\\\nprint(initial_feature_names)\\\\n\\\\n\\\\n## deop pice columns from features\\\\n# drop_cols = [col for col in ['o', 'h', 'l', 'c'] if col in features.columns]\\\\n# if drop_cols: features = features.drop(columns=drop_cols)\\\\n\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"b11f96b9-cfd2-4ed3-b8d1-652069a68faf\\\",\\\"runStartTime\\\":1764176686866,\\\"runEndTime\\\":1764176703479,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":6,\\\"id\\\":\\\"a391dd06\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"171391f3-8ecf-4b15-a232-176c6a338e84\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":6,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+cHJldl9zYXR1cmRheV9yYW5nZV94X3ZvbDwvdGg+CiAgICAgIDx0aD5wcmV2X3N1bmRheV9yYW5nZV94X3ZvbDwvdGg+CiAgICAgIDx0aD53ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2c8L3RoPgogICAgICA8dGg+d2Vla2RheV92c19zdW5kYXlfcHJvZzwvdGg+CiAgICAgIDx0aD5wcmV2X2N5Y2xlX3Byb2dyZXNzX3hfaG91cjwvdGg+CiAgICAgIDx0aD5leHRyZW1lX3JhbmdlX3ZvbDwvdGg+CiAgICAgIDx0aD5za2V3X3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPmt1cnRvc2lzX3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPmRpc3RhbmNlX3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPnZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nPC90aD4KICAgIDwvdHI+CiAgPC90aGVhZD4KICA8dGJvZHk+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTEwLTE1IDIwOjAwOjAwPC90aD4KICAgICAgPHRkPjExMTI2MC4xPC90ZD4KICAgICAgPHRkPjExMTU1MC44PC90ZD4KICAgICAgPHRkPjExMDUwOC4zPC90ZD4KICAgICAgPHRkPjExMTA5OS44PC90ZD4KICAgICAgPHRkPjMyOS4wPC90ZD4KICAgICAgPHRkPjExLjA8L3RkPgogICAgICA8dGQ+MTMuMDwvdGQ+CiAgICAgIDx0ZD4yMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+LTAuMDA2OTA3PC90ZD4KICAgICAgPHRkPi0wLjAyMTY5NDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDQwNTg8L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMC0xNSAyMTowMDowMDwvdGg+CiAgICAgIDx0ZD4xMTExMDIuMDwvdGQ+CiAgICAgIDx0ZD4xMTE0MzIuNzwvdGQ+CiAgICAgIDx0ZD4xMTA0NjMuMzwvdGQ+CiAgICAgIDx0ZD4xMTA4NDQuOTwvdGQ+CiAgICAgIDx0ZD4yODMuMDwvdGQ+CiAgICAgIDx0ZD4xMC4wPC90ZD4KICAgICAgPHRkPjE0LjA8L3RkPgogICAgICA8dGQ+MjI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPi0wLjAwNzczOTwvdGQ+CiAgICAgIDx0ZD4tMC4wMjM4MjM8L3RkPgogICAgICA8dGQ+LTAuMDA0MDQzPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjI6MDA6MDA8L3RoPgogICAgICA8dGQ+MTEwODQ3LjQ8L3RkPgogICAgICA8dGQ+MTExMzk5LjA8L3RkPgogICAgICA8dGQ+MTEwNjUzLjE8L3RkPgogICAgICA8dGQ+MTEwNjUzLjE8L3RkPgogICAgICA8dGQ+MTc3LjA8L3RkPgogICAgICA8dGQ+OS4wPC90ZD4KICAgICAgPHRkPjE1LjA8L3RkPgogICAgICA8dGQ+MjM8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPi0wLjAwOTgzMDwvdGQ+CiAgICAgIDx0ZD4tMC4wMzE1NDg8L3RkPgogICAgICA8dGQ+LTAuMDA0MzQxPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTAtMTUgMjM6MDA6MDA8L3RoPgogICAgICA8dGQ+MTEwNjUzLjI8L3RkPgogICAgICA8dGQ+MTExMDE1Ljc8L3RkPgogICAgICA8dGQ+MTEwNTc3LjE8L3RkPgogICAgICA8dGQ+MTEwNzUzLjQ8L3RkPgogICAgICA8dGQ+NzMuMDwvdGQ+CiAgICAgIDx0ZD44LjA8L3RkPgogICAgICA8dGQ+MTYuMDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD4tMC4wMDg3NTg8L3RkPgogICAgICA8dGQ+LTAuMDI1NzQyPC90ZD4KICAgICAgPHRkPi0wLjAwMzU3NjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTEwLTE2IDAwOjAwOjAwPC90aD4KICAgICAgPHRkPjExMDc1My4zPC90ZD4KICAgICAgPHRkPjExMDg1Ny42PC90ZD4KICAgICAgPHRkPjExMDM2Ni4wPC90ZD4KICAgICAgPHRkPjExMDQzOC4wPC90ZD4KICAgICAgPHRkPjE5OC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPi0wLjAwODgxODwvdGQ+CiAgICAgIDx0ZD4tMC4wMjE1Njc8L3RkPgogICAgICA8dGQ+LTAuMDAzNzQ1PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+TmFOPC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAxMjcyNTwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA4OjAwOjAwPC90aD4KICAgICAgPHRkPjg3ODcyLjc8L3RkPgogICAgICA8dGQ+ODc4ODEuODwvdGQ+CiAgICAgIDx0ZD44NzM0Mi45PC90ZD4KICAgICAgPHRkPjg3MzYxLjc8L3RkPgogICAgICA8dGQ+MjMyLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+OTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDAxNDg2PC90ZD4KICAgICAgPHRkPjAuMDAxMTQzPC90ZD4KICAgICAgPHRkPi0wLjAwMTc4OTwvdGQ+CiAgICAgIDx0ZD4tMC4wMDEyNDk8L3RkPgogICAgICA8dGQ+LTAuMDAwNzU5PC90ZD4KICAgICAgPHRkPjAuMDA3NTk4PC90ZD4KICAgICAgPHRkPjAuMDE0NTcyPC90ZD4KICAgICAgPHRkPi0xLjExNTI0MjwvdGQ+CiAgICAgIDx0ZD4wLjAyNjk3MjwvdGQ+CiAgICAgIDx0ZD4tNi4zMTg2OTE8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDAxNTcxPC90ZD4KICAgICAgPHRkPjAuMDAzOTc5PC90ZD4KICAgICAgPHRkPi0wLjAwMjIxMDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDc2MjE8L3RkPgogICAgICA8dGQ+LTAuMDAxNjIyPC90ZD4KICAgICAgPHRkPjAuMDE0NDI2PC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAwMTkyMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg3MDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDQ5MTM8L3RkPgogICAgICA8dGQ+LTAuMDA3NTE2PC90ZD4KICAgICAgPHRkPi0wLjAwMzIwOTwvdGQ+CiAgICAgIDx0ZD4wLjAxODkzMTwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDExOjAwOjAwPC90aD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44NjgxOC44PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjEyPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDE4NzI8L3RkPgogICAgICA8dGQ+MC4wMDM5NjM8L3RkPgogICAgICA8dGQ+LTAuMDAyMDYxPC90ZD4KICAgICAgPHRkPi0wLjAwNDcxMjwvdGQ+CiAgICAgIDx0ZD4tMC4wMDExODM8L3RkPgogICAgICA8dGQ+MC4wMTI2OTg8L3RkPgogICAgICA8dGQ+LTAuMDk0ODU5PC90ZD4KICAgICAgPHRkPi0wLjk0MzU5MzwvdGQ+CiAgICAgIDx0ZD4wLjAzMjkxNTwvdGQ+CiAgICAgIDx0ZD4tNS40MDY5MDM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD4xMDAwIHJvd3Mgw5cgNDUwIGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gICAgICAgICBoICAgICAgICAgbCAgICAgICAgIGMgIHZvbENjeSAgXAoyMDI1LTEwLTE1IDIwOjAwOjAwICAxMTEyNjAuMSAgMTExNTUwLjggIDExMDUwOC4zICAxMTEwOTkuOCAgIDMyOS4wICAgCjIwMjUtMTAtMTUgMjE6MDA6MDAgIDExMTEwMi4wICAxMTE0MzIuNyAgMTEwNDYzLjMgIDExMDg0NC45ICAgMjgzLjAgICAKMjAyNS0xMC0xNSAyMjowMDowMCAgMTEwODQ3LjQgIDExMTM5OS4wICAxMTA2NTMuMSAgMTEwNjUzLjEgICAxNzcuMCAgIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAxMTA2NTMuMiAgMTExMDE1LjcgIDExMDU3Ny4xICAxMTA3NTMuNCAgICA3My4wICAgCjIwMjUtMTAtMTYgMDA6MDA6MDAgIDExMDc1My4zICAxMTA4NTcuNiAgMTEwMzY2LjAgIDExMDQzOC4wICAgMTk4LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgLi4uICAgICAgIC4uLiAgICAgICAuLi4gICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgODc3MjUuMiAgIDg3OTAwLjAgICA4NzYzNy43ICAgODc4NzIuNiAgIDE5NS4wICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICA4Nzg3Mi43ICAgODc4ODEuOCAgIDg3MzQyLjkgICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgIDg3MzUzLjUgICA4NzM5Ni43ICAgODY2MjcuOSAgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgODY3NzIuMiAgIDg2OTk5LjkgICA4NjU5NS44ICAgODY4NzkuNyAgIDE5NS4wICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICA4Njg3OS43ICAgODY4NzkuNyAgIDg2ODE4LjggICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDI1LTEwLTE1IDIwOjAwOjAwICAgICAgICAgICAgIDExLjAgICAgICAgICAgMTMuMCAgICAyMSAgICAgICAgICAgIDIgICAKMjAyNS0xMC0xNSAyMTowMDowMCAgICAgICAgICAgICAxMC4wICAgICAgICAgIDE0LjAgICAgMjIgICAgICAgICAgICAyICAgCjIwMjUtMTAtMTUgMjI6MDA6MDAgICAgICAgICAgICAgIDkuMCAgICAgICAgICAxNS4wICAgIDIzICAgICAgICAgICAgMiAgIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAgICAgICAgICAgICA4LjAgICAgICAgICAgMTYuMCAgICAgMCAgICAgICAgICAgIDMgICAKMjAyNS0xMC0xNiAwMDowMDowMCAgICAgICAgICAgICAgNy4wICAgICAgICAgIDE3LjAgICAgIDEgICAgICAgICAgICAzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHByZXZfc2F0dXJkYXlfcmFuZ2VfeF92b2wgIFwKMjAyNS0xMC0xNSAyMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgICAgICAgICAgICAgICAgTmFOICAgCjIwMjUtMTAtMTUgMjE6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE1IDIyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgICAgICAgICAgICAgICAgTmFOICAgCjIwMjUtMTAtMTYgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAgICAgICAgICAgICAgIE5hTiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwMTQ4NiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgICAgICAgICAgMC4wMDE1NzEgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDAxOTIwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwMTg3MiAgIAoKICAgICAgICAgICAgICAgICAgICAgcHJldl9zdW5kYXlfcmFuZ2VfeF92b2wgIHdlZWtkYXlfdnNfc2F0dXJkYXlfcHJvZyAgXAoyMDI1LTEwLTE1IDIwOjAwOjAwICAgICAgICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgICAgLTAuMDA2OTA3ICAgCjIwMjUtMTAtMTUgMjE6MDA6MDAgICAgICAgICAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgICAtMC4wMDc3MzkgICAKMjAyNS0xMC0xNSAyMjowMDowMCAgICAgICAgICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICAgIC0wLjAwOTgzMCAgIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAgICAgICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgICAgLTAuMDA4NzU4ICAgCjIwMjUtMTAtMTYgMDA6MDA6MDAgICAgICAgICAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgICAtMC4wMDg4MTggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDAxMTQzICAgICAgICAgICAgICAgICAtMC4wMDE3ODkgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAgMC4wMDM5NzkgICAgICAgICAgICAgICAgIC0wLjAwMjIxMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAgICAwLjAwMzg3MCAgICAgICAgICAgICAgICAgLTAuMDA0OTEzICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDAzOTYzICAgICAgICAgICAgICAgICAtMC4wMDIwNjEgICAKCiAgICAgICAgICAgICAgICAgICAgIHdlZWtkYXlfdnNfc3VuZGF5X3Byb2cgIHByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyICBcCjIwMjUtMTAtMTUgMjA6MDA6MDAgICAgICAgICAgICAgICAtMC4wMjE2OTQgICAgICAgICAgICAgICAgICAgLTAuMDA0MDU4ICAgCjIwMjUtMTAtMTUgMjE6MDA6MDAgICAgICAgICAgICAgICAtMC4wMjM4MjMgICAgICAgICAgICAgICAgICAgLTAuMDA0MDQzICAgCjIwMjUtMTAtMTUgMjI6MDA6MDAgICAgICAgICAgICAgICAtMC4wMzE1NDggICAgICAgICAgICAgICAgICAgLTAuMDA0MzQxICAgCjIwMjUtMTAtMTUgMjM6MDA6MDAgICAgICAgICAgICAgICAtMC4wMjU3NDIgICAgICAgICAgICAgICAgICAgLTAuMDAzNTc2ICAgCjIwMjUtMTAtMTYgMDA6MDA6MDAgICAgICAgICAgICAgICAtMC4wMjE1NjcgICAgICAgICAgICAgICAgICAgLTAuMDAzNzQ1ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDAwMDAgICAgICAgICAgICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDEyNDkgICAgICAgICAgICAgICAgICAgLTAuMDAwNzU5ICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDc2MjEgICAgICAgICAgICAgICAgICAgLTAuMDAxNjIyICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDc1MTYgICAgICAgICAgICAgICAgICAgLTAuMDAzMjA5ICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDQ3MTIgICAgICAgICAgICAgICAgICAgLTAuMDAxMTgzICAgCgogICAgICAgICAgICAgICAgICAgICBleHRyZW1lX3JhbmdlX3ZvbCAgc2tld192b2xfZXh0cmVtZSAgXAoyMDI1LTEwLTE1IDIwOjAwOjAwICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE1IDIxOjAwOjAwICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE1IDIyOjAwOjAwICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE1IDIzOjAwOjAwICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE2IDAwOjAwOjAwICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgIE5hTiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAwLjAxMjcyNSAgICAgICAgICAwLjAxMzkwMyAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwLjAwNzU5OCAgICAgICAgICAwLjAxNDU3MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwLjAxNDQyNiAgICAgICAgIC0wLjA1NDc5NyAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAwLjAxODkzMSAgICAgICAgIC0wLjEwODAzMyAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAwLjAxMjY5OCAgICAgICAgIC0wLjA5NDg1OSAgIAoKICAgICAgICAgICAgICAgICAgICAga3VydG9zaXNfdm9sX2V4dHJlbWUgIGRpc3RhbmNlX3ZvbF9leHRyZW1lICBcCjIwMjUtMTAtMTUgMjA6MDA6MDAgICAgICAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE1IDIxOjAwOjAwICAgICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgICAgICBOYU4gICAKMjAyNS0xMC0xNSAyMjowMDowMCAgICAgICAgICAgICAgICAgICBOYU4gICAgICAgICAgICAgICAgICAgTmFOICAgCjIwMjUtMTAtMTUgMjM6MDA6MDAgICAgICAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgICAgIE5hTiAgIAoyMDI1LTEwLTE2IDAwOjAwOjAwICAgICAgICAgICAgICAgICAgIE5hTiAgICAgICAgICAgICAgICAgICBOYU4gICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgLTEuMTQ5Mzk1ICAgICAgICAgICAgICAwLjAyODA2OCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgIC0xLjExNTI0MiAgICAgICAgICAgICAgMC4wMjY5NzIgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAtMS4xMzk1NDQgICAgICAgICAgICAgIDAuMDMwMTI2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgLTAuOTg1OTIzICAgICAgICAgICAgICAwLjAzMzY0MyAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgIC0wLjk0MzU5MyAgICAgICAgICAgICAgMC4wMzI5MTUgICAKCiAgICAgICAgICAgICAgICAgICAgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICAKMjAyNS0xMC0xNSAyMDowMDowMCAgICAgICAgICAgICAgICAgICAgICBOYU4gIAoyMDI1LTEwLTE1IDIxOjAwOjAwICAgICAgICAgICAgICAgICAgICAgIE5hTiAgCjIwMjUtMTAtMTUgMjI6MDA6MDAgICAgICAgICAgICAgICAgICAgICAgTmFOICAKMjAyNS0xMC0xNSAyMzowMDowMCAgICAgICAgICAgICAgICAgICAgICBOYU4gIAoyMDI1LTEwLTE2IDAwOjAwOjAwICAgICAgICAgICAgICAgICAgICAgIE5hTiAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAtMS45NzIwNDAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIC02LjMxODY5MSAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAgNy4xMzAyNzIgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAgIC01LjQwNjkwMyAgCgpbMTAwMCByb3dzIHggNDUwIGNvbHVtbnNd\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"features\\\",\\\"internalMetadata\\\":{\\\"executionId\\\":\\\"736c991f-25a5-4b07-99f9-ca850160e014\\\",\\\"runStartTime\\\":1764176745730,\\\"runEndTime\\\":1764176745744,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":6,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"59dd5080\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":34,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_8896403a-6894-4396-a058-b17b1b1499e7",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_8896403a-6894-4396-a058-b17b1b1499e7","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":3,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ef7f068c-24cb-4499-993a-effddfeec1a1\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkhlYXZ5IGNhY2hlIHJlYWR5OiBoZWF2eV9mZWF0dXJlc192MS5wa2wgKHRvdGFsIDEpIGluIGNhY2hlL2hlYXZ5X2ZlYXR1cmVzCkxvYWRlZCBoZWF2eSBjYWNoZSBwYXlsb2FkIGZyb20gZGlzazsgc2tpcHBpbmcgcmVidWlsZC4KTWFudWFsIGZlYXR1cmVzIHNoYXBlIGZyb20gY2FjaGU6ICg1Mzk2NCwgNDUwKQpNYW51YWwgZmVhdHVyZXMgc2hhcGUgZnJvbSBjYWNoZTogKDUzOTY0LCA0NTApCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"c0fd2b68-b78e-48f4-8607-a0ba73d9991e\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"error\\\",\\\"originalError\\\":{\\\"output_type\\\":\\\"error\\\",\\\"ename\\\":\\\"KeyboardInterrupt\\\",\\\"evalue\\\":\\\"\\\",\\\"traceback\\\":[\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\",\\\"\\\\u001b[31mKeyboardInterrupt\\\\u001b[39m                         Traceback (most recent call last)\\\",\\\"\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[3]\\\\u001b[39m\\\\u001b[32m, line 94\\\\u001b[39m\\\\n\\\\u001b[32m     92\\\\u001b[39m \\\\u001b[38;5;66;03m# Run Fit/Transform\\\\u001b[39;00m\\\\n\\\\u001b[32m     93\\\\u001b[39m regime_engineer.fit(df_train)\\\\n\\\\u001b[32m---> \\\\u001b[39m\\\\u001b[32m94\\\\u001b[39m targets = \\\\u001b[43mregime_engineer\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mtransform\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mdf_train\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m     96\\\\u001b[39m \\\\u001b[38;5;66;03m# Check the distribution\\\\u001b[39;00m\\\\n\\\\u001b[32m     97\\\\u001b[39m dist = regime_engineer.get_regime_distribution(df_train)\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/sklearn/utils/_set_output.py:316\\\\u001b[39m, in \\\\u001b[36m_wrap_method_output.<locals>.wrapped\\\\u001b[39m\\\\u001b[34m(self, X, *args, **kwargs)\\\\u001b[39m\\\\n\\\\u001b[32m    314\\\\u001b[39m \\\\u001b[38;5;129m@wraps\\\\u001b[39m(f)\\\\n\\\\u001b[32m    315\\\\u001b[39m \\\\u001b[38;5;28;01mdef\\\\u001b[39;00m\\\\u001b[38;5;250m \\\\u001b[39m\\\\u001b[34mwrapped\\\\u001b[39m(\\\\u001b[38;5;28mself\\\\u001b[39m, X, *args, **kwargs):\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m316\\\\u001b[39m     data_to_wrap = \\\\u001b[43mf\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mX\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43m*\\\\u001b[49m\\\\u001b[43margs\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43m*\\\\u001b[49m\\\\u001b[43m*\\\\u001b[49m\\\\u001b[43mkwargs\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m    317\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(data_to_wrap, \\\\u001b[38;5;28mtuple\\\\u001b[39m):\\\\n\\\\u001b[32m    318\\\\u001b[39m         \\\\u001b[38;5;66;03m# only wrap the first output for cross decomposition\\\\u001b[39;00m\\\\n\\\\u001b[32m    319\\\\u001b[39m         return_tuple = (\\\\n\\\\u001b[32m    320\\\\u001b[39m             _wrap_data_with_container(method, data_to_wrap[\\\\u001b[32m0\\\\u001b[39m], X, \\\\u001b[38;5;28mself\\\\u001b[39m),\\\\n\\\\u001b[32m    321\\\\u001b[39m             *data_to_wrap[\\\\u001b[32m1\\\\u001b[39m:],\\\\n\\\\u001b[32m    322\\\\u001b[39m         )\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m/shared/eastSync/pyEast/pro_version/targetEngineer.py:343\\\\u001b[39m, in \\\\u001b[36mVolatilityRegimeEngineer.transform\\\\u001b[39m\\\\u001b[34m(self, X)\\\\u001b[39m\\\\n\\\\u001b[32m    341\\\\u001b[39m check_is_fitted(\\\\u001b[38;5;28mself\\\\u001b[39m, \\\\u001b[33m'\\\\u001b[39m\\\\u001b[33m_seasonal_vol_lookup\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m)\\\\n\\\\u001b[32m    342\\\\u001b[39m box_df = \\\\u001b[38;5;28mself\\\\u001b[39m._calculate_lookback_box(X)\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m343\\\\u001b[39m results = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_assign_regime_labels\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mX\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mbox_df\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m    345\\\\u001b[39m output = results.copy()\\\\n\\\\u001b[32m    346\\\\u001b[39m output[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mbox_std_deseasonalized\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] = box_df[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mbox_std\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m]\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m/shared/eastSync/pyEast/pro_version/targetEngineer.py:301\\\\u001b[39m, in \\\\u001b[36mVolatilityRegimeEngineer._assign_regime_labels\\\\u001b[39m\\\\u001b[34m(self, X, box_df)\\\\u001b[39m\\\\n\\\\u001b[32m    299\\\\u001b[39m sub_indices = fwd_indices[i : i + \\\\u001b[38;5;28mself\\\\u001b[39m.jump_speed_window]\\\\n\\\\u001b[32m    300\\\\u001b[39m s_high = high.loc[sub_indices].max()\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m301\\\\u001b[39m s_low = \\\\u001b[43mlow\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mloc\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[43msub_indices\\\\u001b[49m\\\\u001b[43m]\\\\u001b[49m.min()\\\\n\\\\u001b[32m    302\\\\u001b[39m s_ret = \\\\u001b[38;5;28mmax\\\\u001b[39m(\\\\u001b[38;5;28mabs\\\\u001b[39m(np.log(s_high/ref_price)), \\\\u001b[38;5;28mabs\\\\u001b[39m(np.log(s_low/ref_price)))\\\\n\\\\u001b[32m    303\\\\u001b[39m current_z = s_ret / (box_std * sqrt_jump)\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1192\\\\u001b[39m, in \\\\u001b[36m_LocationIndexer.__getitem__\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m   1190\\\\u001b[39m maybe_callable = com.apply_if_callable(key, \\\\u001b[38;5;28mself\\\\u001b[39m.obj)\\\\n\\\\u001b[32m   1191\\\\u001b[39m maybe_callable = \\\\u001b[38;5;28mself\\\\u001b[39m._check_deprecated_callable_usage(key, maybe_callable)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1192\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_axis\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mmaybe_callable\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1421\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_axis\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1418\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mhasattr\\\\u001b[39m(key, \\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mndim\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m) \\\\u001b[38;5;129;01mand\\\\u001b[39;00m key.ndim > \\\\u001b[32m1\\\\u001b[39m:\\\\n\\\\u001b[32m   1419\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mValueError\\\\u001b[39;00m(\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mCannot index with multidimensional key\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1421\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_iterable\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1423\\\\u001b[39m \\\\u001b[38;5;66;03m# nested tuple slicing\\\\u001b[39;00m\\\\n\\\\u001b[32m   1424\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m is_nested_tuple(key, labels):\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1361\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_iterable\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1358\\\\u001b[39m \\\\u001b[38;5;28mself\\\\u001b[39m._validate_key(key, axis)\\\\n\\\\u001b[32m   1360\\\\u001b[39m \\\\u001b[38;5;66;03m# A collection of keys\\\\u001b[39;00m\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1361\\\\u001b[39m keyarr, indexer = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_listlike_indexer\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1362\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m.obj._reindex_with_indexers(\\\\n\\\\u001b[32m   1363\\\\u001b[39m     {axis: [keyarr, indexer]}, copy=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m, allow_dups=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m\\\\n\\\\u001b[32m   1364\\\\u001b[39m )\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1559\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._get_listlike_indexer\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1556\\\\u001b[39m ax = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis(axis)\\\\n\\\\u001b[32m   1557\\\\u001b[39m axis_name = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis_name(axis)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1559\\\\u001b[39m keyarr, indexer = \\\\u001b[43max\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_indexer_strict\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1561\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m keyarr, indexer\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6214\\\\u001b[39m, in \\\\u001b[36mIndex._get_indexer_strict\\\\u001b[39m\\\\u001b[34m(self, key, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6210\\\\u001b[39m     keyarr, indexer, new_indexer = \\\\u001b[38;5;28mself\\\\u001b[39m._reindex_non_unique(keyarr)\\\\n\\\\u001b[32m   6212\\\\u001b[39m \\\\u001b[38;5;28mself\\\\u001b[39m._raise_if_missing(keyarr, indexer, axis_name)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6214\\\\u001b[39m keyarr = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mtake\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   6215\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, Index):\\\\n\\\\u001b[32m   6216\\\\u001b[39m     \\\\u001b[38;5;66;03m# GH 42790 - Preserve name from an Index\\\\u001b[39;00m\\\\n\\\\u001b[32m   6217\\\\u001b[39m     keyarr.name = key.name\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/datetimelike.py:841\\\\u001b[39m, in \\\\u001b[36mDatetimeTimedeltaMixin.take\\\\u001b[39m\\\\u001b[34m(self, indices, axis, allow_fill, fill_value, **kwargs)\\\\u001b[39m\\\\n\\\\u001b[32m    839\\\\u001b[39m maybe_slice = lib.maybe_indices_to_slice(indices, \\\\u001b[38;5;28mlen\\\\u001b[39m(\\\\u001b[38;5;28mself\\\\u001b[39m))\\\\n\\\\u001b[32m    840\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(maybe_slice, \\\\u001b[38;5;28mslice\\\\u001b[39m):\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m841\\\\u001b[39m     freq = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_data\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_getitem_freq\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mmaybe_slice\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m    842\\\\u001b[39m     result._data._freq = freq\\\\n\\\\u001b[32m    843\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m result\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/arrays/datetimelike.py:417\\\\u001b[39m, in \\\\u001b[36mDatetimeLikeArrayMixin._get_getitem_freq\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m    415\\\\u001b[39m     freq = \\\\u001b[38;5;28;01mNone\\\\u001b[39;00m\\\\n\\\\u001b[32m    416\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m417\\\\u001b[39m     key = \\\\u001b[43mcheck_array_indexer\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m  \\\\u001b[38;5;66;03m# maybe ndarray[bool] -> slice\\\\u001b[39;00m\\\\n\\\\u001b[32m    418\\\\u001b[39m     freq = \\\\u001b[38;5;28;01mNone\\\\u001b[39;00m\\\\n\\\\u001b[32m    419\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, \\\\u001b[38;5;28mslice\\\\u001b[39m):\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexers/utils.py:517\\\\u001b[39m, in \\\\u001b[36mcheck_array_indexer\\\\u001b[39m\\\\u001b[34m(array, indexer)\\\\u001b[39m\\\\n\\\\u001b[32m    511\\\\u001b[39m \\\\u001b[38;5;28;01mfrom\\\\u001b[39;00m\\\\u001b[38;5;250m \\\\u001b[39m\\\\u001b[34;01mpandas\\\\u001b[39;00m\\\\u001b[34;01m.\\\\u001b[39;00m\\\\u001b[34;01mcore\\\\u001b[39;00m\\\\u001b[34;01m.\\\\u001b[39;00m\\\\u001b[34;01mconstruction\\\\u001b[39;00m\\\\u001b[38;5;250m \\\\u001b[39m\\\\u001b[38;5;28;01mimport\\\\u001b[39;00m array \\\\u001b[38;5;28;01mas\\\\u001b[39;00m pd_array\\\\n\\\\u001b[32m    513\\\\u001b[39m \\\\u001b[38;5;66;03m# whatever is not an array-like is returned as-is (possible valid array\\\\u001b[39;00m\\\\n\\\\u001b[32m    514\\\\u001b[39m \\\\u001b[38;5;66;03m# indexers that are not array-like: integer, slice, Ellipsis, None)\\\\u001b[39;00m\\\\n\\\\u001b[32m    515\\\\u001b[39m \\\\u001b[38;5;66;03m# In this context, tuples are not considered as array-like, as they have\\\\u001b[39;00m\\\\n\\\\u001b[32m    516\\\\u001b[39m \\\\u001b[38;5;66;03m# a specific meaning in indexing (multi-dimensional indexing)\\\\u001b[39;00m\\\\n\\\\u001b[32m--> \\\\u001b[39m\\\\u001b[32m517\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[43mis_list_like\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m:\\\\n\\\\u001b[32m    518\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(indexer, \\\\u001b[38;5;28mtuple\\\\u001b[39m):\\\\n\\\\u001b[32m    519\\\\u001b[39m         \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m indexer\\\\n\\\",\\\"\\\\u001b[31mKeyboardInterrupt\\\\u001b[39m: \\\"]}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ewoJIm5hbWUiOiAiS2V5Ym9hcmRJbnRlcnJ1cHQiLAoJIm1lc3NhZ2UiOiAiIiwKCSJzdGFjayI6ICJcdTAwMWJbMzFtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHUwMDFiWzM5bVxuXHUwMDFiWzMxbUtleWJvYXJkSW50ZXJydXB0XHUwMDFiWzM5bSAgICAgICAgICAgICAgICAgICAgICAgICBUcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdClcblx1MDAxYlszNm1DZWxsXHUwMDFiWzM5bVx1MDAxYlszNm0gXHUwMDFiWzM5bVx1MDAxYlszMm1JblszXVx1MDAxYlszOW1cdTAwMWJbMzJtLCBsaW5lIDk0XHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgICAgOTJcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgUnVuIEZpdC9UcmFuc2Zvcm1cdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgICA5M1x1MDAxYlszOW0gcmVnaW1lX2VuZ2luZWVyLmZpdChkZl90cmFpbilcblx1MDAxYlszMm0tLS0+IFx1MDAxYlszOW1cdTAwMWJbMzJtOTRcdTAwMWJbMzltIHRhcmdldHMgPSBcdTAwMWJbNDNtcmVnaW1lX2VuZ2luZWVyXHUwMDFiWzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M210cmFuc2Zvcm1cdTAwMWJbNDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbWRmX3RyYWluXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgICAgOTZcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgQ2hlY2sgdGhlIGRpc3RyaWJ1dGlvblx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAgIDk3XHUwMDFiWzM5bSBkaXN0ID0gcmVnaW1lX2VuZ2luZWVyLmdldF9yZWdpbWVfZGlzdHJpYnV0aW9uKGRmX3RyYWluKVxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybX4vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi8udmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL3NrbGVhcm4vdXRpbHMvX3NldF9vdXRwdXQucHk6MzE2XHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bV93cmFwX21ldGhvZF9vdXRwdXQuPGxvY2Fscz4ud3JhcHBlZFx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIFgsICphcmdzLCAqKmt3YXJncylcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgIDMxNFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7MTI5bUB3cmFwc1x1MDAxYlszOW0oZilcblx1MDAxYlszMm0gICAgMzE1XHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1kZWZcdTAwMWJbMzk7MDBtXHUwMDFiWzM4OzU7MjUwbSBcdTAwMWJbMzltXHUwMDFiWzM0bXdyYXBwZWRcdTAwMWJbMzltKFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLCBYLCAqYXJncywgKiprd2FyZ3MpOlxuXHUwMDFiWzMybS0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTMxNlx1MDAxYlszOW0gICAgIGRhdGFfdG9fd3JhcCA9IFx1MDAxYls0M21mXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbVhcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbSpcdTAwMWJbNDltXHUwMDFiWzQzbWFyZ3NcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbSpcdTAwMWJbNDltXHUwMDFiWzQzbSpcdTAwMWJbNDltXHUwMDFiWzQzbWt3YXJnc1x1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblx1MDAxYlszMm0gICAgMzE3XHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bWlzaW5zdGFuY2VcdTAwMWJbMzltKGRhdGFfdG9fd3JhcCwgXHUwMDFiWzM4OzU7MjhtdHVwbGVcdTAwMWJbMzltKTpcblx1MDAxYlszMm0gICAgMzE4XHUwMDFiWzM5bSAgICAgICAgIFx1MDAxYlszODs1OzY2OzAzbSMgb25seSB3cmFwIHRoZSBmaXJzdCBvdXRwdXQgZm9yIGNyb3NzIGRlY29tcG9zaXRpb25cdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgIDMxOVx1MDAxYlszOW0gICAgICAgICByZXR1cm5fdHVwbGUgPSAoXG5cdTAwMWJbMzJtICAgIDMyMFx1MDAxYlszOW0gICAgICAgICAgICAgX3dyYXBfZGF0YV93aXRoX2NvbnRhaW5lcihtZXRob2QsIGRhdGFfdG9fd3JhcFtcdTAwMWJbMzJtMFx1MDAxYlszOW1dLCBYLCBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bSksXG5cdTAwMWJbMzJtICAgIDMyMVx1MDAxYlszOW0gICAgICAgICAgICAgKmRhdGFfdG9fd3JhcFtcdTAwMWJbMzJtMVx1MDAxYlszOW06XSxcblx1MDAxYlszMm0gICAgMzIyXHUwMDFiWzM5bSAgICAgICAgIClcblxuXHUwMDFiWzM2bUZpbGUgXHUwMDFiWzM5bVx1MDAxYlszMm0vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi90YXJnZXRFbmdpbmVlci5weTozNDNcdTAwMWJbMzltLCBpbiBcdTAwMWJbMzZtVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyLnRyYW5zZm9ybVx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIFgpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgICAzNDFcdTAwMWJbMzltIGNoZWNrX2lzX2ZpdHRlZChcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bSwgXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbV9zZWFzb25hbF92b2xfbG9va3VwXHUwMDFiWzM5bVx1MDAxYlszM20nXHUwMDFiWzM5bSlcblx1MDAxYlszMm0gICAgMzQyXHUwMDFiWzM5bSBib3hfZGYgPSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5fY2FsY3VsYXRlX2xvb2tiYWNrX2JveChYKVxuXHUwMDFiWzMybS0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTM0M1x1MDAxYlszOW0gcmVzdWx0cyA9IFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9hc3NpZ25fcmVnaW1lX2xhYmVsc1x1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNtWFx1MDAxYls0OW1cdTAwMWJbNDNtLFx1MDAxYls0OW1cdTAwMWJbNDNtIFx1MDAxYls0OW1cdTAwMWJbNDNtYm94X2RmXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgICAzNDVcdTAwMWJbMzltIG91dHB1dCA9IHJlc3VsdHMuY29weSgpXG5cdTAwMWJbMzJtICAgIDM0Nlx1MDAxYlszOW0gb3V0cHV0W1x1MDAxYlszM20nXHUwMDFiWzM5bVx1MDAxYlszM21ib3hfc3RkX2Rlc2Vhc29uYWxpemVkXHUwMDFiWzM5bVx1MDAxYlszM20nXHUwMDFiWzM5bV0gPSBib3hfZGZbXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbWJveF9zdGRcdTAwMWJbMzltXHUwMDFiWzMzbSdcdTAwMWJbMzltXVxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybS9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL3RhcmdldEVuZ2luZWVyLnB5OjMwMVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1Wb2xhdGlsaXR5UmVnaW1lRW5naW5lZXIuX2Fzc2lnbl9yZWdpbWVfbGFiZWxzXHUwMDFiWzM5bVx1MDAxYlszNG0oc2VsZiwgWCwgYm94X2RmKVx1MDAxYlszOW1cblx1MDAxYlszMm0gICAgMjk5XHUwMDFiWzM5bSBzdWJfaW5kaWNlcyA9IGZ3ZF9pbmRpY2VzW2kgOiBpICsgXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0uanVtcF9zcGVlZF93aW5kb3ddXG5cdTAwMWJbMzJtICAgIDMwMFx1MDAxYlszOW0gc19oaWdoID0gaGlnaC5sb2Nbc3ViX2luZGljZXNdLm1heCgpXG5cdTAwMWJbMzJtLS0+IFx1MDAxYlszOW1cdTAwMWJbMzJtMzAxXHUwMDFiWzM5bSBzX2xvdyA9IFx1MDAxYls0M21sb3dcdTAwMWJbNDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbWxvY1x1MDAxYls0OW1cdTAwMWJbNDNtW1x1MDAxYls0OW1cdTAwMWJbNDNtc3ViX2luZGljZXNcdTAwMWJbNDltXHUwMDFiWzQzbV1cdTAwMWJbNDltLm1pbigpXG5cdTAwMWJbMzJtICAgIDMwMlx1MDAxYlszOW0gc19yZXQgPSBcdTAwMWJbMzg7NTsyOG1tYXhcdTAwMWJbMzltKFx1MDAxYlszODs1OzI4bWFic1x1MDAxYlszOW0obnAubG9nKHNfaGlnaC9yZWZfcHJpY2UpKSwgXHUwMDFiWzM4OzU7MjhtYWJzXHUwMDFiWzM5bShucC5sb2coc19sb3cvcmVmX3ByaWNlKSkpXG5cdTAwMWJbMzJtICAgIDMwM1x1MDAxYlszOW0gY3VycmVudF96ID0gc19yZXQgLyAoYm94X3N0ZCAqIHNxcnRfanVtcClcblxuXHUwMDFiWzM2bUZpbGUgXHUwMDFiWzM5bVx1MDAxYlszMm1+L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vLnZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9wYW5kYXMvY29yZS9pbmRleGluZy5weToxMTkyXHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bV9Mb2NhdGlvbkluZGV4ZXIuX19nZXRpdGVtX19cdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXkpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDExOTBcdTAwMWJbMzltIG1heWJlX2NhbGxhYmxlID0gY29tLmFwcGx5X2lmX2NhbGxhYmxlKGtleSwgXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0ub2JqKVxuXHUwMDFiWzMybSAgIDExOTFcdTAwMWJbMzltIG1heWJlX2NhbGxhYmxlID0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0uX2NoZWNrX2RlcHJlY2F0ZWRfY2FsbGFibGVfdXNhZ2Uoa2V5LCBtYXliZV9jYWxsYWJsZSlcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTExOTJcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7Mjg7NDNtc2VsZlx1MDAxYlszOTs0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtX2dldGl0ZW1fYXhpc1x1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNtbWF5YmVfY2FsbGFibGVcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNcdTAwMWJbNDltXHUwMDFiWzQzbT1cdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNcdTAwMWJbNDltXHUwMDFiWzQzbSlcdTAwMWJbNDltXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTQyMVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0aXRlbV9heGlzXHUwMDFiWzM5bVx1MDAxYlszNG0oc2VsZiwga2V5LCBheGlzKVx1MDAxYlszOW1cblx1MDAxYlszMm0gICAxNDE4XHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bWhhc2F0dHJcdTAwMWJbMzltKGtleSwgXHUwMDFiWzMzbVwiXHUwMDFiWzM5bVx1MDAxYlszM21uZGltXHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW0pIFx1MDAxYlszODs1OzEyOTswMW1hbmRcdTAwMWJbMzk7MDBtIGtleS5uZGltID4gXHUwMDFiWzMybTFcdTAwMWJbMzltOlxuXHUwMDFiWzMybSAgIDE0MTlcdTAwMWJbMzltICAgICAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtcmFpc2VcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzE2NzswMW1WYWx1ZUVycm9yXHUwMDFiWzM5OzAwbShcdTAwMWJbMzNtXCJcdTAwMWJbMzltXHUwMDFiWzMzbUNhbm5vdCBpbmRleCB3aXRoIG11bHRpZGltZW5zaW9uYWwga2V5XHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW0pXG5cdTAwMWJbMzJtLT4gXHUwMDFiWzM5bVx1MDAxYlszMm0xNDIxXHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtcmV0dXJuXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyODs0M21zZWxmXHUwMDFiWzM5OzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21fZ2V0aXRlbV9pdGVyYWJsZVx1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNta2V5XHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M209XHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgIDE0MjNcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgbmVzdGVkIHR1cGxlIHNsaWNpbmdcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgMTQyNFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIGlzX25lc3RlZF90dXBsZShrZXksIGxhYmVscyk6XG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTM2MVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0aXRlbV9pdGVyYWJsZVx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIGtleSwgYXhpcylcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgMTM1OFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0uX3ZhbGlkYXRlX2tleShrZXksIGF4aXMpXG5cdTAwMWJbMzJtICAgMTM2MFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7NjY7MDNtIyBBIGNvbGxlY3Rpb24gb2Yga2V5c1x1MDAxYlszOTswMG1cblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTEzNjFcdTAwMWJbMzltIGtleWFyciwgaW5kZXhlciA9IFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9nZXRfbGlzdGxpa2VfaW5kZXhlclx1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNta2V5XHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgIDEzNjJcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0ub2JqLl9yZWluZGV4X3dpdGhfaW5kZXhlcnMoXG5cdTAwMWJbMzJtICAgMTM2M1x1MDAxYlszOW0gICAgIHtheGlzOiBba2V5YXJyLCBpbmRleGVyXX0sIGNvcHk9XHUwMDFiWzM4OzU7Mjg7MDFtVHJ1ZVx1MDAxYlszOTswMG0sIGFsbG93X2R1cHM9XHUwMDFiWzM4OzU7Mjg7MDFtVHJ1ZVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAxMzY0XHUwMDFiWzM5bSApXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTU1OVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0X2xpc3RsaWtlX2luZGV4ZXJcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXksIGF4aXMpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDE1NTZcdTAwMWJbMzltIGF4ID0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0ub2JqLl9nZXRfYXhpcyhheGlzKVxuXHUwMDFiWzMybSAgIDE1NTdcdTAwMWJbMzltIGF4aXNfbmFtZSA9IFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLm9iai5fZ2V0X2F4aXNfbmFtZShheGlzKVxuXHUwMDFiWzMybS0+IFx1MDAxYlszOW1cdTAwMWJbMzJtMTU1OVx1MDAxYlszOW0ga2V5YXJyLCBpbmRleGVyID0gXHUwMDFiWzQzbWF4XHUwMDFiWzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21fZ2V0X2luZGV4ZXJfc3RyaWN0XHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21rZXlcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNfbmFtZVx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblx1MDAxYlszMm0gICAxNTYxXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1yZXR1cm5cdTAwMWJbMzk7MDBtIGtleWFyciwgaW5kZXhlclxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybX4vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi8udmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL3BhbmRhcy9jb3JlL2luZGV4ZXMvYmFzZS5weTo2MjE0XHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bUluZGV4Ll9nZXRfaW5kZXhlcl9zdHJpY3RcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXksIGF4aXNfbmFtZSlcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgNjIxMFx1MDAxYlszOW0gICAgIGtleWFyciwgaW5kZXhlciwgbmV3X2luZGV4ZXIgPSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5fcmVpbmRleF9ub25fdW5pcXVlKGtleWFycilcblx1MDAxYlszMm0gICA2MjEyXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5fcmFpc2VfaWZfbWlzc2luZyhrZXlhcnIsIGluZGV4ZXIsIGF4aXNfbmFtZSlcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTYyMTRcdTAwMWJbMzltIGtleWFyciA9IFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbXRha2VcdTAwMWJbNDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbWluZGV4ZXJcdTAwMWJbNDltXHUwMDFiWzQzbSlcdTAwMWJbNDltXG5cdTAwMWJbMzJtICAgNjIxNVx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bWlzaW5zdGFuY2VcdTAwMWJbMzltKGtleSwgSW5kZXgpOlxuXHUwMDFiWzMybSAgIDYyMTZcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTs2NjswM20jIEdIIDQyNzkwIC0gUHJlc2VydmUgbmFtZSBmcm9tIGFuIEluZGV4XHUwMDFiWzM5OzAwbVxuXHUwMDFiWzMybSAgIDYyMTdcdTAwMWJbMzltICAgICBrZXlhcnIubmFtZSA9IGtleS5uYW1lXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhlcy9kYXRldGltZWxpa2UucHk6ODQxXHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bURhdGV0aW1lVGltZWRlbHRhTWl4aW4udGFrZVx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIGluZGljZXMsIGF4aXMsIGFsbG93X2ZpbGwsIGZpbGxfdmFsdWUsICoqa3dhcmdzKVx1MDAxYlszOW1cblx1MDAxYlszMm0gICAgODM5XHUwMDFiWzM5bSBtYXliZV9zbGljZSA9IGxpYi5tYXliZV9pbmRpY2VzX3RvX3NsaWNlKGluZGljZXMsIFx1MDAxYlszODs1OzI4bWxlblx1MDAxYlszOW0oXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0pKVxuXHUwMDFiWzMybSAgICA4NDBcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyOG1pc2luc3RhbmNlXHUwMDFiWzM5bShtYXliZV9zbGljZSwgXHUwMDFiWzM4OzU7Mjhtc2xpY2VcdTAwMWJbMzltKTpcblx1MDAxYlszMm0tLT4gXHUwMDFiWzM5bVx1MDAxYlszMm04NDFcdTAwMWJbMzltICAgICBmcmVxID0gXHUwMDFiWzM4OzU7Mjg7NDNtc2VsZlx1MDAxYlszOTs0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtX2RhdGFcdTAwMWJbNDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9nZXRfZ2V0aXRlbV9mcmVxXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21tYXliZV9zbGljZVx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblx1MDAxYlszMm0gICAgODQyXHUwMDFiWzM5bSAgICAgcmVzdWx0Ll9kYXRhLl9mcmVxID0gZnJlcVxuXHUwMDFiWzMybSAgICA4NDNcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gcmVzdWx0XG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvYXJyYXlzL2RhdGV0aW1lbGlrZS5weTo0MTdcdTAwMWJbMzltLCBpbiBcdTAwMWJbMzZtRGF0ZXRpbWVMaWtlQXJyYXlNaXhpbi5fZ2V0X2dldGl0ZW1fZnJlcVx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIGtleSlcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgIDQxNVx1MDAxYlszOW0gICAgIGZyZXEgPSBcdTAwMWJbMzg7NTsyODswMW1Ob25lXHUwMDFiWzM5OzAwbVxuXHUwMDFiWzMybSAgICA0MTZcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWVsc2VcdTAwMWJbMzk7MDBtOlxuXHUwMDFiWzMybS0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTQxN1x1MDAxYlszOW0gICAgIGtleSA9IFx1MDAxYls0M21jaGVja19hcnJheV9pbmRleGVyXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWtleVx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW0gIFx1MDAxYlszODs1OzY2OzAzbSMgbWF5YmUgbmRhcnJheVtib29sXSAtPiBzbGljZVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAgNDE4XHUwMDFiWzM5bSAgICAgZnJlcSA9IFx1MDAxYlszODs1OzI4OzAxbU5vbmVcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgIDQxOVx1MDAxYlszOW0gICAgIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyOG1pc2luc3RhbmNlXHUwMDFiWzM5bShrZXksIFx1MDAxYlszODs1OzI4bXNsaWNlXHUwMDFiWzM5bSk6XG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhlcnMvdXRpbHMucHk6NTE3XHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bWNoZWNrX2FycmF5X2luZGV4ZXJcdTAwMWJbMzltXHUwMDFiWzM0bShhcnJheSwgaW5kZXhlcilcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgIDUxMVx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtZnJvbVx1MDAxYlszOTswMG1cdTAwMWJbMzg7NTsyNTBtIFx1MDAxYlszOW1cdTAwMWJbMzQ7MDFtcGFuZGFzXHUwMDFiWzM5OzAwbVx1MDAxYlszNDswMW0uXHUwMDFiWzM5OzAwbVx1MDAxYlszNDswMW1jb3JlXHUwMDFiWzM5OzAwbVx1MDAxYlszNDswMW0uXHUwMDFiWzM5OzAwbVx1MDAxYlszNDswMW1jb25zdHJ1Y3Rpb25cdTAwMWJbMzk7MDBtXHUwMDFiWzM4OzU7MjUwbSBcdTAwMWJbMzltXHUwMDFiWzM4OzU7Mjg7MDFtaW1wb3J0XHUwMDFiWzM5OzAwbSBhcnJheSBcdTAwMWJbMzg7NTsyODswMW1hc1x1MDAxYlszOTswMG0gcGRfYXJyYXlcblx1MDAxYlszMm0gICAgNTEzXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTs2NjswM20jIHdoYXRldmVyIGlzIG5vdCBhbiBhcnJheS1saWtlIGlzIHJldHVybmVkIGFzLWlzIChwb3NzaWJsZSB2YWxpZCBhcnJheVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAgNTE0XHUwMDFiWzM5bSBcdTAwMWJbMzg7NTs2NjswM20jIGluZGV4ZXJzIHRoYXQgYXJlIG5vdCBhcnJheS1saWtlOiBpbnRlZ2VyLCBzbGljZSwgRWxsaXBzaXMsIE5vbmUpXHUwMDFiWzM5OzAwbVxuXHUwMDFiWzMybSAgICA1MTVcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgSW4gdGhpcyBjb250ZXh0LCB0dXBsZXMgYXJlIG5vdCBjb25zaWRlcmVkIGFzIGFycmF5LWxpa2UsIGFzIHRoZXkgaGF2ZVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAgNTE2XHUwMDFiWzM5bSBcdTAwMWJbMzg7NTs2NjswM20jIGEgc3BlY2lmaWMgbWVhbmluZyBpbiBpbmRleGluZyAobXVsdGktZGltZW5zaW9uYWwgaW5kZXhpbmcpXHUwMDFiWzM5OzAwbVxuXHUwMDFiWzMybS0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTUxN1x1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYls0M21pc19saXN0X2xpa2VcdTAwMWJbNDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbWluZGV4ZXJcdTAwMWJbNDltXHUwMDFiWzQzbSlcdTAwMWJbNDltOlxuXHUwMDFiWzMybSAgICA1MThcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1pZlx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7MjhtaXNpbnN0YW5jZVx1MDAxYlszOW0oaW5kZXhlciwgXHUwMDFiWzM4OzU7MjhtdHVwbGVcdTAwMWJbMzltKTpcblx1MDAxYlszMm0gICAgNTE5XHUwMDFiWzM5bSAgICAgICAgIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gaW5kZXhlclxuXG5cdTAwMWJbMzFtS2V5Ym9hcmRJbnRlcnJ1cHRcdTAwMWJbMzltOiAiCn0=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.error\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nhistory_slice = raw_history[:]\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feture Engineering\\\\nfe = FeatureEngineer(verbose=feature_params.get(\\\\\\\"verbose\\\\\\\", False), **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## cache\\\\ncache_ready = True  # Force rebuild for testing\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"Loaded heavy cache payload from disk; skipping rebuild.\\\\\\\")\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"Manual features shape from cache: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"Heavy cache not available or failed to load; running full fit.\\\\\\\")\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=verbose_flag, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## Add targets standard expiration targets\\\\n# target_engineer = ExpirationTargetEngineer(**CONFIG[\\\\\\\"targets\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\n# target_engineer.fit(features)\\\\n# targets = target_engineer.transform(features)\\\\n\\\\n## 2a. Volatility Regime Target Engineering Test ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\ndf_train = features.copy()\\\\n\\\\n# Instantiate with your parameters\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas (scaled internally for 6h window)\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n\\\\n    # Hardening Parameters\\\\n    trend_min_efficiency=0.15, # Allows looser/messier trends\\\\n    trend_min_r2=0.6           # Requires moderate linear fit\\\\n)\\\\n\\\\n# Run Fit/Transform\\\\nregime_engineer.fit(df_train)\\\\ntargets = regime_engineer.transform(df_train)\\\\n\\\\n# Check the distribution\\\\ndist = regime_engineer.get_regime_distribution(df_train)\\\\nprint(dist)\\\\n\\\\n\\\\ninitial_feature_names = list(features.columns)\\\\n\\\\n# Generate targets (your existing logic)\\\\nprint(initial_feature_names)\\\\n\\\\n\\\\n## deop price columns from features\\\\n# drop_cols = [col for col in ['o', 'h', 'l', 'c', 'volCcy'] if col in features.columns]\\\\n# if drop_cols: features = features.drop(columns=drop_cols)\\\\n\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":3,\\\"executionId\\\":\\\"7e9fbc2e-6262-42d9-999a-ed3f77899505\\\",\\\"runStartTime\\\":1764178546918,\\\"runEndTime\\\":1764178830444,\\\"lastRunSuccess\\\":false,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":1,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"49251b87-6527-4753-80ce-d9f7c4cb442d\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"error\\\",\\\"originalError\\\":{\\\"output_type\\\":\\\"error\\\",\\\"ename\\\":\\\"NameError\\\",\\\"evalue\\\":\\\"name 'features' is not defined\\\",\\\"traceback\\\":[\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\",\\\"\\\\u001b[31mNameError\\\\u001b[39m                                 Traceback (most recent call last)\\\",\\\"\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[1]\\\\u001b[39m\\\\u001b[32m, line 2\\\\u001b[39m\\\\n\\\\u001b[32m      1\\\\u001b[39m \\\\u001b[38;5;66;03m# Find rows with any NaN values in features\\\\u001b[39;00m\\\\n\\\\u001b[32m----> \\\\u001b[39m\\\\u001b[32m2\\\\u001b[39m nan_mask = \\\\u001b[43mfeatures\\\\u001b[49m.isna().any(axis=\\\\u001b[32m1\\\\u001b[39m)\\\\n\\\\u001b[32m      3\\\\u001b[39m features_with_nans = features[nan_mask]\\\\n\\\",\\\"\\\\u001b[31mNameError\\\\u001b[39m: name 'features' is not defined\\\"]}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ewoJIm5hbWUiOiAiTmFtZUVycm9yIiwKCSJtZXNzYWdlIjogIm5hbWUgJ2ZlYXR1cmVzJyBpcyBub3QgZGVmaW5lZCIsCgkic3RhY2siOiAiXHUwMDFiWzMxbS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx1MDAxYlszOW1cblx1MDAxYlszMW1OYW1lRXJyb3JcdTAwMWJbMzltICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpXG5cdTAwMWJbMzZtQ2VsbFx1MDAxYlszOW1cdTAwMWJbMzZtIFx1MDAxYlszOW1cdTAwMWJbMzJtSW5bMV1cdTAwMWJbMzltXHUwMDFiWzMybSwgbGluZSAyXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgICAgIDFcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgRmluZCByb3dzIHdpdGggYW55IE5hTiB2YWx1ZXMgaW4gZmVhdHVyZXNcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtLS0tLT4gXHUwMDFiWzM5bVx1MDAxYlszMm0yXHUwMDFiWzM5bSBuYW5fbWFzayA9IFx1MDAxYls0M21mZWF0dXJlc1x1MDAxYls0OW0uaXNuYSgpLmFueShheGlzPVx1MDAxYlszMm0xXHUwMDFiWzM5bSlcblx1MDAxYlszMm0gICAgICAzXHUwMDFiWzM5bSBmZWF0dXJlc193aXRoX25hbnMgPSBmZWF0dXJlc1tuYW5fbWFza11cblxuXHUwMDFiWzMxbU5hbWVFcnJvclx1MDAxYlszOW06IG5hbWUgJ2ZlYXR1cmVzJyBpcyBub3QgZGVmaW5lZCIKfQ==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.error\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n# Find rows with any NaN values in features\\\\nnan_mask = features.isna().any(axis=1)\\\\nfeatures_with_nans = features[nan_mask]\\\\n\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"4b5a9213-29e4-4548-90bd-298b8efc8811\\\",\\\"runStartTime\\\":1764178353998,\\\"runEndTime\\\":1764178354110,\\\"lastRunSuccess\\\":false,\\\"executionOrder\\\":1,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1},\\\"error\\\":{\\\"name\\\":\\\"NameError\\\",\\\"message\\\":\\\"name 'features' is not defined\\\",\\\"stack\\\":\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\\n\\\\u001b[31mNameError\\\\u001b[39m                                 Traceback (most recent call last)\\\\n\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[1]\\\\u001b[39m\\\\u001b[32m, line 2\\\\u001b[39m\\\\n\\\\u001b[32m      1\\\\u001b[39m \\\\u001b[38;5;66;03m# Find rows with any NaN values in features\\\\u001b[39;00m\\\\n\\\\u001b[32m----> \\\\u001b[39m\\\\u001b[32m2\\\\u001b[39m nan_mask = \\\\u001b[43mfeatures\\\\u001b[49m.isna().any(axis=\\\\u001b[32m1\\\\u001b[39m)\\\\n\\\\u001b[32m      3\\\\u001b[39m features_with_nans = features[nan_mask]\\\\n\\\\n\\\\u001b[31mNameError\\\\u001b[39m: name 'features' is not defined\\\",\\\"location\\\":{\\\"startLineNumber\\\":1,\\\"startColumn\\\":0,\\\"endLineNumber\\\":1,\\\"endColumn\\\":0},\\\"uri\\\":{\\\"$mid\\\":1,\\\"fsPath\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"external\\\":\\\"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X12sZmlsZQ%3D%3D\\\",\\\"path\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"scheme\\\":\\\"vscode-notebook-cell\\\",\\\"fragment\\\":\\\"X12sZmlsZQ==\\\"}}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":38,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_b054dee5-2ef3-417c-a8ac-7d662a467283",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_b054dee5-2ef3-417c-a8ac-7d662a467283","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"457d304c-b832-4c21-bf55-e39b68b765de\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDMwMDAsIDUpCkhlYXZ5IGNhY2hlIHJlYWR5OiBoZWF2eV9mZWF0dXJlc192MS5wa2wgKHRvdGFsIDEpIGluIGNhY2hlL2hlYXZ5X2ZlYXR1cmVzCgrinJMgVXNpbmcgaGVhdnkgY2FjaGUgKG9ubHkgcHJldl9jeWNsZSBmZWF0dXJlcyBjYWNoZWQpCiAgTm90ZTogUm9sbGluZy9zdGF0ZWxlc3MgZmVhdHVyZXMgc3RpbGwgY29tcHV0ZWQgb24tdGhlLWZseQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"31d549a9-ee09-4f69-891b-c53eb00e0821\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"95d43fe2-a9e0-4503-8392-767b5e635bb3\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz0zMDAwLCBjb2xzPTQ1MCwgdG90YWw9MC42OXMgW3N0YXRlbGVzczozNC4zbXMsIG1lcmdlX3N0YXRlbGVzczowLjZtcywgdGVtcG9yYWw6MS4wbXMsIHJvbGxpbmc6OTguMW1zLCBwcmV2X3dlZWtfY3ljbGU6My4zbXMsIGN1cnJlbnRfY3ljbGU6NDcyLjltcywgbm9uX2xpbmVhcjozMi4ybXMsIGN1c3RvbV9pbnRlcmFjdGlvbnM6MjMuM21zLCBjbGVhbnVwOjE5Ljltc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAwLjY5cyAtPiBzaGFwZTogKDMwMDAsIDQ1MCkKCi0tLSBCdWlsZGluZyBWb2xhdGlsaXR5IFJlZ2ltZSBUYXJnZXRzIC0tLQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAxOC42N3MgLT4gc2hhcGU6ICgzMDAwLCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAxOC42N3MgLT4gc2hhcGU6ICgzMDAwLCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgMjM3OQoxICAgICAzODUKMiAgICAgMjAwCk5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoMzAwMCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiAzOC4yOXMKClJlZ2ltZSBkaXN0cmlidXRpb246CnJlZ2ltZV9sYWJlbAowICAgIDIzNzkKMSAgICAgMzg1CjIgICAgIDIwMApOYW1lOiBjb3VudCwgZHR5cGU6IEludDY0CgpDb21iaW5lZCBzaGFwZTogKDMwMDAsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogMzguMjlzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[-3000:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"211413e7-1937-49c7-a841-ebf6ea742e1d\\\",\\\"runStartTime\\\":1764178916223,\\\"runEndTime\\\":1764178954511,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":1,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"49251b87-6527-4753-80ce-d9f7c4cb442d\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"error\\\",\\\"originalError\\\":{\\\"output_type\\\":\\\"error\\\",\\\"ename\\\":\\\"NameError\\\",\\\"evalue\\\":\\\"name 'features' is not defined\\\",\\\"traceback\\\":[\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\",\\\"\\\\u001b[31mNameError\\\\u001b[39m                                 Traceback (most recent call last)\\\",\\\"\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[1]\\\\u001b[39m\\\\u001b[32m, line 2\\\\u001b[39m\\\\n\\\\u001b[32m      1\\\\u001b[39m \\\\u001b[38;5;66;03m# Find rows with any NaN values in features\\\\u001b[39;00m\\\\n\\\\u001b[32m----> \\\\u001b[39m\\\\u001b[32m2\\\\u001b[39m nan_mask = \\\\u001b[43mfeatures\\\\u001b[49m.isna().any(axis=\\\\u001b[32m1\\\\u001b[39m)\\\\n\\\\u001b[32m      3\\\\u001b[39m features_with_nans = features[nan_mask]\\\\n\\\",\\\"\\\\u001b[31mNameError\\\\u001b[39m: name 'features' is not defined\\\"]}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ewoJIm5hbWUiOiAiTmFtZUVycm9yIiwKCSJtZXNzYWdlIjogIm5hbWUgJ2ZlYXR1cmVzJyBpcyBub3QgZGVmaW5lZCIsCgkic3RhY2siOiAiXHUwMDFiWzMxbS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx1MDAxYlszOW1cblx1MDAxYlszMW1OYW1lRXJyb3JcdTAwMWJbMzltICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpXG5cdTAwMWJbMzZtQ2VsbFx1MDAxYlszOW1cdTAwMWJbMzZtIFx1MDAxYlszOW1cdTAwMWJbMzJtSW5bMV1cdTAwMWJbMzltXHUwMDFiWzMybSwgbGluZSAyXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgICAgIDFcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgRmluZCByb3dzIHdpdGggYW55IE5hTiB2YWx1ZXMgaW4gZmVhdHVyZXNcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtLS0tLT4gXHUwMDFiWzM5bVx1MDAxYlszMm0yXHUwMDFiWzM5bSBuYW5fbWFzayA9IFx1MDAxYls0M21mZWF0dXJlc1x1MDAxYls0OW0uaXNuYSgpLmFueShheGlzPVx1MDAxYlszMm0xXHUwMDFiWzM5bSlcblx1MDAxYlszMm0gICAgICAzXHUwMDFiWzM5bSBmZWF0dXJlc193aXRoX25hbnMgPSBmZWF0dXJlc1tuYW5fbWFza11cblxuXHUwMDFiWzMxbU5hbWVFcnJvclx1MDAxYlszOW06IG5hbWUgJ2ZlYXR1cmVzJyBpcyBub3QgZGVmaW5lZCIKfQ==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.error\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n# Find rows with any NaN values in features\\\\nnan_mask = features.isna().any(axis=1)\\\\nfeatures_with_nans = features[nan_mask]\\\\n\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"4b5a9213-29e4-4548-90bd-298b8efc8811\\\",\\\"runStartTime\\\":1764178353998,\\\"runEndTime\\\":1764178354110,\\\"lastRunSuccess\\\":false,\\\"executionOrder\\\":1,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1},\\\"error\\\":{\\\"name\\\":\\\"NameError\\\",\\\"message\\\":\\\"name 'features' is not defined\\\",\\\"stack\\\":\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\\n\\\\u001b[31mNameError\\\\u001b[39m                                 Traceback (most recent call last)\\\\n\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[1]\\\\u001b[39m\\\\u001b[32m, line 2\\\\u001b[39m\\\\n\\\\u001b[32m      1\\\\u001b[39m \\\\u001b[38;5;66;03m# Find rows with any NaN values in features\\\\u001b[39;00m\\\\n\\\\u001b[32m----> \\\\u001b[39m\\\\u001b[32m2\\\\u001b[39m nan_mask = \\\\u001b[43mfeatures\\\\u001b[49m.isna().any(axis=\\\\u001b[32m1\\\\u001b[39m)\\\\n\\\\u001b[32m      3\\\\u001b[39m features_with_nans = features[nan_mask]\\\\n\\\\n\\\\u001b[31mNameError\\\\u001b[39m: name 'features' is not defined\\\",\\\"location\\\":{\\\"startLineNumber\\\":1,\\\"startColumn\\\":0,\\\"endLineNumber\\\":1,\\\"endColumn\\\":0},\\\"uri\\\":{\\\"$mid\\\":1,\\\"fsPath\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"external\\\":\\\"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X12sZmlsZQ%3D%3D\\\",\\\"path\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"scheme\\\":\\\"vscode-notebook-cell\\\",\\\"fragment\\\":\\\"X12sZmlsZQ==\\\"}}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":41,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_9d1a734f-1fb3-4999-b7bb-8a28cceeb48e",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_9d1a734f-1fb3-4999-b7bb-8a28cceeb48e","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"2eb57c97-de93-4f80-8491-ee2fa22c27df\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"58d7c3ce-5202-4cde-94c7-1ae663db4303\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"38eaca1b-1c25-4457-aa60-b29eff19e561\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjY0cyBbc3RhdGVsZXNzOjIzNC45bXMsIG1lcmdlX3N0YXRlbGVzczo0LjNtcywgdGVtcG9yYWw6MTIuNm1zLCByb2xsaW5nOjc2Mi4xbXMsIHByZXZfd2Vla19jeWNsZTo0NC41bXMsIGN1cnJlbnRfY3ljbGU6OTEyNS41bXMsIG5vbl9saW5lYXI6MjUwLjNtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy42bXMsIGNsZWFudXA6MTc3Ljltc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC42NHMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM0MS4yM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQxLjIzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjg5LjMwcwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjg5LjMwcwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":8,\\\"executionId\\\":\\\"477441da-7490-4098-bbe6-ff6503346cc0\\\",\\\"runStartTime\\\":1764179655338,\\\"runEndTime\\\":1764180344639,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"5871f625-2097-44eb-ab45-b9e77aa82511\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjM2cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuMzZzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"539f56b9-fad4-4a05-b167-57f97ac81f61\\\",\\\"runStartTime\\\":1764180574538,\\\"runEndTime\\\":1764180574900,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":15,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"28d960bb-8e4d-4b4b-aeba-3873dbe9e700\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3RtcC9pcHlrZXJuZWxfNDU3NDE5LzI5NTQ5Mjk5OTUucHk6MzogVXNlcldhcm5pbmc6IEJvb2xlYW4gU2VyaWVzIGtleSB3aWxsIGJlIHJlaW5kZXhlZCB0byBtYXRjaCBEYXRhRnJhbWUgaW5kZXguCiAgZmVhdHVyZXNbMTAwOl1bbmFuX21hc2tdCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"b7c68e83-8826-4cd0-b56f-a428747307e1\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":15,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+cHJldl9zYXR1cmRheV9yYW5nZV94X3ZvbDwvdGg+CiAgICAgIDx0aD5wcmV2X3N1bmRheV9yYW5nZV94X3ZvbDwvdGg+CiAgICAgIDx0aD53ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2c8L3RoPgogICAgICA8dGg+d2Vla2RheV92c19zdW5kYXlfcHJvZzwvdGg+CiAgICAgIDx0aD5wcmV2X2N5Y2xlX3Byb2dyZXNzX3hfaG91cjwvdGg+CiAgICAgIDx0aD5leHRyZW1lX3JhbmdlX3ZvbDwvdGg+CiAgICAgIDx0aD5za2V3X3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPmt1cnRvc2lzX3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPmRpc3RhbmNlX3ZvbF9leHRyZW1lPC90aD4KICAgICAgPHRoPnZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nPC90aD4KICAgIDwvdHI+CiAgPC90aGVhZD4KICA8dGJvZHk+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTA1IDA0OjAwOjAwPC90aD4KICAgICAgPHRkPjgxNDkuNDwvdGQ+CiAgICAgIDx0ZD44MTU2Ljc8L3RkPgogICAgICA8dGQ+ODEzOS45PC90ZD4KICAgICAgPHRkPjgxMzkuOTwvdGQ+CiAgICAgIDx0ZD4zNzAuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD41PC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDU1OTY8L3RkPgogICAgICA8dGQ+MC4wMDg0ODg8L3RkPgogICAgICA8dGQ+LTAuMDAwOTA2PC90ZD4KICAgICAgPHRkPi0wLjAwMDI0MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDEwODwvdGQ+CiAgICAgIDx0ZD4wLjAwMzgyNTwvdGQ+CiAgICAgIDx0ZD4tMC4xOTU0OTU8L3RkPgogICAgICA8dGQ+LTAuNzY2NTI5PC90ZD4KICAgICAgPHRkPjAuMDE3MTU5PC90ZD4KICAgICAgPHRkPi00LjM3MDMwNDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0wNSAwNTowMDowMDwvdGg+CiAgICAgIDx0ZD44MTM5Ljk8L3RkPgogICAgICA8dGQ+ODE0MC4wPC90ZD4KICAgICAgPHRkPjgxMjQuMjwvdGQ+CiAgICAgIDx0ZD44MTI4LjA8L3RkPgogICAgICA8dGQ+MzU1LjA8L3RkPgogICAgICA8dGQ+Mi4wPC90ZD4KICAgICAgPHRkPjIyLjA8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD41PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA4NTg5PC90ZD4KICAgICAgPHRkPjAuMDAwMjQwPC90ZD4KICAgICAgPHRkPjAuMDAwNzQwPC90ZD4KICAgICAgPHRkPi0wLjAwMDc1NTwvdGQ+CiAgICAgIDx0ZD4wLjAwMjA3MzwvdGQ+CiAgICAgIDx0ZD4tMC4xOTcyODM8L3RkPgogICAgICA8dGQ+LTAuNzUxNzU2PC90ZD4KICAgICAgPHRkPjAuMDE1MTA5PC90ZD4KICAgICAgPHRkPi0zLjkzMzA5NzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0wNSAwNjowMDowMDwvdGg+CiAgICAgIDx0ZD44MTI4LjA8L3RkPgogICAgICA8dGQ+ODE0NS40PC90ZD4KICAgICAgPHRkPjgxMTUuMzwvdGQ+CiAgICAgIDx0ZD44MTQyLjM8L3RkPgogICAgICA8dGQ+NjE1LjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+NzwvdGQ+CiAgICAgIDx0ZD41PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDA1NDY3PC90ZD4KICAgICAgPHRkPjAuMDA4NzMyPC90ZD4KICAgICAgPHRkPi0wLjAwMDUyMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMDczMjwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAyODE8L3RkPgogICAgICA8dGQ+MC4wMDI3MzE8L3RkPgogICAgICA8dGQ+LTAuMTYzMTczPC90ZD4KICAgICAgPHRkPi0wLjc0NjQ1ODwvdGQ+CiAgICAgIDx0ZD4wLjAxNTU1ODwvdGQ+CiAgICAgIDx0ZD4tMy42NzIyNDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMDUgMDc6MDA6MDA8L3RoPgogICAgICA8dGQ+ODE0Mi4zPC90ZD4KICAgICAgPHRkPjgxNDIuMzwvdGQ+CiAgICAgIDx0ZD44MTEyLjY8L3RkPgogICAgICA8dGQ+ODEyMy4zPC90ZD4KICAgICAgPHRkPjg0NC4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+NTwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDQzODY8L3RkPgogICAgICA8dGQ+LTAuMTY0ODUwPC90ZD4KICAgICAgPHRkPi0wLjc2MzMwNzwvdGQ+CiAgICAgIDx0ZD4wLjAxNDkyMzwvdGQ+CiAgICAgIDx0ZD4tMS4wMTE1NDc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMDUgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODEyMy4zPC90ZD4KICAgICAgPHRkPjgxMjMuMzwvdGQ+CiAgICAgIDx0ZD44MDgxLjA8L3RkPgogICAgICA8dGQ+ODEwMi44PC90ZD4KICAgICAgPHRkPjE4NjQuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDEwNDc8L3RkPgogICAgICA8dGQ+MC4wMDEwMzA8L3RkPgogICAgICA8dGQ+MC4wMDAyNTk8L3RkPgogICAgICA8dGQ+LTAuMDAwMDQ4PC90ZD4KICAgICAgPHRkPjAuMDAwMDYwPC90ZD4KICAgICAgPHRkPjAuMDA2MzIwPC90ZD4KICAgICAgPHRkPi0wLjE4MjM2OTwvdGQ+CiAgICAgIDx0ZD4tMC42ODAyMjE8L3RkPgogICAgICA8dGQ+MC4wMTU5MTc8L3RkPgogICAgICA8dGQ+MC45NzMwMDk8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyMi0xMi0xOCAxNDowMDowMDwvdGg+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjE2NzM5Ljc8L3RkPgogICAgICA8dGQ+MTY3MzkuNzwvdGQ+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjAuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNTwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDAxMTA4PC90ZD4KICAgICAgPHRkPjAuMDAxMzI5PC90ZD4KICAgICAgPHRkPi0wLjAwMDUzODwvdGQ+CiAgICAgIDx0ZD4wLjAwMDE5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAzNDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAwMDA8L3RkPgogICAgICA8dGQ+LTAuMzE3NzcyPC90ZD4KICAgICAgPHRkPjAuMDE0NDgzPC90ZD4KICAgICAgPHRkPi0xLjAwMDAwMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyMi0xMi0xOCAxNTowMDowMDwvdGg+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjE2NzM5Ljc8L3RkPgogICAgICA8dGQ+MTY3MzkuNzwvdGQ+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjAuMDwvdGQ+CiAgICAgIDx0ZD4xNi4wPC90ZD4KICAgICAgPHRkPjguMDwvdGQ+CiAgICAgIDx0ZD4xNjwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDAxMjI3PC90ZD4KICAgICAgPHRkPjAuMDAxNDA2PC90ZD4KICAgICAgPHRkPi0wLjAwMDM1MDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDA3NjwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+LTAuMDAwMDAwPC90ZD4KICAgICAgPHRkPi0wLjMxNjY0NzwvdGQ+CiAgICAgIDx0ZD4wLjAxNDEzODwvdGQ+CiAgICAgIDx0ZD4tMS4wMDAwMDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjItMTItMTggMTY6MDA6MDA8L3RoPgogICAgICA8dGQ+MTY3MzkuNzwvdGQ+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjE2NzM5Ljc8L3RkPgogICAgICA8dGQ+MTY3MzkuNzwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+MTUuMDwvdGQ+CiAgICAgIDx0ZD45LjA8L3RkPgogICAgICA8dGQ+MTc8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAwMDgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDg5NTwvdGQ+CiAgICAgIDx0ZD4tMC4wMDA5OTE8L3RkPgogICAgICA8dGQ+LTAuMDAwNDM5PC90ZD4KICAgICAgPHRkPjAuMDAwMTEzPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPi0wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4tMC4xODY5NjY8L3RkPgogICAgICA8dGQ+MC4wMTM5NzU8L3RkPgogICAgICA8dGQ+LTEuMDAwMDAwPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDIyLTEyLTE4IDE3OjAwOjAwPC90aD4KICAgICAgPHRkPjE2NzM5Ljc8L3RkPgogICAgICA8dGQ+MTY3MzkuNzwvdGQ+CiAgICAgIDx0ZD4xNjczOS43PC90ZD4KICAgICAgPHRkPjE2NzM5Ljc8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjE0LjA8L3RkPgogICAgICA8dGQ+MTAuMDwvdGQ+CiAgICAgIDx0ZD4xODwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDAwNDA0PC90ZD4KICAgICAgPHRkPjAuMDAwNDUxPC90ZD4KICAgICAgPHRkPjAuMDAwMjcyPC90ZD4KICAgICAgPHRkPjAuMDAwNTI0PC90ZD4KICAgICAgPHRkPi0wLjAwMDEyMDwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAwMDA8L3RkPgogICAgICA8dGQ+LTAuMDg3NzIxPC90ZD4KICAgICAgPHRkPjAuMDEzNDA4PC90ZD4KICAgICAgPHRkPi0xLjAwMDAwMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyMi0xMi0xOCAxODowMDowMDwvdGg+CiAgICAgIDx0ZD4xNjczMy44PC90ZD4KICAgICAgPHRkPjE2NzQ2Ljc8L3RkPgogICAgICA8dGQ+MTY3MTkuMzwvdGQ+CiAgICAgIDx0ZD4xNjc0My44PC90ZD4KICAgICAgPHRkPjkyLjA8L3RkPgogICAgICA8dGQ+MTMuMDwvdGQ+CiAgICAgIDx0ZD4xMS4wPC90ZD4KICAgICAgPHRkPjE5PC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDA1NzI8L3RkPgogICAgICA8dGQ+MC4wMDA2NDY8L3RkPgogICAgICA8dGQ+LTAuMDAwMzEwPC90ZD4KICAgICAgPHRkPi0wLjAwMDA0NjwvdGQ+CiAgICAgIDx0ZD4tMC4wMDAwMzA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+LTAuMDQwMzcyPC90ZD4KICAgICAgPHRkPi0wLjExOTM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAxMjk1MDwvdGQ+CiAgICAgIDx0ZD4tMS4wMDAwMDA8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD4zNjAgcm93cyDDlyA0NTAgY29sdW1uczwvcD4KPC9kaXY+\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMDUgMDQ6MDA6MDAgICA4MTQ5LjQgICA4MTU2LjcgICA4MTM5LjkgICA4MTM5LjkgICAzNzAuMCAgIAoyMDE5LTEwLTA1IDA1OjAwOjAwICAgODEzOS45ICAgODE0MC4wICAgODEyNC4yICAgODEyOC4wICAgMzU1LjAgICAKMjAxOS0xMC0wNSAwNjowMDowMCAgIDgxMjguMCAgIDgxNDUuNCAgIDgxMTUuMyAgIDgxNDIuMyAgIDYxNS4wICAgCjIwMTktMTAtMDUgMDc6MDA6MDAgICA4MTQyLjMgICA4MTQyLjMgICA4MTEyLjYgICA4MTIzLjMgICA4NDQuMCAgIAoyMDE5LTEwLTA1IDA4OjAwOjAwICAgODEyMy4zICAgODEyMy4zICAgODA4MS4wICAgODEwMi44ICAxODY0LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjItMTItMTggMTQ6MDA6MDAgIDE2NzM5LjcgIDE2NzM5LjcgIDE2NzM5LjcgIDE2NzM5LjcgICAgIDAuMCAgIAoyMDIyLTEyLTE4IDE1OjAwOjAwICAxNjczOS43ICAxNjczOS43ICAxNjczOS43ICAxNjczOS43ICAgICAwLjAgICAKMjAyMi0xMi0xOCAxNjowMDowMCAgMTY3MzkuNyAgMTY3MzkuNyAgMTY3MzkuNyAgMTY3MzkuNyAgICAgMC4wICAgCjIwMjItMTItMTggMTc6MDA6MDAgIDE2NzM5LjcgIDE2NzM5LjcgIDE2NzM5LjcgIDE2NzM5LjcgICAgIDAuMCAgIAoyMDIyLTEyLTE4IDE4OjAwOjAwICAxNjczMy44ICAxNjc0Ni43ICAxNjcxOS4zICAxNjc0My44ICAgIDkyLjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTA1IDA0OjAwOjAwICAgICAgICAgICAgICAzLjAgICAgICAgICAgMjEuMCAgICAgNSAgICAgICAgICAgIDUgICAKMjAxOS0xMC0wNSAwNTowMDowMCAgICAgICAgICAgICAgMi4wICAgICAgICAgIDIyLjAgICAgIDYgICAgICAgICAgICA1ICAgCjIwMTktMTAtMDUgMDY6MDA6MDAgICAgICAgICAgICAgIDEuMCAgICAgICAgICAyMy4wICAgICA3ICAgICAgICAgICAgNSAgIAoyMDE5LTEwLTA1IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDUgICAKMjAxOS0xMC0wNSAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICA1ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDIyLTEyLTE4IDE0OjAwOjAwICAgICAgICAgICAgIDE3LjAgICAgICAgICAgIDcuMCAgICAxNSAgICAgICAgICAgIDYgICAKMjAyMi0xMi0xOCAxNTowMDowMCAgICAgICAgICAgICAxNi4wICAgICAgICAgICA4LjAgICAgMTYgICAgICAgICAgICA2ICAgCjIwMjItMTItMTggMTY6MDA6MDAgICAgICAgICAgICAgMTUuMCAgICAgICAgICAgOS4wICAgIDE3ICAgICAgICAgICAgNiAgIAoyMDIyLTEyLTE4IDE3OjAwOjAwICAgICAgICAgICAgIDE0LjAgICAgICAgICAgMTAuMCAgICAxOCAgICAgICAgICAgIDYgICAKMjAyMi0xMi0xOCAxODowMDowMCAgICAgICAgICAgICAxMy4wICAgICAgICAgIDExLjAgICAgMTkgICAgICAgICAgICA2ICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHByZXZfc2F0dXJkYXlfcmFuZ2VfeF92b2wgIFwKMjAxOS0xMC0wNSAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDA1NTk2ICAgCjIwMTktMTAtMDUgMDU6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwNTQ5NSAgIAoyMDE5LTEwLTA1IDA2OjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAgICAgICAgICAgMC4wMDU0NjcgICAKMjAxOS0xMC0wNSAwNzowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDAwMDAwICAgCjIwMTktMTAtMDUgMDg6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwMTA0NyAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAKMjAyMi0xMi0xOCAxNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDAxMTA4ICAgCjIwMjItMTItMTggMTU6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwMTIyNyAgIAoyMDIyLTEyLTE4IDE2OjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAgICAgICAgICAgMC4wMDA4MDQgICAKMjAyMi0xMi0xOCAxNzowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgICAgICAgICAgIDAuMDAwNDA0ICAgCjIwMjItMTItMTggMTg6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgICAgICAgICAgICAwLjAwMDU3MiAgIAoKICAgICAgICAgICAgICAgICAgICAgcHJldl9zdW5kYXlfcmFuZ2VfeF92b2wgIHdlZWtkYXlfdnNfc2F0dXJkYXlfcHJvZyAgXAoyMDE5LTEwLTA1IDA0OjAwOjAwICAgICAgICAgICAgICAgICAwLjAwODQ4OCAgICAgICAgICAgICAgICAgLTAuMDAwOTA2ICAgCjIwMTktMTAtMDUgMDU6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDA4NTg5ICAgICAgICAgICAgICAgICAgMC4wMDAyNDAgICAKMjAxOS0xMC0wNSAwNjowMDowMCAgICAgICAgICAgICAgICAgMC4wMDg3MzIgICAgICAgICAgICAgICAgIC0wLjAwMDUyMiAgIAoyMDE5LTEwLTA1IDA3OjAwOjAwICAgICAgICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgICAgICAgICAgIDAuMDAwMDAwICAgCjIwMTktMTAtMDUgMDg6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDAxMDMwICAgICAgICAgICAgICAgICAgMC4wMDAyNTkgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgIC4uLiAgIAoyMDIyLTEyLTE4IDE0OjAwOjAwICAgICAgICAgICAgICAgICAwLjAwMTMyOSAgICAgICAgICAgICAgICAgLTAuMDAwNTM4ICAgCjIwMjItMTItMTggMTU6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDAxNDA2ICAgICAgICAgICAgICAgICAtMC4wMDAzNTAgICAKMjAyMi0xMi0xOCAxNjowMDowMCAgICAgICAgICAgICAgICAgMC4wMDA4OTUgICAgICAgICAgICAgICAgIC0wLjAwMDk5MSAgIAoyMDIyLTEyLTE4IDE3OjAwOjAwICAgICAgICAgICAgICAgICAwLjAwMDQ1MSAgICAgICAgICAgICAgICAgIDAuMDAwMjcyICAgCjIwMjItMTItMTggMTg6MDA6MDAgICAgICAgICAgICAgICAgIDAuMDAwNjQ2ICAgICAgICAgICAgICAgICAtMC4wMDAzMTAgICAKCiAgICAgICAgICAgICAgICAgICAgIHdlZWtkYXlfdnNfc3VuZGF5X3Byb2cgIHByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyICBcCjIwMTktMTAtMDUgMDQ6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDAyNDEgICAgICAgICAgICAgICAgICAgIDAuMDAwMTA4ICAgCjIwMTktMTAtMDUgMDU6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDA3NDAgICAgICAgICAgICAgICAgICAgLTAuMDAwNzU1ICAgCjIwMTktMTAtMDUgMDY6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDA3MzIgICAgICAgICAgICAgICAgICAgLTAuMDAwMjgxICAgCjIwMTktMTAtMDUgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDAwMDAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDAwICAgCjIwMTktMTAtMDUgMDg6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDAwNDggICAgICAgICAgICAgICAgICAgIDAuMDAwMDYwICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjItMTItMTggMTQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDAxOTMgICAgICAgICAgICAgICAgICAgIDAuMDAwMDM0ICAgCjIwMjItMTItMTggMTU6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDAwNzYgICAgICAgICAgICAgICAgICAgLTAuMDAwMDAwICAgCjIwMjItMTItMTggMTY6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDA0MzkgICAgICAgICAgICAgICAgICAgIDAuMDAwMTEzICAgCjIwMjItMTItMTggMTc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDA1MjQgICAgICAgICAgICAgICAgICAgLTAuMDAwMTIwICAgCjIwMjItMTItMTggMTg6MDA6MDAgICAgICAgICAgICAgICAtMC4wMDAwNDYgICAgICAgICAgICAgICAgICAgLTAuMDAwMDMwICAgCgogICAgICAgICAgICAgICAgICAgICBleHRyZW1lX3JhbmdlX3ZvbCAgc2tld192b2xfZXh0cmVtZSAgXAoyMDE5LTEwLTA1IDA0OjAwOjAwICAgICAgICAgICAwLjAwMzgyNSAgICAgICAgIC0wLjE5NTQ5NSAgIAoyMDE5LTEwLTA1IDA1OjAwOjAwICAgICAgICAgICAwLjAwMjA3MyAgICAgICAgIC0wLjE5NzI4MyAgIAoyMDE5LTEwLTA1IDA2OjAwOjAwICAgICAgICAgICAwLjAwMjczMSAgICAgICAgIC0wLjE2MzE3MyAgIAoyMDE5LTEwLTA1IDA3OjAwOjAwICAgICAgICAgICAwLjAwNDM4NiAgICAgICAgIC0wLjE2NDg1MCAgIAoyMDE5LTEwLTA1IDA4OjAwOjAwICAgICAgICAgICAwLjAwNjMyMCAgICAgICAgIC0wLjE4MjM2OSAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgIC4uLiAgIAoyMDIyLTEyLTE4IDE0OjAwOjAwICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgIC0wLjAwMDAwMCAgIAoyMDIyLTEyLTE4IDE1OjAwOjAwICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgIC0wLjAwMDAwMCAgIAoyMDIyLTEyLTE4IDE2OjAwOjAwICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgIC0wLjAwMDAwMCAgIAoyMDIyLTEyLTE4IDE3OjAwOjAwICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgIC0wLjAwMDAwMCAgIAoyMDIyLTEyLTE4IDE4OjAwOjAwICAgICAgICAgICAwLjAwMDAwMCAgICAgICAgIC0wLjA0MDM3MiAgIAoKICAgICAgICAgICAgICAgICAgICAga3VydG9zaXNfdm9sX2V4dHJlbWUgIGRpc3RhbmNlX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMDUgMDQ6MDA6MDAgICAgICAgICAgICAgLTAuNzY2NTI5ICAgICAgICAgICAgICAwLjAxNzE1OSAgIAoyMDE5LTEwLTA1IDA1OjAwOjAwICAgICAgICAgICAgIC0wLjc1MTc1NiAgICAgICAgICAgICAgMC4wMTUxMDkgICAKMjAxOS0xMC0wNSAwNjowMDowMCAgICAgICAgICAgICAtMC43NDY0NTggICAgICAgICAgICAgIDAuMDE1NTU4ICAgCjIwMTktMTAtMDUgMDc6MDA6MDAgICAgICAgICAgICAgLTAuNzYzMzA3ICAgICAgICAgICAgICAwLjAxNDkyMyAgIAoyMDE5LTEwLTA1IDA4OjAwOjAwICAgICAgICAgICAgIC0wLjY4MDIyMSAgICAgICAgICAgICAgMC4wMTU5MTcgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjItMTItMTggMTQ6MDA6MDAgICAgICAgICAgICAgLTAuMzE3NzcyICAgICAgICAgICAgICAwLjAxNDQ4MyAgIAoyMDIyLTEyLTE4IDE1OjAwOjAwICAgICAgICAgICAgIC0wLjMxNjY0NyAgICAgICAgICAgICAgMC4wMTQxMzggICAKMjAyMi0xMi0xOCAxNjowMDowMCAgICAgICAgICAgICAtMC4xODY5NjYgICAgICAgICAgICAgIDAuMDEzOTc1ICAgCjIwMjItMTItMTggMTc6MDA6MDAgICAgICAgICAgICAgLTAuMDg3NzIxICAgICAgICAgICAgICAwLjAxMzQwOCAgIAoyMDIyLTEyLTE4IDE4OjAwOjAwICAgICAgICAgICAgIC0wLjExOTM2MSAgICAgICAgICAgICAgMC4wMTI5NTAgICAKCiAgICAgICAgICAgICAgICAgICAgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICAKMjAxOS0xMC0wNSAwNDowMDowMCAgICAgICAgICAgICAgICAtNC4zNzAzMDQgIAoyMDE5LTEwLTA1IDA1OjAwOjAwICAgICAgICAgICAgICAgIC0zLjkzMzA5NyAgCjIwMTktMTAtMDUgMDY6MDA6MDAgICAgICAgICAgICAgICAgLTMuNjcyMjQ2ICAKMjAxOS0xMC0wNSAwNzowMDowMCAgICAgICAgICAgICAgICAtMS4wMTE1NDcgIAoyMDE5LTEwLTA1IDA4OjAwOjAwICAgICAgICAgICAgICAgICAwLjk3MzAwOSAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAKMjAyMi0xMi0xOCAxNDowMDowMCAgICAgICAgICAgICAgICAtMS4wMDAwMDAgIAoyMDIyLTEyLTE4IDE1OjAwOjAwICAgICAgICAgICAgICAgIC0xLjAwMDAwMCAgCjIwMjItMTItMTggMTY6MDA6MDAgICAgICAgICAgICAgICAgLTEuMDAwMDAwICAKMjAyMi0xMi0xOCAxNzowMDowMCAgICAgICAgICAgICAgICAtMS4wMDAwMDAgIAoyMDIyLTEyLTE4IDE4OjAwOjAwICAgICAgICAgICAgICAgIC0xLjAwMDAwMCAgCgpbMzYwIHJvd3MgeCA0NTAgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"nan_mask = features.isna().any(axis=1)\\\\n\\\\nfeatures[100:][nan_mask]\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"91959877-7211-4d38-afd6-fcf6fa5704fc\\\",\\\"runStartTime\\\":1764180683832,\\\"runEndTime\\\":1764180683857,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":15,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":17,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"0ee02236-5196-4bc5-8010-8b9b4d6e748a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"UmVtb3ZpbmcgZGF0YSBiZWZvcmUgMjAxOS0xMS0wMSAoZmlyc3QgMSBtb250aHMpCk5hTiByb3dzIGFmdGVyIGN1dG9mZiByZW1vdmFsOiAxNzMgLyA1MzIyMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"6b9a7617-09f3-4f74-a636-6946075ccdaa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":17,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+OTE1MS4yPC90ZD4KICAgICAgPHRkPjkxNTUuODwvdGQ+CiAgICAgIDx0ZD45MTE1LjA8L3RkPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjExNzQuMDwvdGQ+CiAgICAgIDx0ZD43LjA8L3RkPgogICAgICA8dGQ+MTcuMDwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MS4wODg3NzM8L3RkPgogICAgICA8dGQ+MC4xMjUwNzQ8L3RkPgogICAgICA8dGQ+MC4xMjE1Mjc8L3RkPgogICAgICA8dGQ+LTQuNjkxMjk2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC41NzIwODI8L3RkPgogICAgICA8dGQ+MS4xNDQxNjM8L3RkPgogICAgICA8dGQ+MC4wMDYzODc8L3RkPgogICAgICA8dGQ+MC4wMDgzNjg8L3RkPgogICAgICA8dGQ+MC4wMDU5MDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDE6MDA6MDA8L3RoPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjkxNDkuMDwvdGQ+CiAgICAgIDx0ZD45MTA4Ljg8L3RkPgogICAgICA8dGQ+OTEwOC44PC90ZD4KICAgICAgPHRkPjk4Ny4wPC90ZD4KICAgICAgPHRkPjYuMDwvdGQ+CiAgICAgIDx0ZD4xOC4wPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjExNzU4ODwvdGQ+CiAgICAgIDx0ZD4wLjEyNzYwNzwvdGQ+CiAgICAgIDx0ZD4wLjEyMjMwNTwvdGQ+CiAgICAgIDx0ZD4tMy45NzQ1NTQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MTUwODwvdGQ+CiAgICAgIDx0ZD4xLjI4MzAxNzwvdGQ+CiAgICAgIDx0ZD4wLjAwNjYxMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTY4NjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD45MTA4Ljk8L3RkPgogICAgICA8dGQ+OTE0OC44PC90ZD4KICAgICAgPHRkPjkwNzUuMjwvdGQ+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+MTY1NS4wPC90ZD4KICAgICAgPHRkPjUuMDwvdGQ+CiAgICAgIDx0ZD4xOS4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjA2MzkxNDwvdGQ+CiAgICAgIDx0ZD4wLjEwMDA5NTwvdGQ+CiAgICAgIDx0ZD4wLjA5ODQ5NzwvdGQ+CiAgICAgIDx0ZD4tNS4yMzE1OTY8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2MTY3MjwvdGQ+CiAgICAgIDx0ZD4wLjkyMzM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MjwvdGQ+CiAgICAgIDx0ZD4wLjAwNDgyNjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+OTEzNy4zPC90ZD4KICAgICAgPHRkPjkwNjEuNTwvdGQ+CiAgICAgIDx0ZD45MDgyLjk8L3RkPgogICAgICA8dGQ+MTMxNS4wPC90ZD4KICAgICAgPHRkPjQuMDwvdGQ+CiAgICAgIDx0ZD4yMC4wPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjU2ODcyODwvdGQ+CiAgICAgIDx0ZD4wLjAyMzk2MTwvdGQ+CiAgICAgIDx0ZD4wLjA2NDc3NTwvdGQ+CiAgICAgIDx0ZD4tMi4yNTMwMjg8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MDM4NzwvdGQ+CiAgICAgIDx0ZD4xLjI4MDc3NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzUyOTwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTAwMTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwNDowMDowMDwvdGg+CiAgICAgIDx0ZD45MDgzLjA8L3RkPgogICAgICA8dGQ+OTEyMy40PC90ZD4KICAgICAgPHRkPjkwNjAuMDwvdGQ+CiAgICAgIDx0ZD45MDk5Ljc8L3RkPgogICAgICA8dGQ+MTQ5Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjQ3ODcwNTwvdGQ+CiAgICAgIDx0ZD4tMC4xMTQ3NTA8L3RkPgogICAgICA8dGQ+MC4wNjk5MDk8L3RkPgogICAgICA8dGQ+LTQuNDI4MDIzPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42NjE0ODg8L3RkPgogICAgICA8dGQ+MS4zMjI5NzY8L3RkPgogICAgICA8dGQ+MC4wMDY3MTk8L3RkPgogICAgICA8dGQ+MC4wMDgyNzM8L3RkPgogICAgICA8dGQ+MC4wMDU1NDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40NjczNzM8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDYzOTM8L3RkPgogICAgICA8dGQ+MC4wMDU0ODM8L3RkPgogICAgICA8dGQ+MC4wMDM4NjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc4NzIuNzwvdGQ+CiAgICAgIDx0ZD44Nzg4MS44PC90ZD4KICAgICAgPHRkPjg3MzQyLjk8L3RkPgogICAgICA8dGQ+ODczNjEuNzwvdGQ+CiAgICAgIDx0ZD4yMzIuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMTQ1NzI8L3RkPgogICAgICA8dGQ+LTEuMTE1MjQyPC90ZD4KICAgICAgPHRkPjAuMDI2OTcyPC90ZD4KICAgICAgPHRkPi02LjMxODY5MTwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMjQ5NTAxPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA3MjA0PC90ZD4KICAgICAgPHRkPjAuMDA1NDgxPC90ZD4KICAgICAgPHRkPjAuMDAzNDI3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjg3MzUzLjU8L3RkPgogICAgICA8dGQ+ODczOTYuNzwvdGQ+CiAgICAgIDx0ZD44NjYyNy45PC90ZD4KICAgICAgPHRkPjg2Nzc2LjI8L3RkPgogICAgICA8dGQ+NTY3LjA8L3RkPgogICAgICA8dGQ+MjIuMDwvdGQ+CiAgICAgIDx0ZD4yLjA8L3RkPgogICAgICA8dGQ+MTA8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wNTQ3OTc8L3RkPgogICAgICA8dGQ+LTEuMTM5NTQ0PC90ZD4KICAgICAgPHRkPjAuMDMwMTI2PC90ZD4KICAgICAgPHRkPi00Ljk4OTM3NjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMDkyNzIwPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA1NjY4PC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA0MzY3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTc0NjE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDgxOTg8L3RkPgogICAgICA8dGQ+MC4wMDU1MDM8L3RkPgogICAgICA8dGQ+MC4wMDMwMjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTE6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44Njg3OS43PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+ODY4MTguODwvdGQ+CiAgICAgIDx0ZD41LjA8L3RkPgogICAgICA8dGQ+MjAuMDwvdGQ+CiAgICAgIDx0ZD40LjA8L3RkPgogICAgICA8dGQ+MTI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wOTQ4NTk8L3RkPgogICAgICA8dGQ+LTAuOTQzNTkzPC90ZD4KICAgICAgPHRkPjAuMDMyOTE1PC90ZD4KICAgICAgPHRkPi01LjQwNjkwMzwvdGQ+CiAgICAgIDx0ZD4mbHQ7TkEmZ3Q7PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+MC4wMDk1NTA8L3RkPgogICAgICA8dGQ+MC4wMDU0Nzg8L3RkPgogICAgICA8dGQ+MC4wMDI1ODM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD41MzIyMCByb3dzIMOXIDQ1NiBjb2x1bW5zPC9wPgo8L2Rpdj4=\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICA5MTUxLjIgICA5MTU1LjggICA5MTE1LjAgICA5MTM1LjAgIDExNzQuMCAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgOTEzNS4wICAgOTE0OS4wICAgOTEwOC44ICAgOTEwOC44ICAgOTg3LjAgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgIDkxMDguOSAgIDkxNDguOCAgIDkwNzUuMiAgIDkxMzcuMyAgMTY1NS4wICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICA5MTM3LjMgICA5MTM3LjMgICA5MDYxLjUgICA5MDgyLjkgIDEzMTUuMCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgOTA4My4wICAgOTEyMy40ICAgOTA2MC4wICAgOTA5OS43ICAxNDk2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgIDg3NzI1LjIgIDg3OTAwLjAgIDg3NjM3LjcgIDg3ODcyLjYgICAxOTUuMCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICA4Nzg3Mi43ICA4Nzg4MS44ICA4NzM0Mi45ICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgODczNTMuNSAgODczOTYuNyAgODY2MjcuOSAgODY3NzYuMiAgIDU2Ny4wICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgIDg2NzcyLjIgIDg2OTk5LjkgIDg2NTk1LjggIDg2ODc5LjcgICAxOTUuMCAgIAoyMDI1LTExLTI2IDExOjAwOjAwICA4Njg3OS43ICA4Njg3OS43ICA4NjgxOC44ICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTExLTAxIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA0ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNCAgIAoyMDE5LTExLTAxIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA0ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAxLjA4ODc3MyAgICAgICAgICAgICAgMC4xMjUwNzQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDEuMTE3NTg4ICAgICAgICAgICAgICAwLjEyNzYwNyAgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMS4wNjM5MTQgICAgICAgICAgICAgIDAuMTAwMDk1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjU2ODcyOCAgICAgICAgICAgICAgMC4wMjM5NjEgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuNDc4NzA1ICAgICAgICAgICAgIC0wLjExNDc1MCAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAxMzkwMyAgICAgICAgICAgICAtMS4xNDkzOTUgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDE0NTcyICAgICAgICAgICAgIC0xLjExNTI0MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAtMC4wNTQ3OTcgICAgICAgICAgICAgLTEuMTM5NTQ0ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjEwODAzMyAgICAgICAgICAgICAtMC45ODU5MjMgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMDk0ODU5ICAgICAgICAgICAgIC0wLjk0MzU5MyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMTIxNTI3ICAgICAgICAgICAgICAgIC00LjY5MTI5NiAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgICAgICAgICAgICAwLjEyMjMwNSAgICAgICAgICAgICAgICAtMy45NzQ1NTQgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgICAgICAgICAgICAgMC4wOTg0OTcgICAgICAgICAgICAgICAgLTUuMjMxNTk2ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDY0Nzc1ICAgICAgICAgICAgICAgIC0yLjI1MzAyOCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgICAgICAgICAgICAwLjA2OTkwOSAgICAgICAgICAgICAgICAtNC40MjgwMjMgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgIDAuMDI4MDY4ICAgICAgICAgICAgICAgIC0xLjk3MjA0MCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAwLjAyNjk3MiAgICAgICAgICAgICAgICAtNi4zMTg2OTEgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgMC4wMzAxMjYgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgIDAuMDMzNjQzICAgICAgICAgICAgICAgICA3LjEzMDI3MiAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAwLjAzMjkxNSAgICAgICAgICAgICAgICAtNS40MDY5MDMgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNTcyMDgyICAgICAgICAgIDEuMTQ0MTYzICAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQxNTA4ICAgICAgICAgIDEuMjgzMDE3ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDYxNjcyICAgICAgICAgIDAuOTIzMzQ1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQwMzg3ICAgICAgICAgIDEuMjgwNzc1ICAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjYxNDg4ICAgICAgICAgIDEuMzIyOTc2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgPE5BPiAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgTmFOICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMS0wMSAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM4NyAgICAgMC4wMDgzNjggICAgICAwLjAwNTkwMCAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY2MTAgICAgIDAuMDA4MzQ1ICAgICAgMC4wMDU2ODYgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3ODA0ICAgICAwLjAwODM2MiAgICAgIDAuMDA0ODI2ICAKMjAxOS0xMS0wMSAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzUyOSAgICAgMC4wMDgzNjEgICAgICAwLjAwNTAwMSAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY3MTkgICAgIDAuMDA4MjczICAgICAgMC4wMDU1NDYgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM5MyAgICAgMC4wMDU0ODMgICAgICAwLjAwMzg2MyAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDcyMDQgICAgIDAuMDA1NDgxICAgICAgMC4wMDM0MjcgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA1NjY4ICAgICAwLjAwNTQ5NSAgICAgIDAuMDA0MzY3ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAwLjAwODE5OCAgICAgMC4wMDU1MDMgICAgICAwLjAwMzAyMyAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDk1NTAgICAgIDAuMDA1NDc4ICAgICAgMC4wMDI1ODMgIAoKWzUzMjIwIHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\n\\\\nnan_mask_clean = combined_df_clean.isna().any(axis=1)\\\\nprint(f\\\\\\\"NaN rows after cutoff removal: {nan_mask_clean.sum()} / {combined_df_clean.shape[0]}\\\\\\\")\\\\ncombined_df_clean\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"12d0618e-4a5b-45a0-b040-8fb4aa1c38e9\\\",\\\"runStartTime\\\":1764180761320,\\\"runEndTime\\\":1764180761376,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":17,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":45,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_269d5b27-8e89-438c-bbb8-63b3245733cb",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_269d5b27-8e89-438c-bbb8-63b3245733cb","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"2eb57c97-de93-4f80-8491-ee2fa22c27df\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"58d7c3ce-5202-4cde-94c7-1ae663db4303\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"38eaca1b-1c25-4457-aa60-b29eff19e561\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjY0cyBbc3RhdGVsZXNzOjIzNC45bXMsIG1lcmdlX3N0YXRlbGVzczo0LjNtcywgdGVtcG9yYWw6MTIuNm1zLCByb2xsaW5nOjc2Mi4xbXMsIHByZXZfd2Vla19jeWNsZTo0NC41bXMsIGN1cnJlbnRfY3ljbGU6OTEyNS41bXMsIG5vbl9saW5lYXI6MjUwLjNtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy42bXMsIGNsZWFudXA6MTc3Ljltc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC42NHMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM0MS4yM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQxLjIzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjg5LjMwcwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjg5LjMwcwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":8,\\\"executionId\\\":\\\"477441da-7490-4098-bbe6-ff6503346cc0\\\",\\\"runStartTime\\\":1764179655338,\\\"runEndTime\\\":1764180344639,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"5871f625-2097-44eb-ab45-b9e77aa82511\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjM2cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuMzZzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"539f56b9-fad4-4a05-b167-57f97ac81f61\\\",\\\"runStartTime\\\":1764180574538,\\\"runEndTime\\\":1764180574900,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":18,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"354380a9-5e0a-4d20-ab60-898a50136396\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f76d01d2-6887-4ad9-aa84-ffd6daad6aff\\\",\\\"runStartTime\\\":1764180883405,\\\"runEndTime\\\":1764180883441,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":18,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":17,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"0ee02236-5196-4bc5-8010-8b9b4d6e748a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"UmVtb3ZpbmcgZGF0YSBiZWZvcmUgMjAxOS0xMS0wMSAoZmlyc3QgMSBtb250aHMpCk5hTiByb3dzIGFmdGVyIGN1dG9mZiByZW1vdmFsOiAxNzMgLyA1MzIyMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"6b9a7617-09f3-4f74-a636-6946075ccdaa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":17,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+OTE1MS4yPC90ZD4KICAgICAgPHRkPjkxNTUuODwvdGQ+CiAgICAgIDx0ZD45MTE1LjA8L3RkPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjExNzQuMDwvdGQ+CiAgICAgIDx0ZD43LjA8L3RkPgogICAgICA8dGQ+MTcuMDwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MS4wODg3NzM8L3RkPgogICAgICA8dGQ+MC4xMjUwNzQ8L3RkPgogICAgICA8dGQ+MC4xMjE1Mjc8L3RkPgogICAgICA8dGQ+LTQuNjkxMjk2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC41NzIwODI8L3RkPgogICAgICA8dGQ+MS4xNDQxNjM8L3RkPgogICAgICA8dGQ+MC4wMDYzODc8L3RkPgogICAgICA8dGQ+MC4wMDgzNjg8L3RkPgogICAgICA8dGQ+MC4wMDU5MDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDE6MDA6MDA8L3RoPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjkxNDkuMDwvdGQ+CiAgICAgIDx0ZD45MTA4Ljg8L3RkPgogICAgICA8dGQ+OTEwOC44PC90ZD4KICAgICAgPHRkPjk4Ny4wPC90ZD4KICAgICAgPHRkPjYuMDwvdGQ+CiAgICAgIDx0ZD4xOC4wPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjExNzU4ODwvdGQ+CiAgICAgIDx0ZD4wLjEyNzYwNzwvdGQ+CiAgICAgIDx0ZD4wLjEyMjMwNTwvdGQ+CiAgICAgIDx0ZD4tMy45NzQ1NTQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MTUwODwvdGQ+CiAgICAgIDx0ZD4xLjI4MzAxNzwvdGQ+CiAgICAgIDx0ZD4wLjAwNjYxMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTY4NjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD45MTA4Ljk8L3RkPgogICAgICA8dGQ+OTE0OC44PC90ZD4KICAgICAgPHRkPjkwNzUuMjwvdGQ+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+MTY1NS4wPC90ZD4KICAgICAgPHRkPjUuMDwvdGQ+CiAgICAgIDx0ZD4xOS4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjA2MzkxNDwvdGQ+CiAgICAgIDx0ZD4wLjEwMDA5NTwvdGQ+CiAgICAgIDx0ZD4wLjA5ODQ5NzwvdGQ+CiAgICAgIDx0ZD4tNS4yMzE1OTY8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2MTY3MjwvdGQ+CiAgICAgIDx0ZD4wLjkyMzM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MjwvdGQ+CiAgICAgIDx0ZD4wLjAwNDgyNjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+OTEzNy4zPC90ZD4KICAgICAgPHRkPjkwNjEuNTwvdGQ+CiAgICAgIDx0ZD45MDgyLjk8L3RkPgogICAgICA8dGQ+MTMxNS4wPC90ZD4KICAgICAgPHRkPjQuMDwvdGQ+CiAgICAgIDx0ZD4yMC4wPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjU2ODcyODwvdGQ+CiAgICAgIDx0ZD4wLjAyMzk2MTwvdGQ+CiAgICAgIDx0ZD4wLjA2NDc3NTwvdGQ+CiAgICAgIDx0ZD4tMi4yNTMwMjg8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MDM4NzwvdGQ+CiAgICAgIDx0ZD4xLjI4MDc3NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzUyOTwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTAwMTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwNDowMDowMDwvdGg+CiAgICAgIDx0ZD45MDgzLjA8L3RkPgogICAgICA8dGQ+OTEyMy40PC90ZD4KICAgICAgPHRkPjkwNjAuMDwvdGQ+CiAgICAgIDx0ZD45MDk5Ljc8L3RkPgogICAgICA8dGQ+MTQ5Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjQ3ODcwNTwvdGQ+CiAgICAgIDx0ZD4tMC4xMTQ3NTA8L3RkPgogICAgICA8dGQ+MC4wNjk5MDk8L3RkPgogICAgICA8dGQ+LTQuNDI4MDIzPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42NjE0ODg8L3RkPgogICAgICA8dGQ+MS4zMjI5NzY8L3RkPgogICAgICA8dGQ+MC4wMDY3MTk8L3RkPgogICAgICA8dGQ+MC4wMDgyNzM8L3RkPgogICAgICA8dGQ+MC4wMDU1NDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40NjczNzM8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDYzOTM8L3RkPgogICAgICA8dGQ+MC4wMDU0ODM8L3RkPgogICAgICA8dGQ+MC4wMDM4NjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc4NzIuNzwvdGQ+CiAgICAgIDx0ZD44Nzg4MS44PC90ZD4KICAgICAgPHRkPjg3MzQyLjk8L3RkPgogICAgICA8dGQ+ODczNjEuNzwvdGQ+CiAgICAgIDx0ZD4yMzIuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMTQ1NzI8L3RkPgogICAgICA8dGQ+LTEuMTE1MjQyPC90ZD4KICAgICAgPHRkPjAuMDI2OTcyPC90ZD4KICAgICAgPHRkPi02LjMxODY5MTwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMjQ5NTAxPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA3MjA0PC90ZD4KICAgICAgPHRkPjAuMDA1NDgxPC90ZD4KICAgICAgPHRkPjAuMDAzNDI3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjg3MzUzLjU8L3RkPgogICAgICA8dGQ+ODczOTYuNzwvdGQ+CiAgICAgIDx0ZD44NjYyNy45PC90ZD4KICAgICAgPHRkPjg2Nzc2LjI8L3RkPgogICAgICA8dGQ+NTY3LjA8L3RkPgogICAgICA8dGQ+MjIuMDwvdGQ+CiAgICAgIDx0ZD4yLjA8L3RkPgogICAgICA8dGQ+MTA8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wNTQ3OTc8L3RkPgogICAgICA8dGQ+LTEuMTM5NTQ0PC90ZD4KICAgICAgPHRkPjAuMDMwMTI2PC90ZD4KICAgICAgPHRkPi00Ljk4OTM3NjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMDkyNzIwPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA1NjY4PC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA0MzY3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTc0NjE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDgxOTg8L3RkPgogICAgICA8dGQ+MC4wMDU1MDM8L3RkPgogICAgICA8dGQ+MC4wMDMwMjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTE6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44Njg3OS43PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+ODY4MTguODwvdGQ+CiAgICAgIDx0ZD41LjA8L3RkPgogICAgICA8dGQ+MjAuMDwvdGQ+CiAgICAgIDx0ZD40LjA8L3RkPgogICAgICA8dGQ+MTI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wOTQ4NTk8L3RkPgogICAgICA8dGQ+LTAuOTQzNTkzPC90ZD4KICAgICAgPHRkPjAuMDMyOTE1PC90ZD4KICAgICAgPHRkPi01LjQwNjkwMzwvdGQ+CiAgICAgIDx0ZD4mbHQ7TkEmZ3Q7PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+MC4wMDk1NTA8L3RkPgogICAgICA8dGQ+MC4wMDU0Nzg8L3RkPgogICAgICA8dGQ+MC4wMDI1ODM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD41MzIyMCByb3dzIMOXIDQ1NiBjb2x1bW5zPC9wPgo8L2Rpdj4=\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICA5MTUxLjIgICA5MTU1LjggICA5MTE1LjAgICA5MTM1LjAgIDExNzQuMCAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgOTEzNS4wICAgOTE0OS4wICAgOTEwOC44ICAgOTEwOC44ICAgOTg3LjAgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgIDkxMDguOSAgIDkxNDguOCAgIDkwNzUuMiAgIDkxMzcuMyAgMTY1NS4wICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICA5MTM3LjMgICA5MTM3LjMgICA5MDYxLjUgICA5MDgyLjkgIDEzMTUuMCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgOTA4My4wICAgOTEyMy40ICAgOTA2MC4wICAgOTA5OS43ICAxNDk2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgIDg3NzI1LjIgIDg3OTAwLjAgIDg3NjM3LjcgIDg3ODcyLjYgICAxOTUuMCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICA4Nzg3Mi43ICA4Nzg4MS44ICA4NzM0Mi45ICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgODczNTMuNSAgODczOTYuNyAgODY2MjcuOSAgODY3NzYuMiAgIDU2Ny4wICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgIDg2NzcyLjIgIDg2OTk5LjkgIDg2NTk1LjggIDg2ODc5LjcgICAxOTUuMCAgIAoyMDI1LTExLTI2IDExOjAwOjAwICA4Njg3OS43ICA4Njg3OS43ICA4NjgxOC44ICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTExLTAxIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA0ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNCAgIAoyMDE5LTExLTAxIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA0ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAxLjA4ODc3MyAgICAgICAgICAgICAgMC4xMjUwNzQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDEuMTE3NTg4ICAgICAgICAgICAgICAwLjEyNzYwNyAgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMS4wNjM5MTQgICAgICAgICAgICAgIDAuMTAwMDk1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjU2ODcyOCAgICAgICAgICAgICAgMC4wMjM5NjEgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuNDc4NzA1ICAgICAgICAgICAgIC0wLjExNDc1MCAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAxMzkwMyAgICAgICAgICAgICAtMS4xNDkzOTUgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDE0NTcyICAgICAgICAgICAgIC0xLjExNTI0MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAtMC4wNTQ3OTcgICAgICAgICAgICAgLTEuMTM5NTQ0ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjEwODAzMyAgICAgICAgICAgICAtMC45ODU5MjMgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMDk0ODU5ICAgICAgICAgICAgIC0wLjk0MzU5MyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMTIxNTI3ICAgICAgICAgICAgICAgIC00LjY5MTI5NiAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgICAgICAgICAgICAwLjEyMjMwNSAgICAgICAgICAgICAgICAtMy45NzQ1NTQgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgICAgICAgICAgICAgMC4wOTg0OTcgICAgICAgICAgICAgICAgLTUuMjMxNTk2ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDY0Nzc1ICAgICAgICAgICAgICAgIC0yLjI1MzAyOCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgICAgICAgICAgICAwLjA2OTkwOSAgICAgICAgICAgICAgICAtNC40MjgwMjMgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgIDAuMDI4MDY4ICAgICAgICAgICAgICAgIC0xLjk3MjA0MCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAwLjAyNjk3MiAgICAgICAgICAgICAgICAtNi4zMTg2OTEgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgMC4wMzAxMjYgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgIDAuMDMzNjQzICAgICAgICAgICAgICAgICA3LjEzMDI3MiAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAwLjAzMjkxNSAgICAgICAgICAgICAgICAtNS40MDY5MDMgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNTcyMDgyICAgICAgICAgIDEuMTQ0MTYzICAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQxNTA4ICAgICAgICAgIDEuMjgzMDE3ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDYxNjcyICAgICAgICAgIDAuOTIzMzQ1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQwMzg3ICAgICAgICAgIDEuMjgwNzc1ICAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjYxNDg4ICAgICAgICAgIDEuMzIyOTc2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgPE5BPiAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgTmFOICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMS0wMSAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM4NyAgICAgMC4wMDgzNjggICAgICAwLjAwNTkwMCAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY2MTAgICAgIDAuMDA4MzQ1ICAgICAgMC4wMDU2ODYgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3ODA0ICAgICAwLjAwODM2MiAgICAgIDAuMDA0ODI2ICAKMjAxOS0xMS0wMSAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzUyOSAgICAgMC4wMDgzNjEgICAgICAwLjAwNTAwMSAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY3MTkgICAgIDAuMDA4MjczICAgICAgMC4wMDU1NDYgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM5MyAgICAgMC4wMDU0ODMgICAgICAwLjAwMzg2MyAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDcyMDQgICAgIDAuMDA1NDgxICAgICAgMC4wMDM0MjcgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA1NjY4ICAgICAwLjAwNTQ5NSAgICAgIDAuMDA0MzY3ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAwLjAwODE5OCAgICAgMC4wMDU1MDMgICAgICAwLjAwMzAyMyAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDk1NTAgICAgIDAuMDA1NDc4ICAgICAgMC4wMDI1ODMgIAoKWzUzMjIwIHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\n\\\\nnan_mask_clean = combined_df_clean.isna().any(axis=1)\\\\nprint(f\\\\\\\"NaN rows after cutoff removal: {nan_mask_clean.sum()} / {combined_df_clean.shape[0]}\\\\\\\")\\\\ncombined_df_clean\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"12d0618e-4a5b-45a0-b040-8fb4aa1c38e9\\\",\\\"runStartTime\\\":1764180761320,\\\"runEndTime\\\":1764180761376,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":17,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":48,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py::request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0","content":"\"\"\"Tiered feature engineering pipeline with heavy cache and live state support.\n\nThis module reorganizes the legacy feature engineering code into three distinct\nfeature categories (stateless, rolling, and complex/grouped) and exposes a\nthree-tier caching strategy:\n\n* Tier 1 (Heavy cache): expensive grouped aggregations persisted to disk.\n* Tier 2 (Live state cache): in-memory rolling window state for incremental updates.\n* Tier 3 (On-demand row projection): combines cached state with the latest bar.\n\nQuick start (sklearn-compatible fit/transform pattern):\n\n1. **Training Phase**: Fit on historical data to build heavy cache and learn patterns::\n\n         from featureEngineer import FeatureEngineer\n\n         # Initialize with production settings\n         fe = FeatureEngineer()\n         \n         # Fit on training data (builds heavy cache, ~1-2s for 1000 rows)\n         fe.fit(historical_ohlcv_data)\n         \n         # Transform training data (reuses cache, fast)\n         training_features = fe.transform(historical_ohlcv_data)\n\n2. **Real-time Inference**: Transform new data using fitted pipeline::\n\n         # Transform single new row (target: <100ms latency)\n         new_features = fe.transform(latest_market_data)\n         \n         # Transform updated/corrected data (same performance)\n         corrected_features = fe.transform(corrected_market_data)\n\n3. **Performance**: Typical latency ~50-100ms per row for real-time inference.\n\nAdvanced usage for streaming:\n\n4. For high-frequency streaming updates, use the live state system::\n\n       live_state = fe.initialize_live_state(price_df)\n       # Append the next bar\n       next_features = fe.ingest_live_row(next_bar)\n       # Replace the latest bar with revised data\n       revised_features = fe.ingest_live_row(revised_bar)\n\nThe design targets low-fragmentation DataFrame operations while remaining fully\ncompatible with the existing offline batch workflow.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport pickle\nimport time\nimport warnings\nfrom collections import deque\nfrom contextlib import nullcontext\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Tuple\n\nimport numpy as np\nimport pandas as pd\nimport ta\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\nfrom ML_general_tools import stat_tools\nfrom data_pipeline import is_europe_dst\n\n\nHEAVY_CACHE_VERSION = 1\nDEFAULT_PREV_DAYTYPE_WINDOW = 90\nDEFAULT_EMPIRICAL_THRESHOLDS = (0.0001, 0.0005, 0.001)\nDEFAULT_EMPIRICAL_WINDOW = 90\nDEFAULT_EMPIRICAL_MIN_COUNT = 20\nHOURS_PER_YEAR = 24 * 365\n# Standard normal quantiles for 90%, 50%, and 10% (fixed z-scores)\nZ_SCORE_90 = 1.2815515655446004\nZ_SCORE_75 = 0.6744897501960817\nZ_SCORE_25 = -Z_SCORE_75\nZ_SCORE_10 = -Z_SCORE_90\n\n@dataclass\nclass HeavyFeaturePayload:\n    \"\"\"Serialized representation of complex/grouped features.\"\"\"\n\n    prev_cycle_lookup: pd.DataFrame\n    prev_cycle_stats_lookup: pd.DataFrame\n    empirical_lookup: pd.DataFrame\n    metadata: Dict[str, Any]\n\n\nclass HeavyFeatureCache:\n    \"\"\"Persist heavy feature payloads to disk with version awareness.\"\"\"\n\n    def __init__(self, cache_dir: Optional[Path]) -> None:\n        self.cache_dir = Path(cache_dir or Path(\"cache\") / \"heavy_features\")\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        self.payload: Optional[HeavyFeaturePayload] = None\n\n    @property\n    def cache_path(self) -> Path:\n        return self.cache_dir / f\"heavy_features_v{HEAVY_CACHE_VERSION}.pkl\"\n\n    def load(self) -> bool:\n        cache_path = self.cache_path\n        if not cache_path.exists():\n            return False\n        try:\n            with cache_path.open(\"rb\") as fh:\n                payload = pickle.load(fh)\n        except Exception:\n            return False\n        if not isinstance(payload, HeavyFeaturePayload):\n            return False\n        metadata = payload.metadata if isinstance(payload.metadata, dict) else {}\n        if metadata.get(\"version\") != HEAVY_CACHE_VERSION:\n            return False\n        self.payload = payload\n        return True\n\n    def save(self, payload: HeavyFeaturePayload) -> None:\n        cache_path = self.cache_path\n        with cache_path.open(\"wb\") as fh:\n            pickle.dump(payload, fh)\n        self.payload = payload\n\n\n@dataclass\nclass LiveStateCache:\n    \"\"\"Hold incremental feature state for real-time updates.\"\"\"\n\n    features_df: pd.DataFrame\n    price_history: pd.DataFrame\n    rolling_states: Dict[str, Any]\n    ema_states: Dict[str, Any]\n    metadata: Dict[str, Any]\n\n    def append(self, features_row: pd.Series, price_row: pd.Series) -> None:\n        self.features_df = pd.concat([self.features_df, features_row.to_frame().T])\n        self.price_history = pd.concat([self.price_history, price_row.to_frame().T])\n\n\n@dataclass\nclass RollingWindowState:\n    \"\"\"Maintain running statistics for a fixed-length window.\"\"\"\n\n    window: int\n    values: deque = field(default_factory=deque)\n    sum_: float = 0.0\n    sum_sq: float = 0.0\n\n    def append(self, value: float) -> None:\n        self.values.append(value)\n        self.sum_ += value\n        self.sum_sq += value * value\n        if len(self.values) > self.window:\n            old = self.values.popleft()\n            self.sum_ -= old\n            self.sum_sq -= old * old\n\n    def mean(self, min_periods: int = 1) -> float:\n        n = len(self.values)\n        if n < max(1, min_periods):\n            return float(\"nan\")\n        return self.sum_ / n\n\n    def std(self, min_periods: int = 2) -> float:\n        n = len(self.values)\n        if n < max(2, min_periods):\n            return float(\"nan\")\n        mean = self.sum_ / n\n        variance = (self.sum_sq - n * mean * mean) / max(1, n - 1)\n        variance = max(variance, 0.0)\n        return float(np.sqrt(variance))\n\n\nclass StatelessFeatureBlock:\n    \"\"\"Generate row-wise features that only require the most recent bar.\"\"\"\n\n    def __init__(self, expiration_hour: int, include_dst: bool) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_dst = include_dst\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return a DataFrame of strictly causal, per-row features.\"\"\"\n\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Stateless features require a DatetimeIndex\")\n        if df.empty:\n            return pd.DataFrame(index=df.index)\n\n        idx = df.index\n        current_time = idx + pd.Timedelta(hours=1)\n        expiry_today = current_time.normalize() + pd.Timedelta(hours=self.expiration_hour)\n        expiry_tomorrow = expiry_today + pd.Timedelta(days=1)\n        time_diff = np.where(current_time < expiry_today, expiry_today - current_time, expiry_tomorrow - current_time)\n        time_to_exp = pd.Series(\n            [float(delta / pd.Timedelta(hours=1)) for delta in time_diff],\n            index=idx,\n            dtype=\"float64\",\n        )\n        time_to_exp[np.isclose(time_to_exp, 0.0, atol=1e-9)] = 24.0\n\n        stateless = pd.DataFrame(index=idx)\n        stateless[\"time_to_exp1_hr\"] = time_to_exp\n        stateless[\"time_elapsed\"] = 24.0 - time_to_exp\n        stateless[\"hour\"] = current_time.hour\n        stateless[\"day_of_week\"] = current_time.dayofweek\n        stateless[\"is_weekend\"] = stateless[\"day_of_week\"].isin([5, 6]).astype(int)\n\n        hour_of_week = stateless[\"day_of_week\"] * 24 + stateless[\"hour\"]\n        stateless[\"hour_of_week\"] = hour_of_week\n        stateless[\"hour_of_week_sin\"] = np.sin(2 * np.pi * hour_of_week / 168)\n        stateless[\"hour_of_week_cos\"] = np.cos(2 * np.pi * hour_of_week / 168)\n        stateless[\"hours_since_week_start\"] = hour_of_week.astype(float)\n\n        stateless[\"day_type_num\"] = np.select(\n            [stateless[\"day_of_week\"] < 5, stateless[\"day_of_week\"] == 5, stateless[\"day_of_week\"] == 6],\n            [0, 1, 2],\n            default=-1,\n        )\n\n        stateless[\"prev_close\"] = df[\"c\"].shift(1)\n        if \"volCcy\" in df.columns:\n            stateless[\"volCcy_prev\"] = df[\"volCcy\"].shift(1).round()\n        else:\n            stateless[\"volCcy_prev\"] = np.nan\n\n        cycle_start_mask = ((idx + pd.Timedelta(hours=1)).hour == self.expiration_hour)\n        cycle_start_flags = cycle_start_mask.astype(int)\n        cycle_ids = cycle_start_flags.cumsum()\n        stateless[\"cycle_id\"] = cycle_ids\n\n        cycle_anchor_close = df[\"c\"].where(cycle_start_mask)\n        stateless[\"window_prev_close\"] = cycle_anchor_close.ffill()\n        stateless.loc[stateless[\"window_prev_close\"].isna(), \"window_prev_close\"] = stateless.loc[\n            stateless[\"window_prev_close\"].isna(), \"prev_close\"\n        ]\n        stateless[\"_cycle_start_ts\"] = (idx + pd.Timedelta(hours=1)).to_series().where(cycle_start_mask).ffill().values\n\n        close_shift_1 = df[\"c\"].shift(1)\n        close_shift_2 = df[\"c\"].shift(2)\n        safe_close_shift_2 = close_shift_2.replace(0, np.nan)\n\n        stateless[\"returns_1h\"] = ((close_shift_1 / safe_close_shift_2) - 1).fillna(0)\n\n        horizons = [2, 3, 4, 5, 6, 12, 24, 72]\n        for horizon in horizons:\n            denominator = df[\"c\"].shift(horizon + 1).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[f\"returns_{horizon}h\"] = (ratio - 1).fillna(0)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[f\"logret_{horizon}h\"] = np.log(ratio.replace(0, np.nan))\n\n        for window_hours, label in [(24 * 7 + 1, \"returns_1wk\"), (24 * 30 + 1, \"returns_1M\")]:\n            denominator = df[\"c\"].shift(window_hours).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[label] = (ratio - 1).fillna(0)\n\n        if {\"h\", \"l\"}.issubset(df.columns):\n            high_shift_1 = df[\"h\"].shift(1)\n            low_shift_1 = df[\"l\"].shift(1)\n            safe_low = low_shift_1.replace(0, np.nan)\n\n            stateless[\"ret_h_pc\"] = (high_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_l_pc\"] = (low_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_c_pc\"] = (close_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_h_l\"] = (high_shift_1 / safe_low) - 1\n\n            for window in [2, 3, 6, 12, 24]:\n                rolling_high = high_shift_1.rolling(window=window, min_periods=1).max()\n                rolling_low = low_shift_1.rolling(window=window, min_periods=1).min()\n                stateless[f\"range_{window}h\"] = rolling_high - rolling_low\n                stateless[f\"range_pc_{window}h\"] = (\n                    (rolling_high - rolling_low) / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n                )\n\n            trading_range = high_shift_1 - low_shift_1\n            stateless[\"range\"] = trading_range\n            stateless[\"range_pc\"] = trading_range / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            stateless[\"close_to_high\"] = (high_shift_1 - close_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            stateless[\"close_to_low\"] = (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n\n            same_high_low = high_shift_1 == low_shift_1\n            stateless.loc[same_high_low, [\"close_to_high\", \"close_to_low\"]] = 0.5\n\n            stateless[\"close_pos_in_bar\"] = (\n                (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            ).clip(0, 1)\n            stateless.loc[same_high_low, \"close_pos_in_bar\"] = 0.5\n\n            prev_close_shift_1 = stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[\"logret_h_pc\"] = np.log(high_shift_1 / prev_close_shift_1)\n                stateless[\"logret_l_pc\"] = np.log(low_shift_1 / prev_close_shift_1)\n                stateless[\"logret_c_pc\"] = np.log(close_shift_1 / prev_close_shift_1)\n\n        if self.include_dst:\n            stateless[\"is_dst\"] = is_europe_dst(idx).astype(int)\n\n        return stateless.replace([np.inf, -np.inf], np.nan)\n\n\nclass RollingFeatureBlock:\n    \"\"\"Produce fixed-window rolling statistics without duplicating logic elsewhere.\"\"\"\n\n    def __init__(self,\n                 vol_window_sizes: Iterable[int],\n                 vlm_window_sizes: Iterable[int],\n                 vol_types_to_calc: Iterable[str],\n                 vol_trading_periods: int) -> None:\n        self.vol_window_sizes = sorted(set(vol_window_sizes))\n        self.vlm_window_sizes = sorted(set(vlm_window_sizes))\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.stats = stat_tools()\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return combined trend/volatility/liquidity/relative-position features.\"\"\"\n\n        features = []\n\n        if {\"c\", \"h\", \"l\"}.issubset(df.columns):\n            features.append(self._trend_features(df))\n            features.append(self._relative_position_features(df))\n        if \"volCcy_prev\" in df.columns or \"volCcy\" in df.columns:\n            features.append(self._liquidity_features(df))\n        features.append(self._volatility_features(df))\n\n        valid = [f for f in features if f is not None and not f.empty]\n        if not valid:\n            return pd.DataFrame(index=df.index)\n        return pd.concat(valid, axis=1)\n\n    # --- Private helpers -------------------------------------------------\n\n    def _trend_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        trend_df = pd.DataFrame(index=df.index)\n        closes = df[\"c\"].shift(1)\n        \n        # Calculate trend strength features (backward z-scores)\n        # How big was the move over the last N hours relative to volatility?\n        safe_close = closes.replace(0, np.nan)\n        \n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n\n            close_w_ago = df[\"c\"].shift(w + 1).replace(0, np.nan)\n            \n            # Standard momentum (returns)\n            momentum = ((closes / close_w_ago) - 1).fillna(0)\n            trend_df[f\"momentum_{w}h\"] = momentum\n            trend_df[f\"momentum_signed_sqrt_{w}h\"] = np.sign(momentum) * np.sqrt(np.abs(momentum))\n            \n            # Trend strength: backward return / volatility (z-score of move)\n            # This normalizes the move by historical volatility\n            backward_return = np.log(safe_close / close_w_ago)\n            \n            # Use realized volatility as the denominator\n            # Get log returns for volatility calculation\n            prev_close_lag = safe_close.shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                log_ret = np.log(safe_close / prev_close_lag)\n            log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n            \n            # Rolling std (annualized volatility)\n            box_std = log_ret.rolling(w, min_periods=min_p).std()\n            \n            # Per-period std for the window length (de-annualize for the period)\n            box_std_period = box_std * np.sqrt(w)  # Adjust for window length\n            \n            # Trend strength = realized move / expected move\n            # This gives you \"how many sigmas was this move?\"\n            trend_strength = backward_return / box_std_period.replace(0, np.nan)\n            trend_df[f\"trend_strength_{w}h\"] = trend_strength.fillna(0)\n\n        try:\n            macd = ta.trend.MACD(df[\"c\"].shift(1), window_slow=26, window_fast=12, window_sign=9, fillna=True)\n            trend_df[\"macd\"] = macd.macd()\n            trend_df[\"macd_signal\"] = macd.macd_signal()\n            trend_df[\"macd_hist\"] = macd.macd_diff()\n\n            adx = ta.trend.ADXIndicator(df[\"h\"].shift(1), df[\"l\"].shift(1), df[\"c\"].shift(1), window=14, fillna=True)\n            trend_df[\"adx\"] = adx.adx()\n            trend_df[\"adx_pos\"] = adx.adx_pos()\n            trend_df[\"adx_neg\"] = adx.adx_neg()\n        except Exception:\n            for col in [\"macd\", \"macd_signal\", \"macd_hist\", \"adx\", \"adx_pos\", \"adx_neg\"]:\n                trend_df[col] = np.nan\n\n        return trend_df\n\n    def _volatility_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vol_df = pd.DataFrame(index=df.index)\n        prev_close = df[\"prev_close\"].replace(0, np.nan)\n        prev_close_lag = prev_close.shift(1).replace(0, np.nan)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log_ret = np.log(prev_close / prev_close_lag)\n        log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        for w in self.vol_window_sizes:\n            if \"raw\" in self.vol_types_to_calc:\n                min_p = max(3, w // 4)\n                vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_raw_{w}h\"] = vol.fillna(0)\n            if \"gkyz\" in self.vol_types_to_calc:\n                try:\n                    gkyz = self.stats.get_GKYZ(df, w, self.vol_trading_periods)\n                    vol_df[f\"vol_gkyz_{w}h\"] = gkyz.reindex(df.index).ffill()\n                except Exception:\n                    vol_df[f\"vol_gkyz_{w}h\"] = pd.Series(0, index=df.index)\n            if \"atr\" in self.vol_types_to_calc:\n                vol_df[f\"atr_{w}h\"] = self._calculate_atr(df, w)\n            if \"parkinson\" in self.vol_types_to_calc:\n                # Parkinson volatility: range-based estimator using only H/L\n                # Formula:  = [(1/(4*ln(2))) * mean((ln(H/L)))] * (trading_periods)\n                # More efficient than close-to-close, captures intraday volatility\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                safe_low = low_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    hl_ratio = high_shifted / safe_low\n                    log_hl = np.log(hl_ratio.replace([0, np.inf, -np.inf], np.nan))\n                    log_hl_sq = log_hl ** 2\n                \n                min_p = max(3, w // 4)\n                # Parkinson coefficient: 1/(4*ln(2))  0.3607\n                parkinson_coef = 1.0 / (4.0 * np.log(2.0))\n                mean_log_hl_sq = log_hl_sq.rolling(w, min_periods=min_p).mean()\n                vol_parkinson = np.sqrt(parkinson_coef * mean_log_hl_sq) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_parkinson_{w}h\"] = vol_parkinson.fillna(0)\n            if \"rogers_satchell\" in self.vol_types_to_calc:\n                # Rogers-Satchell volatility: drift-independent OHLC estimator\n                # Formula:  = [mean(ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O))] * (trading_periods)\n                # Superior to Parkinson as it incorporates open/close (drift info)\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                close_shifted = df[\"c\"].shift(1)\n                open_shifted = df[\"o\"].shift(1) if \"o\" in df.columns else close_shifted\n                \n                safe_close = close_shifted.replace(0, np.nan).clip(lower=1e-9)\n                safe_open = open_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    log_hc = np.log(high_shifted / safe_close)\n                    log_ho = np.log(high_shifted / safe_open)\n                    log_lc = np.log(low_shifted / safe_close)\n                    log_lo = np.log(low_shifted / safe_open)\n                    \n                    # Rogers-Satchell formula\n                    rs_component = (log_hc * log_ho) + (log_lc * log_lo)\n                    rs_component = rs_component.replace([np.inf, -np.inf], np.nan)\n                \n                min_p = max(3, w // 4)\n                mean_rs = rs_component.rolling(w, min_periods=min_p).mean()\n                # Ensure non-negative before sqrt (numerical stability)\n                vol_rs = np.sqrt(mean_rs.clip(lower=0)) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_rs_{w}h\"] = vol_rs.fillna(0)\n            if \"vol_zscore\" in self.vol_types_to_calc:\n                # Z-score of volatility: (current_vol - rolling_mean) / rolling_std\n                # Use raw volatility as base, with longer lookback for mean/std calculation\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Use 2x window for mean/std to capture volatility regime\n                zscore_window = min(w * 2, max(self.vol_window_sizes))\n                min_p_zscore = max(w, zscore_window // 2)\n                vol_ma = base_vol.rolling(zscore_window, min_periods=min_p_zscore).mean()\n                vol_std = base_vol.rolling(zscore_window, min_periods=min_p_zscore).std().replace(0, 1e-9)\n                vol_df[f\"vol_zscore_{w}h\"] = ((base_vol - vol_ma) / vol_std).fillna(0)\n            if \"log_vol\" in self.vol_types_to_calc:\n                # Log-volatility: useful for multiplicative volatility models\n                # Use raw volatility as base\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Clip to avoid log(0) and handle very small volatilities\n                vol_clipped = base_vol.clip(lower=1e-6)\n                vol_df[f\"log_vol_{w}h\"] = np.log(vol_clipped).fillna(0)\n\n        if \"skew\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=3).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=3).std()\n            centered = log_ret - ewma\n            skew_num = (centered ** 3).ewm(span=24, min_periods=3).mean()\n            vol_df[\"returns_skew_24h\"] = (skew_num / (ewmstd ** 3 + 1e-9)).fillna(0)\n\n        if \"kurtosis\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=4).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=4).std()\n            centered = log_ret - ewma\n            kurt_num = (centered ** 4).ewm(span=24, min_periods=4).mean()\n            vol_df[\"returns_kurtosis_24h\"] = (kurt_num / (ewmstd ** 4 + 1e-9) - 3).fillna(0)\n\n        def _lookup(col: str) -> Optional[pd.Series]:\n            if col in vol_df.columns:\n                return vol_df[col]\n            if col in df.columns:\n                return df[col]\n            return None\n\n        ## lets use raw vol as thats what blackscholes does and they actually got a noble prize somehow\n        vol_24 = _lookup(\"vol_raw_24h\")\n        vol_144 = _lookup(\"vol_raw_144h\")\n        vol_288 = _lookup(\"vol_raw_288h\")\n\n        vol_df[\"vol_ratio_24h_144h\"] = vol_24 / vol_144.replace(0, np.nan)\n        vol_df[\"vol_ratio_24h_288h\"] = vol_24 / vol_288.replace(0, np.nan)\n\n\n        ## essentially using pas 288 as more stable hour to predict blackscholes.\n        sigma_unit = vol_288 / np.sqrt(float(self.vol_trading_periods))\n        sigma_24h = sigma_unit * np.sqrt(24.0)\n\n        exp_ret_p90_24h = sigma_24h * Z_SCORE_90\n        exp_ret_p75_24h = sigma_24h * Z_SCORE_75\n        exp_ret_p25_24h = sigma_24h * Z_SCORE_25\n        exp_ret_p10_24h = sigma_24h * Z_SCORE_10\n\n        ## expected 24 hour moves based on blackschoels and \n        vol_df[\"exp_ret_p90_24h\"] = exp_ret_p90_24h\n        vol_df[\"exp_ret_p75_24h\"] = exp_ret_p75_24h\n        vol_df[\"exp_ret_p25_24h\"] = exp_ret_p25_24h\n        vol_df[\"exp_ret_p10_24h\"] = exp_ret_p10_24h\n\n        vol_df[\"exp_band_width_24h\"] = exp_ret_p90_24h - exp_ret_p10_24h\n        vol_df[\"exp_logmove_p90_24h\"] = np.log1p(exp_ret_p90_24h.clip(lower=-0.999999))\n        vol_df[\"exp_logmove_p10_24h\"] = np.log1p(exp_ret_p10_24h.clip(lower=-0.999999))\n\n\n\n        tte_series = df.get(\"time_to_exp1_hr\")\n        if vol_24 is not None and tte_series is not None:\n            tte_clipped = tte_series.clip(lower=1e-6)\n            with np.errstate(invalid=\"ignore\"):\n                sigma_tte = sigma_unit * np.sqrt(tte_clipped)\n                exp_ret_p90_tte = sigma_tte * Z_SCORE_90\n                exp_ret_p10_tte = sigma_tte * Z_SCORE_10\n\n            vol_df[\"exp_ret_p90_tte\"] = exp_ret_p90_tte\n            vol_df[\"exp_ret_p10_tte\"] = exp_ret_p10_tte\n            vol_df[\"exp_band_width_tte\"] = exp_ret_p90_tte - exp_ret_p10_tte\n            vol_df[\"exp_logmove_p90_tte\"] = np.log1p(exp_ret_p90_tte.clip(lower=-0.999999))\n            vol_df[\"exp_logmove_p10_tte\"] = np.log1p(exp_ret_p10_tte.clip(lower=-0.999999))\n\n\n        if \"returns_24h\" in df.columns and \"exp_band_width_24h\" in vol_df.columns:\n            band_24 = vol_df[\"exp_band_width_24h\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_24h\"] = df[\"returns_24h\"].abs() / band_24\n        if tte_series is not None and \"returns_1h\" in df.columns and \"exp_band_width_tte\" in vol_df.columns:\n            band_tte = vol_df[\"exp_band_width_tte\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_tte\"] = df[\"returns_1h\"].abs() / band_tte\n\n        return vol_df\n\n    def _liquidity_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vlm_df = pd.DataFrame(index=df.index)\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None:\n            vol_series = df[\"volCcy\"].shift(1)\n        vol_adj = vol_series.replace(0, 1e-6)\n        for w in self.vlm_window_sizes:\n            min_p = max(1, w // 2)\n            ma = vol_adj.rolling(w, min_periods=min_p).mean()\n            std = vol_adj.rolling(w, min_periods=min_p).std().replace(0, 1e-6)\n            vlm_df[f\"vlm_ma_{w}h\"] = ma\n            vlm_df[f\"vlm_zscore_{w}h\"] = (vol_adj - ma) / std\n\n        ratio_frames = []\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_168h\" in vlm_df.columns:\n            if \"vlm_ma_3h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_3h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_3h_168h\",\n                    )\n                )\n            if \"vlm_ma_6h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_6h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_6h_168h\",\n                    )\n                )\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_168h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_720h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_720h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_720h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_2160h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_2160h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_2160h\",\n                )\n            )\n\n        if ratio_frames:\n            vlm_df = pd.concat([vlm_df] + [s.to_frame() for s in ratio_frames], axis=1)\n\n        return vlm_df\n\n    def _relative_position_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        rel_df = pd.DataFrame(index=df.index)\n        high = df[\"h\"].shift(1)\n        low = df[\"l\"].shift(1)\n        close = df[\"c\"].shift(1)\n\n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n            rolling_high = high.rolling(window=w, min_periods=min_p).max()\n            rolling_low = low.rolling(window=w, min_periods=min_p).min()\n            range_w = (rolling_high - rolling_low).replace(0, np.nan)\n            rel_df[f\"stoch_pos_{w}h\"] = ((close - rolling_low) / range_w).clip(0, 1)\n            rel_df[f\"dist_from_high_{w}h\"] = (rolling_high - close) / close.replace(0, np.nan)\n            rel_df[f\"dist_from_low_{w}h\"] = (close - rolling_low) / close.replace(0, np.nan)\n            rel_df[f\"price_rank_{w}h\"] = close.rolling(w).rank(pct=True)\n\n        if 24 in self.vol_window_sizes:\n            rel_df[\"new_24h_high\"] = (high > df[\"h\"].shift(2).rolling(23).max()).astype(int)\n            rel_df[\"new_24h_low\"] = (low < df[\"l\"].shift(2).rolling(23).min()).astype(int)\n\n        return rel_df\n\n    @staticmethod\n    def _calculate_atr(df: pd.DataFrame, window: int) -> pd.Series:\n        prev_close = df[\"prev_close\"]\n        tr_components = pd.concat(\n            [\n                df[\"h\"] - df[\"l\"],\n                (df[\"h\"] - prev_close).abs(),\n                (df[\"l\"] - prev_close).abs(),\n            ],\n            axis=1,\n        )\n        tr = tr_components.max(axis=1)\n        min_p = max(1, window // 2)\n        return tr.rolling(window=window, min_periods=min_p).mean().fillna(0)\n\n\nclass ComplexFeatureBlock:\n    def __init__(self,\n                 prev_daytype_window: int,\n                 empirical_window: int,\n                 empirical_min_count: int,\n                 empirical_thresholds: Iterable[float]) -> None:\n        self.prev_daytype_window = prev_daytype_window\n        self.empirical_window = empirical_window\n        self.empirical_min_count = empirical_min_count\n        self.empirical_thresholds = list(empirical_thresholds)\n        self.expiration_hour: Optional[int] = None\n\n    def build_payload(self, df: pd.DataFrame) -> HeavyFeaturePayload:\n        if self.expiration_hour is None:\n            raise RuntimeError(\"ComplexFeatureBlock requires expiration_hour to be set\")\n        if \"time_to_exp1_hr\" not in df.columns or \"day_type_num\" not in df.columns:\n            raise ValueError(\"Complex features require time_to_exp1_hr and day_type_num columns\")\n\n        working = df.copy()\n        if \"_cycle_start_ts\" not in working.columns:\n            working[\"_cycle_start_ts\"] = df.index.to_series().where((df.index.hour == self.expiration_hour))\n\n        working = self._add_current_cycle_progress_features(working)\n        prev_cycle = self._add_prev_daytype_cycle_slice_features(working)\n        prev_cycle_stats = self._add_rolling_stats_for_prev_daytype_features(prev_cycle)\n        empirical = self._add_empirical_probability_features(prev_cycle_stats)\n\n        time_bucket = self._bucket_time_to_exp(empirical[\"time_to_exp1_hr\"])\n        empirical = empirical.assign(_tte_bucket=time_bucket)\n\n        prev_slice_cols = [col for col in empirical.columns \n                          if col.startswith(\"prev_\") \n                          and not col.endswith(\"_tte_bucket\")\n                          and col != \"prev_close\"]  # Exclude prev_close to avoid duplication\n        stats_cols = [col for col in empirical.columns if any(col.endswith(suffix) for suffix in (\"_med\", \"_p10\", \"_p90\"))]\n        empirical_cols = [col for col in empirical.columns if col.startswith(\"emp_\")]\n\n        prev_cycle_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[prev_slice_cols]\n            .median()\n            .sort_index()\n        )\n\n        prev_cycle_stats_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[stats_cols]\n            .last()\n            .sort_index()\n        )\n\n        empirical_lookup = (\n            empirical.groupby([\"hour\", \"day_type_num\"], dropna=False)[empirical_cols]\n            .last()\n            .sort_index()\n        )\n\n        metadata = {\n            \"version\": HEAVY_CACHE_VERSION,\n            \"prev_daytype_window\": self.prev_daytype_window,\n            \"empirical_window\": self.empirical_window,\n            \"empirical_thresholds\": self.empirical_thresholds,\n            \"empirical_min_count\": self.empirical_min_count,\n        }\n\n        return HeavyFeaturePayload(\n            prev_cycle_lookup=prev_cycle_lookup,\n            prev_cycle_stats_lookup=prev_cycle_stats_lookup,\n            empirical_lookup=empirical_lookup,\n            metadata=metadata,\n        )\n\n    def lookup_for_row(self, row: pd.Series, payload: HeavyFeaturePayload) -> pd.Series:\n        out_parts: List[pd.Series] = []\n        tte_bucket = self._bucket_time_to_exp(pd.Series([row[\"time_to_exp1_hr\"]])).iloc[0]\n        day_type = row.get(\"day_type_num\", np.nan)\n        hour = row.get(\"hour\", np.nan)\n\n        if not np.isnan(day_type) and not np.isnan(tte_bucket):\n            idx = (day_type, tte_bucket)\n            if idx in payload.prev_cycle_lookup.index:\n                out_parts.append(payload.prev_cycle_lookup.loc[idx])\n            if idx in payload.prev_cycle_stats_lookup.index:\n                out_parts.append(payload.prev_cycle_stats_lookup.loc[idx])\n\n        if not np.isnan(day_type) and not np.isnan(hour):\n            idx_emp = (hour, day_type)\n            if idx_emp in payload.empirical_lookup.index:\n                out_parts.append(payload.empirical_lookup.loc[idx_emp])\n\n        if not out_parts:\n            return pd.Series(dtype=\"float64\")\n        return pd.concat(out_parts)\n\n    # --- Heavy feature helpers -------------------------------------------\n\n    @staticmethod\n    def _bucket_time_to_exp(series: pd.Series, precision: int = 2) -> pd.Series:\n        return series.round(precision)\n\n    def _add_current_cycle_progress_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        prog_cols = [\"cCProgActP\", \"cCProgMinP\", \"cCProgMaxP\", \"cCProgMinT\", \"cCProgMaxT\", \"cCProgVlm\"]\n        df = df.copy()\n        df[prog_cols] = np.nan\n\n        expiry_times = df.index[df.index.hour == self.expiration_hour].sort_values()\n        for i in range(len(expiry_times)):\n            cycle_start = expiry_times[i]\n            cycle_end = expiry_times[i + 1] - pd.Timedelta(hours=1) if i + 1 < len(expiry_times) else df.index[-1]\n            cycle_mask = (df.index >= cycle_start) & (df.index <= cycle_end)\n            cycle_df = df.loc[cycle_mask]\n            if cycle_df.empty:\n                continue\n\n            prog_start_price = cycle_df.iloc[0][\"prev_close\"]\n            cum_max = cycle_df[\"h\"].expanding().max()\n            cum_min = cycle_df[\"l\"].expanding().min()\n            idxs = cycle_df.index\n            cum_max_t = cycle_df[\"h\"].expanding().apply(\n                lambda x: (idxs[x.argmax()] - cycle_start).total_seconds() // 3600\n            )\n            cum_min_t = cycle_df[\"l\"].expanding().apply(\n                lambda x: (idxs[x.argmin()] - cycle_start).total_seconds() // 3600\n            )\n            vol_series = cycle_df.get(\"volCcy_prev\")\n            if vol_series is None and \"volCcy\" in cycle_df.columns:\n                # Fallback to shifted live volume if the pre-shifted field is missing.\n                vol_series = cycle_df[\"volCcy\"].shift(1)\n            if vol_series is None:\n                vol_series = pd.Series(0.0, index=cycle_df.index)\n            cum_vlm = vol_series.fillna(0.0).cumsum()\n            prog_actp = (cycle_df[\"c\"] / prog_start_price) - 1\n            prog_maxp = (cum_max / prog_start_price) - 1\n            prog_minp = (cum_min / prog_start_price) - 1\n\n            df.loc[cycle_mask, \"cCProgActP\"] = prog_actp.values\n            df.loc[cycle_mask, \"cCProgMaxP\"] = prog_maxp.values\n            df.loc[cycle_mask, \"cCProgMinP\"] = prog_minp.values\n            df.loc[cycle_mask, \"cCProgMaxT\"] = cum_max_t.values\n            df.loc[cycle_mask, \"cCProgMinT\"] = cum_min_t.values\n            df.loc[cycle_mask, \"cCProgVlm\"] = cum_vlm.values\n\n        return df\n\n    def _add_prev_daytype_cycle_slice_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        feature_types = [\"weekday\", \"saturday\", \"sunday\"]\n        base_names = [\n            \"ProgActP\",\n            \"ProgMinP\",\n            \"ProgMaxP\",\n            \"ProgMinT\",\n            \"ProgMaxT\",\n            \"ProgVlm\",\n            \"RemActP\",\n            \"RemMinP\",\n            \"RemMaxP\",\n            \"RemMinT\",\n            \"RemMaxT\",\n        ]\n        feature_names = [f\"prev_{ftype}_{bname}\" for ftype in feature_types for bname in base_names]\n        results = pd.DataFrame(np.nan, index=df.index, columns=feature_names)\n\n        for idx, row in df.iterrows():\n            stats = self._get_prev_daytype_cycle_stats(row, df)\n            results.loc[idx] = stats\n\n        return pd.concat([df, results], axis=1)\n\n    def _get_prev_daytype_cycle_stats(self, row: pd.Series, historical_df: pd.DataFrame) -> Tuple:\n        t_now = row.name\n        time_elapsed = 24 - row.get(\"time_to_exp1_hr\", 0)\n        nan_stats = (np.nan,) * 33\n\n        def get_prev_cycle_start(ref_time: pd.Timestamp, target_dow: int) -> Optional[pd.Timestamp]:\n            for i in range(1, 8):\n                candidate = (ref_time - pd.Timedelta(days=i)).normalize() + pd.Timedelta(hours=self.expiration_hour)\n                if candidate.dayofweek == target_dow:\n                    return candidate\n            return None\n\n        daytype_map = {\"weekday\": [0, 1, 2, 3, 4], \"saturday\": [5], \"sunday\": [6]}\n        stats: List[float] = []\n        for ftype, dows in daytype_map.items():\n            prev_cycle_start = None\n            for dow in dows:\n                candidate = get_prev_cycle_start(t_now, dow)\n                if candidate is not None and candidate in historical_df.index:\n                    prev_cycle_start = candidate\n                    break\n            if prev_cycle_start is None:\n                stats.extend([np.nan] * 11)\n                continue\n\n            try:\n                prog_end = prev_cycle_start + pd.Timedelta(hours=time_elapsed - 1)\n                prog_data = historical_df.loc[prev_cycle_start:prog_end]\n                rem_start = prev_cycle_start + pd.Timedelta(hours=time_elapsed)\n                rem_end = prev_cycle_start + pd.Timedelta(hours=23)\n                rem_data = historical_df.loc[rem_start:rem_end]\n\n                if prog_data.empty:\n                    prog_stats = [0.0] * 6\n                else:\n                    prog_start_price = prog_data.iloc[0][\"prev_close\"]\n                    prog_end_price = prog_data.iloc[-1][\"c\"]\n                    prog_max = prog_data[\"h\"].max()\n                    prog_min = prog_data[\"l\"].min()\n                    prog_max_t = int((prog_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    prog_min_t = int((prog_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    vol_series = prog_data.get(\"volCcy_prev\")\n                    if vol_series is None and \"volCcy\" in prog_data.columns:\n                        vol_series = prog_data[\"volCcy\"].shift(1)\n                    if vol_series is None:\n                        vol_series = pd.Series(0.0, index=prog_data.index)\n                    prog_vlm = vol_series.fillna(0.0).sum()\n                    prog_actp = (prog_end_price / prog_start_price) - 1\n                    prog_maxp = (prog_max / prog_start_price) - 1\n                    prog_minp = (prog_min / prog_start_price) - 1\n                    prog_stats = [prog_actp, prog_minp, prog_maxp, prog_min_t, prog_max_t, prog_vlm]\n\n                if rem_data.empty:\n                    rem_stats = [np.nan] * 5\n                else:\n                    rem_start_price = rem_data.iloc[0][\"prev_close\"]\n                    rem_end_price = rem_data.iloc[-1][\"c\"]\n                    rem_max = rem_data[\"h\"].max()\n                    rem_min = rem_data[\"l\"].min()\n                    rem_max_t = int((rem_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    rem_min_t = int((rem_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    rem_actp = (rem_end_price / rem_start_price) - 1\n                    rem_maxp = (rem_max / rem_start_price) - 1\n                    rem_minp = (rem_min / rem_start_price) - 1\n                    rem_stats = [rem_actp, rem_minp, rem_maxp, rem_min_t, rem_max_t]\n\n                stats.extend(prog_stats + rem_stats)\n            except Exception:\n                stats.extend([np.nan] * 11)\n\n        if len(stats) != 33:\n            return nan_stats\n        return tuple(stats)\n\n    def _add_rolling_stats_for_prev_daytype_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        stat_cols = [\n            col\n            for col in df.columns\n            if col.startswith(\"prev_\")\n            and (\n                col.endswith(\"_ProgMaxP\")\n                or col.endswith(\"_RemMaxP\")\n                or col.endswith(\"_ProgMinP\")\n                or col.endswith(\"_RemMinP\")\n            )\n        ]\n        grouped = df.groupby([\"day_type_num\", \"time_to_exp1_hr\"], group_keys=False)\n        for col in stat_cols:\n            df[f\"{col}_med_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).median()\n            )\n            df[f\"{col}_p10_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.1)\n            )\n            df[f\"{col}_p90_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.9)\n            )\n        return df\n\n    def _add_empirical_probability_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_cols = {\"logret_h_pc\", \"logret_l_pc\"}\n        if not required_cols.issubset(df.columns):\n            raise ValueError(\"Empirical probability features require logret_h_pc and logret_l_pc\")\n\n        thresholds = self.empirical_thresholds\n        for t in thresholds:\n            df[f\"emp_freq_logret_h_pc_ge_{t}\"] = np.nan\n            df[f\"emp_freq_logret_l_pc_le_-{t}\"] = np.nan\n\n        for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n            df[f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = np.nan\n            df[f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = np.nan\n\n        df[\"emp_median_logret_range\"] = np.nan\n        if \"realized_to_expected_24h\" in df.columns:\n            df[\"emp_median_realized_to_expected_24h\"] = np.nan\n        if \"realized_to_expected_tte\" in df.columns:\n            df[\"emp_median_realized_to_expected_tte\"] = np.nan\n\n        grouped = df.groupby([\"hour\", \"day_type_num\"])\n        for (hour, day_type), group in grouped:\n            idx = group.index\n            for t in thresholds:\n                up_mask = (group[\"logret_h_pc\"] >= t).astype(float)\n                down_mask = (group[\"logret_l_pc\"] <= -t).astype(float)\n                up_prob = up_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                down_prob = down_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                df.loc[idx, f\"emp_freq_logret_h_pc_ge_{t}\"] = up_prob.values\n                df.loc[idx, f\"emp_freq_logret_l_pc_le_-{t}\"] = down_prob.values\n\n            for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n                up_pct = group[\"logret_h_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                down_pct = group[\"logret_l_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = up_pct.values\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = down_pct.values\n\n            logret_range = group[\"logret_h_pc\"] - group[\"logret_l_pc\"]\n            median_range = logret_range.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).median().shift(1)\n            df.loc[idx, \"emp_median_logret_range\"] = median_range.values\n\n            if \"realized_to_expected_24h\" in group.columns:\n                rte24 = group[\"realized_to_expected_24h\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_24h\"] = rte24.values\n\n            if \"realized_to_expected_tte\" in group.columns:\n                rtette = group[\"realized_to_expected_tte\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_tte\"] = rtette.values\n\n        return df\n\n\nclass FeatureEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"High-level orchestrator for the tiered feature pipeline.\"\"\"\n\n    def __init__(self,\n                 expiration_hour: int = 8,\n                 vol_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vlm_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vol_types_to_calc: Iterable[str] = (\"raw\", \"gkyz\", \"parkinson\", \"rogers_satchell\", \"skew\", \"kurtosis\", \"vol_zscore\", \"log_vol\"),  ## remember to manage based on rocket or catboost\n                 vol_trading_periods: int = 24 * 365,\n                 include_price: bool = False,\n                 include_trend: bool = True,\n                 include_volatility: bool = True,\n                 include_relative_position: bool = True,\n                 include_temporal: bool = True,\n                 include_liquidity: bool = True,\n                 include_non_linear: bool = True,\n                 include_custom_interactions: bool = False,\n                 include_prev_week_cycle: bool = True,\n                 include_dst_feature: bool = True,\n                 cache_dir: Optional[Path] = Path(\"cache\") / \"heavy_features\",\n                 verbose: bool = False) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_price = include_price\n        self.include_trend = include_trend\n        self.include_volatility = include_volatility\n        self.include_relative_position = include_relative_position\n        self.include_temporal = include_temporal\n        self.include_liquidity = include_liquidity\n        self.include_non_linear = include_non_linear\n        self.include_custom_interactions = include_custom_interactions\n        self.include_prev_week_cycle = include_prev_week_cycle\n        self.include_dst_feature = include_dst_feature\n        self.verbose = verbose\n        self.vol_window_sizes = list(vol_window_sizes)\n        self.vlm_window_sizes = list(vlm_window_sizes)\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.prev_daytype_window = DEFAULT_PREV_DAYTYPE_WINDOW\n        self.empirical_window = DEFAULT_EMPIRICAL_WINDOW\n        self.empirical_min_count = DEFAULT_EMPIRICAL_MIN_COUNT\n        self.empirical_thresholds = list(DEFAULT_EMPIRICAL_THRESHOLDS)\n\n        self.stateless_block = StatelessFeatureBlock(expiration_hour, include_dst_feature)\n        self.rolling_block = RollingFeatureBlock(self.vol_window_sizes,\n                                                 self.vlm_window_sizes,\n                                                 self.vol_types_to_calc,\n                                                 self.vol_trading_periods)\n        self.complex_block = ComplexFeatureBlock(self.prev_daytype_window,\n                                                 self.empirical_window,\n                                                 self.empirical_min_count,\n                                                 self.empirical_thresholds)\n        self.complex_block.expiration_hour = expiration_hour\n\n        self.heavy_cache = HeavyFeatureCache(cache_dir)\n        self.live_state = None\n        self.feature_names_out_ = None\n        self._full_reference = None\n        self._reference_features = None\n        self._heavy_payload: Optional[HeavyFeaturePayload] = None\n\n    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):\n        reference = self._prepare_reference_frame(X)\n        self._full_reference = reference\n\n        self._log(f\"fit start; rows={len(reference)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(reference, build_heavy=True)\n        self.feature_names_out_ = features.columns.tolist()\n        self._reference_features = features\n        duration = time.perf_counter() - start\n        self._log(\n            f\"fit complete; rows={len(reference)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return self\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        if self._full_reference is None:\n            raise RuntimeError(\"fit() must be called before transform().\")\n        frame = self._prepare_reference_frame(X)\n        self._log(f\"transform start; rows={len(frame)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(frame, build_heavy=False)\n        duration = time.perf_counter() - start\n        self._log(\n            f\"transform complete; rows={len(frame)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return features\n\n    # Live update API -------------------------------------------------\n    def initialize_live_state(self, historical_df: pd.DataFrame) -> LiveStateCache:\n        features = self.transform(historical_df)\n        price_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in historical_df.columns]\n        price_history = historical_df.loc[features.index, price_cols]\n        metadata = {\"max_history\": self._live_history_window()}\n        self.live_state = LiveStateCache(\n            features_df=features.copy(),\n            price_history=price_history.copy(),\n            rolling_states={},\n            ema_states={},\n            metadata=metadata,\n        )\n        return self.live_state\n\n    def compute_next_row(self, new_row: pd.Series, *, commit: bool = False) -> pd.Series:\n        self._ensure_live_state_ready()\n        if not isinstance(new_row.name, pd.Timestamp):\n            raise TypeError(\"New row must have a DatetimeIndex timestamp as its name.\")\n\n        if not self.live_state.price_history.empty:\n            last_index = self.live_state.price_history.index[-1]\n            if new_row.name <= last_index:\n                raise ValueError(\n                    f\"New row timestamp {new_row.name} must be greater than last history index {last_index}.\"\n                )\n\n        return self._append_live_row(new_row, commit=commit)\n\n    def _live_history_window(self) -> int:\n        return max(self.vol_window_sizes + self.vlm_window_sizes + [24 * 30]) + 5\n\n    def update_last_row(self, updated_row: pd.Series, *, commit: bool = True) -> pd.Series:\n        self._ensure_live_state_ready()\n        if self.live_state.price_history.empty:\n            raise RuntimeError(\"Live state history is empty; cannot update last row.\")\n        if not isinstance(updated_row.name, pd.Timestamp):\n            raise TypeError(\"Updated row must have a DatetimeIndex timestamp as its name.\")\n        last_index = self.live_state.price_history.index[-1]\n        if updated_row.name != last_index:\n            raise ValueError(\n                f\"Updated row timestamp {updated_row.name} does not match last history index {last_index}.\"\n            )\n        return self._update_live_last_row(updated_row, commit=commit)\n\n    def ingest_live_row(self, row: pd.Series, *, commit: bool = True) -> pd.Series:\n        \"\"\"Ingest a streaming bar, updating or appending as needed.\n\n        If ``row.name`` (timestamp) matches the most recent entry, the cached\n        features are recomputed for that bar. If the timestamp is newer than the\n        cached history, the bar is appended. Rows older than the last cached bar\n        raise a ``ValueError``.\n        \"\"\"\n\n        self._ensure_live_state_ready()\n        if not isinstance(row.name, pd.Timestamp):\n            raise TypeError(\"Row must have a DatetimeIndex timestamp as its name.\")\n\n        if self.live_state.price_history.empty:\n            return self._append_live_row(row, commit=commit)\n\n        last_index = self.live_state.price_history.index[-1]\n        if row.name > last_index:\n            return self._append_live_row(row, commit=commit)\n        if row.name == last_index:\n            return self._update_live_last_row(row, commit=commit)\n\n        raise ValueError(\n            f\"Row timestamp {row.name} precedes the last cached timestamp {last_index}; \"\n            \"historical backfills are not supported by ingest_live_row().\"\n        )\n\n    def _ensure_live_state_ready(self) -> None:\n        if self.live_state is None:\n            raise RuntimeError(\"Live state not initialized; call initialize_live_state() first.\")\n        if self._heavy_payload is None and self.include_prev_week_cycle:\n            if not self.heavy_cache.load():\n                raise RuntimeError(\"Heavy cache unavailable; run fit() to build heavy features.\")\n            self._heavy_payload = self.heavy_cache.payload\n\n    def _append_live_row(self, new_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_cols = self.live_state.price_history.columns\n        missing_cols = [col for col in price_cols if col not in new_row.index]\n        if missing_cols:\n            raise ValueError(f\"New row missing required columns: {missing_cols}\")\n\n        history_frame = self.live_state.price_history\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) >= max_history:\n            trimmed_history = history_frame.tail(max_history - 1)\n        else:\n            trimmed_history = history_frame\n\n        new_price_frame = new_row[price_cols].to_frame().T\n        candidate_history = pd.concat([trimmed_history, new_price_frame])\n        features = self._compute_all_features(candidate_history, build_heavy=False)\n        new_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.append(new_features, new_row[price_cols])\n        return new_features\n\n    def _update_live_last_row(self, updated_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_history = self.live_state.price_history\n        price_cols = price_history.columns\n        missing_cols = [col for col in price_cols if col not in updated_row.index]\n        if missing_cols:\n            raise ValueError(f\"Updated row missing required columns: {missing_cols}\")\n\n        last_index = price_history.index[-1]\n        history_frame = price_history.copy()\n        history_frame.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) > max_history:\n            trimmed_history = history_frame.tail(max_history)\n        else:\n            trimmed_history = history_frame\n\n        features = self._compute_all_features(trimmed_history, build_heavy=False)\n        updated_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.features_df.loc[last_index] = updated_features\n            self.live_state.price_history.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        return updated_features\n\n    # --- Internal helpers --------------------------------------------\n\n    def _prepare_reference_frame(self, df: pd.DataFrame) -> pd.DataFrame:\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must use a DatetimeIndex.\")\n        frame = df.copy()\n        if frame.index.tz is not None:\n            frame = frame.tz_localize(None)\n        if not frame.index.is_monotonic_increasing:\n            frame = frame.sort_index()\n        return frame\n\n    def _compute_all_features(self, df: pd.DataFrame, *, build_heavy: bool) -> pd.DataFrame:\n        timings: List[Tuple[str, float]] = []\n\n        suppress_warnings = not self.verbose\n        warnings_ctx = warnings.catch_warnings() if suppress_warnings else nullcontext()\n        with warnings_ctx:\n            if suppress_warnings:\n                warnings.simplefilter(\"ignore\", category=pd.errors.PerformanceWarning)\n                warnings.simplefilter(\"ignore\", category=pd.errors.SettingWithCopyWarning)\n\n            t_start = time.perf_counter()\n            stateless = self.stateless_block.compute(df)\n            timings.append((\"stateless\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = pd.concat([df, stateless], axis=1)\n            if \"volCcy\" in working.columns:\n                working[\"volCcy\"] = working[\"volCcy\"].round()\n            timings.append((\"merge_stateless\", time.perf_counter() - t_start))\n\n            if self.include_temporal:\n                t_start = time.perf_counter()\n                working = self._add_temporal_features(working)\n                timings.append((\"temporal\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            rolling = self.rolling_block.compute(working)\n            working = pd.concat([working, rolling], axis=1)\n            timings.append((\"rolling\", time.perf_counter() - t_start))\n\n            if self.include_prev_week_cycle:\n                t_start = time.perf_counter()\n                if build_heavy or self._heavy_payload is None:\n                    payload = self.complex_block.build_payload(working)\n                    self.heavy_cache.save(payload)\n                    self._heavy_payload = payload\n                else:\n                    payload = self._heavy_payload\n                heavy_df = self._render_heavy_features(working, payload)\n                working = pd.concat([working, heavy_df], axis=1)\n                timings.append((\"prev_week_cycle\", time.perf_counter() - t_start))\n\n            # Add current cycle features (fast computation, not cached)\n            t_start = time.perf_counter()\n            working = self._add_current_cycle_features(working)\n            timings.append((\"current_cycle\", time.perf_counter() - t_start))\n\n            if self.include_non_linear:\n                t_start = time.perf_counter()\n                working = self._add_non_linear_features(working)\n                timings.append((\"non_linear\", time.perf_counter() - t_start))\n            if self.include_custom_interactions:\n                t_start = time.perf_counter()\n                working = self._add_custom_interactions(working)\n                timings.append((\"custom_interactions\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = working.replace([np.inf, -np.inf], np.nan)\n            working = self._apply_feature_toggles(working)\n            working = working.copy()\n            timings.append((\"cleanup\", time.perf_counter() - t_start))\n\n            if self.verbose:\n                total = sum(duration for _, duration in timings)\n                summary = \", \".join(\n                    f\"{name}:{duration * 1000:.1f}ms\" for name, duration in timings if duration > 0.0\n                )\n                self._log(\n                    f\"feature build complete; rows={len(df)}, cols={working.shape[1]}, total={total:.2f}s [{summary}]\"\n                )\n            return working\n\n    def _log(self, message: str) -> None:\n        if self.verbose:\n            print(f\"[FeatureEngineer] {message}\")\n\n    def _render_heavy_features(self, df: pd.DataFrame, payload: HeavyFeaturePayload) -> pd.DataFrame:\n        pieces: List[pd.DataFrame] = []\n        tte_bucket = self.complex_block._bucket_time_to_exp(df[\"time_to_exp1_hr\"])\n        day_type = df[\"day_type_num\"]\n        hour = df[\"hour\"]\n\n        if not payload.prev_cycle_lookup.empty:\n            idx = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_lookup.index.names,\n            )\n            prev_cycle = payload.prev_cycle_lookup.reindex(idx)\n            prev_cycle.index = df.index\n            pieces.append(prev_cycle)\n\n        if not payload.prev_cycle_stats_lookup.empty:\n            idx_stats = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_stats_lookup.index.names,\n            )\n            stats_df = payload.prev_cycle_stats_lookup.reindex(idx_stats)\n            stats_df.index = df.index\n            pieces.append(stats_df)\n\n        if not payload.empirical_lookup.empty:\n            idx_emp = pd.MultiIndex.from_arrays(\n                [hour.values, day_type.values],\n                names=payload.empirical_lookup.index.names,\n            )\n            emp_df = payload.empirical_lookup.reindex(idx_emp)\n            emp_df.index = df.index\n            pieces.append(emp_df)\n\n        if not pieces:\n            return pd.DataFrame(index=df.index)\n        heavy_df = pd.concat(pieces, axis=1)\n        return heavy_df\n\n    def _apply_feature_toggles(self, df: pd.DataFrame) -> pd.DataFrame:\n        result = df\n\n        if not self.include_price:\n            drop_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in result.columns]\n            result = result.drop(columns=drop_cols)\n        if not self.include_trend:\n            #trend_prefixes = (\"sma_\", \"ema_\", \"momentum_\", \"macd\", \"adx\")  # dont want sma and ema in features as they are prices \n            trend_prefixes = (\"momentum_\", \"macd\", \"adx\")\n            trend_cols = [col for col in result.columns if col.startswith(trend_prefixes)]\n            result = result.drop(columns=trend_cols, errors=\"ignore\")\n        if not self.include_volatility:\n            vol_prefixes = (\"vol_\", \"returns_skew\", \"returns_kurtosis\", \"atr_\", \"log_vol_\")\n            vol_cols = [col for col in result.columns if col.startswith(vol_prefixes)]\n            result = result.drop(columns=vol_cols, errors=\"ignore\")\n        if not self.include_relative_position:\n            rel_prefixes = (\"stoch_pos_\", \"dist_from_\", \"price_rank_\", \"new_24h\")\n            rel_cols = [col for col in result.columns if col.startswith(rel_prefixes)]\n            result = result.drop(columns=rel_cols, errors=\"ignore\")\n        if not self.include_liquidity:\n            vlm_cols = [col for col in result.columns if col.startswith(\"vlm_\")]\n            result = result.drop(columns=vlm_cols, errors=\"ignore\")\n        if not self.include_temporal:\n            temporal_cols = [col for col in [\"tte_phase_cos\", \"tte_phase_sin\", \"is_dst\"] if col in result.columns]\n            result = result.drop(columns=temporal_cols, errors=\"ignore\")\n        helper_cols = [col for col in [\"cycle_id\", \"_cycle_start_ts\", \"_tte_bucket\"] if col in result.columns]\n        if helper_cols:\n            result = result.drop(columns=helper_cols, errors=\"ignore\")\n        return result\n\n    def _add_temporal_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        df = df.copy()\n        tte = df[\"time_to_exp1_hr\"]\n        df[\"tte_phase_cos\"] = np.cos(2 * np.pi * tte / 24)\n        df[\"tte_phase_sin\"] = np.sin(2 * np.pi * tte / 24)\n        return df\n\n    def _add_non_linear_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_base = {\"c\", \"h\", \"l\"}\n        if not required_base.issubset(df.columns):\n            return df\n\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None and \"volCcy\" in df.columns:\n            vol_series = df[\"volCcy\"].shift(1)\n        if vol_series is None:\n            return df\n\n        working = df.copy()\n        if \"volCcy_prev\" not in working.columns:\n            working[\"volCcy_prev\"] = vol_series\n        if \"vol_gkyz_24h\" not in working.columns:\n            working[\"vol_gkyz_24h\"] = 0.0\n        if \"vlm_ma_24h\" not in working.columns:\n            working[\"vlm_ma_24h\"] = vol_series.rolling(24, min_periods=1).mean()\n\n        working = self._add_vol_volume_interactions(working)\n        working = self._add_higher_order_momentum(working)\n        working = self._add_non_linear_range_features(working)\n        working = self._add_liquidity_shock_features(working, vol_series)\n        working = self._add_time_decay_features(working)\n        working = self._add_tail_specific_features(working)\n        working = self._add_time_to_expiry_interactions(working)\n        return working\n\n    def _add_time_to_expiry_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes scaling: t\n        \n        key_features = [\n            \"vol_gkyz_24h\",\n            \"vlm_ma_24h\",\n            \"returns_kurtosis_24h\",\n            \"returns_skew_24h\",\n            \"extreme_prob\",\n            \"vol_clustering\",\n            \"exp_ret_p90_24h\",\n            \"exp_ret_p10_24h\",\n            \"exp_band_width_24h\",\n            \"exp_ret_p90_tte\",\n            \"exp_ret_p10_tte\",\n            \"exp_band_width_tte\",\n        ]\n        for feat in key_features:\n            if feat in df.columns:\n                # Black-Scholes t scaling (most important for volatility)\n                df[f\"{feat}_x_tte_sqrt\"] = df[feat] * tte_sqrt\n                # Linear scaling (for non-vol features)\n                df[f\"{feat}_x_tte\"] = df[feat] * tte\n                # Higher order terms for capturing non-linear time decay\n                df[f\"{feat}_x_tte_sq\"] = df[feat] * (tte ** 2)\n                df[f\"{feat}_x_tte_cu\"] = df[feat] * (tte ** 3)\n        return df\n\n    def _add_vol_volume_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        cols = [\"vol_gkyz_24h\", \"vlm_ma_24h\", \"returns_1h\"]\n        if not all(col in df.columns for col in cols):\n            return df\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"vol_weighted_vol\"] = safe_vol * np.log1p(safe_vlm)\n        df[\"vol_vlm_ratio_change\"] = (safe_vol / safe_vlm).pct_change().fillna(0)\n        df[\"asym_vol_vlm_impact\"] = np.sign(df[\"returns_1h\"]) * (safe_vol ** 2) * np.sqrt(safe_vlm)\n        return df\n\n    def _add_current_cycle_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add current cycle progress features to transform pipeline.\n        \n        Fast computation of current cycle state for 'where we are now' context.\n        Complements previous cycle features with current positioning.\n        \"\"\"\n        # Only compute if we have the required OHLC data\n        required_cols = [\"h\", \"l\", \"c\", \"prev_close\"]\n        if not all(col in df.columns for col in required_cols):\n            if self.verbose:\n                missing = [col for col in required_cols if col not in df.columns]\n                print(f\"Skipping current cycle features - missing columns: {missing}\")\n            return df\n        \n        return self.complex_block._add_current_cycle_progress_features(df)\n\n    def _add_higher_order_momentum(self, df: pd.DataFrame) -> pd.DataFrame:\n        for w in [6, 12, 24]:\n            col = f\"momentum_{w}h\"\n            if col in df.columns:\n                df[f\"momentum_accel_{w}h\"] = df[col] * df[col].diff()\n        if \"momentum_24h\" in df.columns:\n            momentum_24 = df[\"momentum_24h\"]\n            df[\"signed_momentum_power\"] = np.sign(momentum_24) * np.abs(momentum_24) ** 1.5\n            if \"vol_gkyz_24h\" in df.columns:\n                df[\"mom_vol_interaction\"] = momentum_24 * df[\"vol_gkyz_24h\"].rolling(6, min_periods=1).std()\n        return df\n\n    def _add_non_linear_range_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"range_pc\" not in df.columns:\n            df[\"range_pc\"] = (df[\"h\"].shift(1) - df[\"l\"].shift(1)) / df[\"prev_close\"].replace(0, np.nan)\n        if \"vol_gkyz_24h\" not in df.columns:\n            df[\"vol_gkyz_24h\"] = 0.0\n        if \"close_pos_in_bar\" not in df.columns:\n            range_bar = df[\"h\"].shift(1) - df[\"l\"].shift(1)\n            df[\"close_pos_in_bar\"] = np.where(\n                range_bar.abs() > 1e-9,\n                (df[\"c\"].shift(1) - df[\"l\"].shift(1)) / range_bar,\n                0.5,\n            )\n\n        range_pc = df[\"range_pc\"]\n        vol_24 = df[\"vol_gkyz_24h\"]\n        close_pos = df[\"close_pos_in_bar\"].clip(0, 1)\n        range_ma = range_pc.rolling(24, min_periods=1).mean().clip(lower=1e-9)\n        df[\"compressed_range_vol\"] = np.sqrt(range_pc.clip(lower=0)) * vol_24\n        df[\"range_expansion\"] = (range_pc / range_ma) ** 2\n        df[\"nl_pos_in_range\"] = np.sin(np.pi * close_pos) * vol_24\n        return df\n\n    def _add_liquidity_shock_features(self, df: pd.DataFrame, vol_series: pd.Series) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"vlm_ma_24h\"}\n        if not required.issubset(df.columns):\n            return df\n\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        df[\"volume_surprise\"] = (vol_series - df[\"vlm_ma_24h\"]) / (safe_vlm * safe_vol)\n        df[\"liq_vol\"] = vol_series.rolling(6, min_periods=2).std() / safe_vlm\n        df[\"liq_vol_ratio_change\"] = (safe_vlm / safe_vol).pct_change().rolling(6, min_periods=2).mean()\n        trend_std = safe_vlm.rolling(24, min_periods=5).std().clip(lower=1e-6)\n        df[\"volume_trend_z\"] = (vol_series - safe_vlm) / trend_std\n        return df\n\n    def _add_time_decay_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"returns_1h\" in df.columns:\n            returns = df[\"returns_1h\"]\n            for w in [6, 12, 24]:\n                weights = np.exp(-np.linspace(0, 1, w))\n                weights /= weights.sum()\n                df[f\"exp_decay_ret_{w}h\"] = returns.rolling(w).apply(\n                    lambda x, wts=weights[::-1]: float(np.dot(x, wts)), raw=True\n                )\n        if \"vol_gkyz_24h\" in df.columns and \"time_to_exp1_hr\" in df.columns:\n            df[\"time_adj_vol\"] = df[\"vol_gkyz_24h\"] * (1 + df[\"time_to_exp1_hr\"] / 24)\n        if {\"vol_gkyz_24h\", \"tte_phase_sin\", \"tte_phase_cos\"}.issubset(df.columns):\n            df[\"cyclical_vol_compression\"] = (\n                df[\"tte_phase_sin\"] * df[\"vol_gkyz_24h\"] +\n                df[\"tte_phase_cos\"] * df[\"vol_gkyz_24h\"].diff()\n            )\n        return df\n\n    def _add_tail_specific_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"returns_kurtosis_24h\", \"returns_skew_24h\"}\n        if not required.issubset(df.columns):\n            return df\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"extreme_prob\"] = (\n            df[\"returns_kurtosis_24h\"] * df[\"returns_skew_24h\"] * safe_vol\n        ).rolling(12, min_periods=3).mean()\n        df[\"vol_clustering\"] = (df[\"vol_gkyz_24h\"].diff() > 0).rolling(24, min_periods=6).sum() * safe_vol\n        return df\n\n    def _add_custom_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        def safe_div(a: pd.Series, b: pd.Series, eps: float = 1e-8) -> pd.Series:\n            denom = b.replace(0, np.nan).fillna(eps)\n            return a / denom\n\n        # Original interactions\n        if {\"pWRemMaxP_p90_vs_median_spread\", \"vol_gkyz_24h_x_tte\"}.issubset(df.columns):\n            df[\"pWRem_spread_to_vol\"] = safe_div(\n                df[\"pWRemMaxP_p90_vs_median_spread\"],\n                df[\"vol_gkyz_24h_x_tte\"].abs() + 1e-6,\n            )\n        if {\"cWProgMaxP_vs_p90_upside\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"progmax_vs_vol\"] = safe_div(df[\"cWProgMaxP_vs_p90_upside\"], df[\"vol_gkyz_24h\"].abs() + 1e-6)\n        if {\"returns_1h\", \"vol_gkyz_24h\", \"vlm_ma_24h\"}.issubset(df.columns):\n            df[\"shock_absorption\"] = df[\"returns_1h\"] * safe_div(df[\"vol_gkyz_24h\"], df[\"vlm_ma_24h\"])\n        \n        # Critical new interactions for direct target optimization\n        df = self._add_tte_volatility_interactions(df)\n        df = self._add_weekend_regime_interactions(df)\n        df = self._add_cycle_progress_interactions(df) \n        df = self._add_extreme_event_interactions(df)\n        \n        return df\n    \n    def _add_tte_volatility_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add time-to-expiry  volatility interactions crucial for return prediction\"\"\"\n        \n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n            \n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes: t\n        tte_normalized = tte / 168  # Normalize by week\n        \n        # Core TTE  volatility combinations\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\", \"vol_gkyz_288h\",\n                       \"vol_raw_24h\", \"vol_raw_288h\"]  # Include raw vol for consistency\n        \n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                # Black-Scholes t scaling (PRIMARY for volatility  expected move)\n                df[f\"{vol_feat}_x_tte_sqrt\"] = df[vol_feat] * tte_sqrt\n                \n                # Linear TTE (for regime/level effects)\n                df[f\"{vol_feat}_x_tte\"] = df[vol_feat] * tte\n                \n                # Squared TTE (for strong time decay near expiry)\n                df[f\"{vol_feat}_x_tte_sq\"] = df[vol_feat] * (tte_normalized ** 2)\n                \n                # Cyclical TTE effects (captures intraday patterns)\n                if \"tte_phase_sin\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_sin\"] = df[vol_feat] * df[\"tte_phase_sin\"]\n                if \"tte_phase_cos\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_cos\"] = df[vol_feat] * df[\"tte_phase_cos\"]\n        \n        # Volatility term structure  TTE (all three scalings)\n        if {\"vol_gkyz_3h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            vol_term_slope = df[\"vol_gkyz_24h\"] - df[\"vol_gkyz_3h\"]\n            df[\"vol_term_x_tte_sqrt\"] = vol_term_slope * tte_sqrt  # Black-Scholes scaling\n            df[\"vol_term_x_tte\"] = vol_term_slope * tte\n            df[\"vol_term_x_tte_sq\"] = vol_term_slope * (tte_normalized ** 2)\n        \n        return df\n    \n    def _add_weekend_regime_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add weekend/weekday regime-specific interactions\"\"\"\n        \n        if \"is_weekend\" not in df.columns:\n            return df\n            \n        # Weekend-specific volatility behavior\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                df[f\"{vol_feat}_weekend\"] = df[vol_feat] * df[\"is_weekend\"]\n                df[f\"{vol_feat}_weekday\"] = df[vol_feat] * (1 - df[\"is_weekend\"])\n        \n        # Weekend  previous cycle progress (leveraging historical weekend patterns)\n        prev_weekend_cycles = ['prev_saturday', 'prev_sunday'] \n        prev_cycle_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        \n        for weekend_cycle in prev_weekend_cycles:\n            for metric in prev_cycle_metrics:\n                prev_feat = f\"{weekend_cycle}_{metric}\"\n                if prev_feat in df.columns:\n                    df[f\"{prev_feat}_weekend\"] = df[prev_feat] * df[\"is_weekend\"]\n        \n        # Weekend  volume effects\n        if \"vlm_ma_24h\" in df.columns:\n            df[\"volume_weekend_effect\"] = df[\"vlm_ma_24h\"] * df[\"is_weekend\"]\n        \n        return df\n        \n    def _add_cycle_progress_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add previous cycle progress  market condition interactions\n        \n        Note: Uses 'prev_' cycle features (weekday/saturday/sunday) which track \n        complete historical cycles, not current incomplete cycle progress.\n        This is superior for prediction as it uses complete cycle information.\n        \"\"\"\n        \n        # Previous cycle progress features (complete historical cycles)\n        prev_cycle_types = ['prev_weekday', 'prev_saturday', 'prev_sunday']\n        prog_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        vol_features = [\"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        \n        # Previous cycle progress  volatility interactions\n        for cycle_type in prev_cycle_types:\n            for prog_metric in prog_metrics:\n                prog_feature = f\"{cycle_type}_{prog_metric}\"\n                if prog_feature in df.columns:\n                    for vol_feat in vol_features:\n                        if vol_feat in df.columns:\n                            # Use simpler naming pattern to match existing interactions\n                            interaction_name = f\"{prog_feature}_x_{vol_feat.replace('vol_gkyz_', 'vol')}\"\n                            df[interaction_name] = df[prog_feature] * df[vol_feat]\n        \n        # Previous cycle range  volatility (more stable than current cycle)\n        for cycle_type in prev_cycle_types:\n            max_feat = f\"{cycle_type}_ProgMaxP\"\n            min_feat = f\"{cycle_type}_ProgMinP\"\n            if {max_feat, min_feat, \"vol_gkyz_12h\"}.issubset(df.columns):\n                cycle_range = df[max_feat] - df[min_feat]\n                df[f\"{cycle_type}_range_x_vol\"] = cycle_range * df[\"vol_gkyz_12h\"]\n        \n        # Cross-regime cycle comparisons (weekday vs weekend behavior)\n        if {\"prev_weekday_ProgActP\", \"prev_saturday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_saturday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_saturday_ProgActP\"]\n        \n        if {\"prev_weekday_ProgActP\", \"prev_sunday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_sunday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_sunday_ProgActP\"]\n        \n        # Previous cycle activity  time effects\n        if {\"prev_weekday_ProgActP\", \"hour_of_week_sin\"}.issubset(df.columns):\n            df[\"prev_cycle_progress_x_hour\"] = df[\"prev_weekday_ProgActP\"] * df[\"hour_of_week_sin\"]\n            \n        return df\n    \n    def _add_extreme_event_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add interactions specifically designed for extreme event prediction\"\"\"\n        \n        # Compressed range  volatility for tail events\n        if {\"compressed_range_vol\", \"vol_gkyz_3h\"}.issubset(df.columns):\n            df[\"extreme_range_vol\"] = df[\"compressed_range_vol\"] * df[\"vol_gkyz_3h\"]\n        \n        # Skewness  volatility for asymmetric moves\n        if {\"returns_skew_24h\", \"vol_gkyz_6h\"}.issubset(df.columns):\n            df[\"skew_vol_extreme\"] = df[\"returns_skew_24h\"] * df[\"vol_gkyz_6h\"]\n        \n        # Kurtosis  volatility for fat-tail events\n        if {\"returns_kurtosis_24h\", \"vol_gkyz_12h\"}.issubset(df.columns):\n            df[\"kurtosis_vol_extreme\"] = df[\"returns_kurtosis_24h\"] * df[\"vol_gkyz_12h\"]\n        \n        # Distance from highs  volatility for reversal prediction\n        if {\"dist_from_high_144h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"distance_vol_extreme\"] = df[\"dist_from_high_144h\"] * df[\"vol_gkyz_24h\"]\n        \n        # Volume surprise  volatility clustering\n        if {\"volume_surprise\", \"vol_clustering\"}.issubset(df.columns):\n            df[\"vol_surprise_clustering\"] = df[\"volume_surprise\"] * df[\"vol_clustering\"]\n            \n        return df\n","epoch":52,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_12a6e73d-b33c-4750-899a-23b3790b61ab",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_12a6e73d-b33c-4750-899a-23b3790b61ab","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":20,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"39c9d8e5-7b7b-4cef-bbd1-36bef455dfff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"957df78c-8e58-4b2b-a850-5a7c258f1de4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"8289a205-2f21-4755-8d5c-52f78aa08186\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjcwcyBbc3RhdGVsZXNzOjI1MC4ybXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTMuMm1zLCByb2xsaW5nOjY1Mi4zbXMsIHByZXZfd2Vla19jeWNsZTo0Ni43bXMsIGN1cnJlbnRfY3ljbGU6OTI5NC4wbXMsIG5vbl9saW5lYXI6MjQ5LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy45bXMsIGNsZWFudXA6MTY2LjRtc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC43MXMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM1MS4wM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzUxLjAzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":20,\\\"executionId\\\":\\\"2437fd19-fa6b-4462-bb05-1c7f2dcfb249\\\",\\\"runStartTime\\\":1764181303307,\\\"runEndTime\\\":1764182000332,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":22,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"68affb76-e55e-499e-a125-82d3835cf62f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = True  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"04e86cbb-66d4-4a7d-b484-0992182967e2\\\",\\\"runStartTime\\\":1764182014900,\\\"runEndTime\\\":1764182015339,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":22,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":23,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"9b361830-a6b3-4499-91ab-9ccf0481937c\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ab02104d-8695-4b1a-8120-ef06ae1687cf\\\",\\\"runStartTime\\\":1764182020408,\\\"runEndTime\\\":1764182020445,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":23,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":19,\\\"id\\\":\\\"15b86f8a\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"c0f2fd7d-3a82-4434-85e2-86d008c8708e\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpJbnZlc3RpZ2F0aW5nIE1pZGRsZSBOYU5zIGluIFN0b2NoYXN0aWMgRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKU3RvY2hhc3RpYyBmZWF0dXJlczogWydzdG9jaF9wb3NfM2gnLCAnc3RvY2hfcG9zXzZoJywgJ3N0b2NoX3Bvc18xMmgnLCAnc3RvY2hfcG9zXzI0aCcsICdzdG9jaF9wb3NfNzJoJywgJ3N0b2NoX3Bvc18xNDRoJywgJ3N0b2NoX3Bvc18yODhoJ10KClRvdGFsIE5hTnMgaW4gc3RvY2hfcG9zXzNoOiAxNzMKCkRhdGUgcmFuZ2Ugb2YgTmFOIG9jY3VycmVuY2VzOgogIEZpcnN0IE5hTjogMjAxOS0xMC0wMSAwMDowMDowMAogIExhc3QgTmFOOiAyMDIyLTEyLTE4IDE4OjAwOjAwCgpTYW1wbGUgTmFOIHBlcmlvZHMgKHNob3dpbmcgMTAgcmFuZG9tIHNhbXBsZXMpOgogIDIwMjAtMDEtMDggMDU6MDA6MDAKICAyMDIwLTAxLTA0IDE5OjAwOjAwCiAgMjAyMC0wMS0wNSAxNjowMDowMAogIDIwMjAtMDEtMDYgMDE6MDA6MDAKICAyMDIwLTAxLTA4IDEwOjAwOjAwCiAgMjAyMC0wMS0wNCAxMzowMDowMAogIDIwMTktMTAtMDEgMDA6MDA6MDAKICAyMDIwLTAxLTA3IDA2OjAwOjAwCiAgMjAyMC0wMS0wMyAxNTowMDowMAogIDIwMjAtMDEtMDkgMTY6MDA6MDAKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KQ2hlY2tpbmcgaWYgTmFOcyBjb2luY2lkZSB3aXRoIGZsYXQgcHJpY2UgcGVyaW9kcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"d10db76a-7375-4de2-9f18-3355df93746b\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"error\\\",\\\"originalError\\\":{\\\"output_type\\\":\\\"error\\\",\\\"ename\\\":\\\"KeyError\\\",\\\"evalue\\\":\\\"\\\\\\\"None of [Index(['high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"traceback\\\":[\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\",\\\"\\\\u001b[31mKeyError\\\\u001b[39m                                  Traceback (most recent call last)\\\",\\\"\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[19]\\\\u001b[39m\\\\u001b[32m, line 43\\\\u001b[39m\\\\n\\\\u001b[32m     40\\\\u001b[39m window_start = nan_time - pd.Timedelta(hours=\\\\u001b[32m3\\\\u001b[39m)\\\\n\\\\u001b[32m     41\\\\u001b[39m window_end = nan_time\\\\n\\\\u001b[32m---> \\\\u001b[39m\\\\u001b[32m43\\\\u001b[39m window_data = \\\\u001b[43mraw_history\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mloc\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[43mwindow_start\\\\u001b[49m\\\\u001b[43m:\\\\u001b[49m\\\\u001b[43mwindow_end\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mhigh\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mlow\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mclose\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m]\\\\u001b[49m\\\\u001b[43m]\\\\u001b[49m\\\\n\\\\u001b[32m     45\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mlen\\\\u001b[39m(window_data) > \\\\u001b[32m0\\\\u001b[39m:\\\\n\\\\u001b[32m     46\\\\u001b[39m     price_range = window_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m].max() - window_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m].min()\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1185\\\\u001b[39m, in \\\\u001b[36m_LocationIndexer.__getitem__\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m   1183\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._is_scalar_access(key):\\\\n\\\\u001b[32m   1184\\\\u001b[39m         \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_value(*key, takeable=\\\\u001b[38;5;28mself\\\\u001b[39m._takeable)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1185\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_tuple\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1186\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   1187\\\\u001b[39m     \\\\u001b[38;5;66;03m# we by definition only have the 0th axis\\\\u001b[39;00m\\\\n\\\\u001b[32m   1188\\\\u001b[39m     axis = \\\\u001b[38;5;28mself\\\\u001b[39m.axis \\\\u001b[38;5;129;01mor\\\\u001b[39;00m \\\\u001b[32m0\\\\u001b[39m\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1378\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_tuple\\\\u001b[39m\\\\u001b[34m(self, tup)\\\\u001b[39m\\\\n\\\\u001b[32m   1375\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._multi_take_opportunity(tup):\\\\n\\\\u001b[32m   1376\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._multi_take(tup)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1378\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_tuple_same_dim\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mtup\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1021\\\\u001b[39m, in \\\\u001b[36m_LocationIndexer._getitem_tuple_same_dim\\\\u001b[39m\\\\u001b[34m(self, tup)\\\\u001b[39m\\\\n\\\\u001b[32m   1018\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m com.is_null_slice(key):\\\\n\\\\u001b[32m   1019\\\\u001b[39m     \\\\u001b[38;5;28;01mcontinue\\\\u001b[39;00m\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1021\\\\u001b[39m retval = \\\\u001b[38;5;28;43mgetattr\\\\u001b[39;49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mretval\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mname\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_axis\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43mi\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1022\\\\u001b[39m \\\\u001b[38;5;66;03m# We should never have retval.ndim < self.ndim, as that should\\\\u001b[39;00m\\\\n\\\\u001b[32m   1023\\\\u001b[39m \\\\u001b[38;5;66;03m#  be handled by the _getitem_lowerdim call above.\\\\u001b[39;00m\\\\n\\\\u001b[32m   1024\\\\u001b[39m \\\\u001b[38;5;28;01massert\\\\u001b[39;00m retval.ndim == \\\\u001b[38;5;28mself\\\\u001b[39m.ndim\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1421\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_axis\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1418\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mhasattr\\\\u001b[39m(key, \\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mndim\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m) \\\\u001b[38;5;129;01mand\\\\u001b[39;00m key.ndim > \\\\u001b[32m1\\\\u001b[39m:\\\\n\\\\u001b[32m   1419\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mValueError\\\\u001b[39;00m(\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mCannot index with multidimensional key\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1421\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_iterable\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1423\\\\u001b[39m \\\\u001b[38;5;66;03m# nested tuple slicing\\\\u001b[39;00m\\\\n\\\\u001b[32m   1424\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m is_nested_tuple(key, labels):\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1361\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_iterable\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1358\\\\u001b[39m \\\\u001b[38;5;28mself\\\\u001b[39m._validate_key(key, axis)\\\\n\\\\u001b[32m   1360\\\\u001b[39m \\\\u001b[38;5;66;03m# A collection of keys\\\\u001b[39;00m\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1361\\\\u001b[39m keyarr, indexer = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_listlike_indexer\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1362\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m.obj._reindex_with_indexers(\\\\n\\\\u001b[32m   1363\\\\u001b[39m     {axis: [keyarr, indexer]}, copy=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m, allow_dups=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m\\\\n\\\\u001b[32m   1364\\\\u001b[39m )\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1559\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._get_listlike_indexer\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1556\\\\u001b[39m ax = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis(axis)\\\\n\\\\u001b[32m   1557\\\\u001b[39m axis_name = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis_name(axis)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1559\\\\u001b[39m keyarr, indexer = \\\\u001b[43max\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_indexer_strict\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1561\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m keyarr, indexer\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6212\\\\u001b[39m, in \\\\u001b[36mIndex._get_indexer_strict\\\\u001b[39m\\\\u001b[34m(self, key, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6209\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   6210\\\\u001b[39m     keyarr, indexer, new_indexer = \\\\u001b[38;5;28mself\\\\u001b[39m._reindex_non_unique(keyarr)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6212\\\\u001b[39m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_raise_if_missing\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkeyarr\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   6214\\\\u001b[39m keyarr = \\\\u001b[38;5;28mself\\\\u001b[39m.take(indexer)\\\\n\\\\u001b[32m   6215\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, Index):\\\\n\\\\u001b[32m   6216\\\\u001b[39m     \\\\u001b[38;5;66;03m# GH 42790 - Preserve name from an Index\\\\u001b[39;00m\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6261\\\\u001b[39m, in \\\\u001b[36mIndex._raise_if_missing\\\\u001b[39m\\\\u001b[34m(self, key, indexer, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6259\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing:\\\\n\\\\u001b[32m   6260\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing == \\\\u001b[38;5;28mlen\\\\u001b[39m(indexer):\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6261\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mNone of [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mkey\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m] are in the [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00maxis_name\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m]\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m   6263\\\\u001b[39m     not_found = \\\\u001b[38;5;28mlist\\\\u001b[39m(ensure_index(key)[missing_mask.nonzero()[\\\\u001b[32m0\\\\u001b[39m]].unique())\\\\n\\\\u001b[32m   6264\\\\u001b[39m     \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mnot_found\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m not in index\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\",\\\"\\\\u001b[31mKeyError\\\\u001b[39m: \\\\\\\"None of [Index(['high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\"]}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ewoJIm5hbWUiOiAiS2V5RXJyb3IiLAoJIm1lc3NhZ2UiOiAiXCJOb25lIG9mIFtJbmRleChbJ2hpZ2gnLCAnbG93JywgJ2Nsb3NlJ10sIGR0eXBlPSdvYmplY3QnKV0gYXJlIGluIHRoZSBbY29sdW1uc11cIiIsCgkic3RhY2siOiAiXHUwMDFiWzMxbS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx1MDAxYlszOW1cblx1MDAxYlszMW1LZXlFcnJvclx1MDAxYlszOW0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpXG5cdTAwMWJbMzZtQ2VsbFx1MDAxYlszOW1cdTAwMWJbMzZtIFx1MDAxYlszOW1cdTAwMWJbMzJtSW5bMTldXHUwMDFiWzM5bVx1MDAxYlszMm0sIGxpbmUgNDNcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgICA0MFx1MDAxYlszOW0gd2luZG93X3N0YXJ0ID0gbmFuX3RpbWUgLSBwZC5UaW1lZGVsdGEoaG91cnM9XHUwMDFiWzMybTNcdTAwMWJbMzltKVxuXHUwMDFiWzMybSAgICAgNDFcdTAwMWJbMzltIHdpbmRvd19lbmQgPSBuYW5fdGltZVxuXHUwMDFiWzMybS0tLT4gXHUwMDFiWzM5bVx1MDAxYlszMm00M1x1MDAxYlszOW0gd2luZG93X2RhdGEgPSBcdTAwMWJbNDNtcmF3X2hpc3RvcnlcdTAwMWJbNDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbWxvY1x1MDAxYls0OW1cdTAwMWJbNDNtW1x1MDAxYls0OW1cdTAwMWJbNDNtd2luZG93X3N0YXJ0XHUwMDFiWzQ5bVx1MDAxYls0M206XHUwMDFiWzQ5bVx1MDAxYls0M213aW5kb3dfZW5kXHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYls0M21bXHUwMDFiWzQ5bVx1MDAxYlszMzs0M20nXHUwMDFiWzM5OzQ5bVx1MDAxYlszMzs0M21oaWdoXHUwMDFiWzM5OzQ5bVx1MDAxYlszMzs0M20nXHUwMDFiWzM5OzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYlszMzs0M20nXHUwMDFiWzM5OzQ5bVx1MDAxYlszMzs0M21sb3dcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbWNsb3NlXHUwMDFiWzM5OzQ5bVx1MDAxYlszMzs0M20nXHUwMDFiWzM5OzQ5bVx1MDAxYls0M21dXHUwMDFiWzQ5bVx1MDAxYls0M21dXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgICAgNDVcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyOG1sZW5cdTAwMWJbMzltKHdpbmRvd19kYXRhKSA+IFx1MDAxYlszMm0wXHUwMDFiWzM5bTpcblx1MDAxYlszMm0gICAgIDQ2XHUwMDFiWzM5bSAgICAgcHJpY2VfcmFuZ2UgPSB3aW5kb3dfZGF0YVtcdTAwMWJbMzNtJ1x1MDAxYlszOW1cdTAwMWJbMzNtaGlnaFx1MDAxYlszOW1cdTAwMWJbMzNtJ1x1MDAxYlszOW1dLm1heCgpIC0gd2luZG93X2RhdGFbXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbWxvd1x1MDAxYlszOW1cdTAwMWJbMzNtJ1x1MDAxYlszOW1dLm1pbigpXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTE4NVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jYXRpb25JbmRleGVyLl9fZ2V0aXRlbV9fXHUwMDFiWzM5bVx1MDAxYlszNG0oc2VsZiwga2V5KVx1MDAxYlszOW1cblx1MDAxYlszMm0gICAxMTgzXHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLl9pc19zY2FsYXJfYWNjZXNzKGtleSk6XG5cdTAwMWJbMzJtICAgMTE4NFx1MDAxYlszOW0gICAgICAgICBcdTAwMWJbMzg7NTsyODswMW1yZXR1cm5cdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLm9iai5fZ2V0X3ZhbHVlKCprZXksIHRha2VhYmxlPVx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLl90YWtlYWJsZSlcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTExODVcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1yZXR1cm5cdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9nZXRpdGVtX3R1cGxlXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21rZXlcdTAwMWJbNDltXHUwMDFiWzQzbSlcdTAwMWJbNDltXG5cdTAwMWJbMzJtICAgMTE4Nlx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtZWxzZVx1MDAxYlszOTswMG06XG5cdTAwMWJbMzJtICAgMTE4N1x1MDAxYlszOW0gICAgIFx1MDAxYlszODs1OzY2OzAzbSMgd2UgYnkgZGVmaW5pdGlvbiBvbmx5IGhhdmUgdGhlIDB0aCBheGlzXHUwMDFiWzM5OzAwbVxuXHUwMDFiWzMybSAgIDExODhcdTAwMWJbMzltICAgICBheGlzID0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0uYXhpcyBcdTAwMWJbMzg7NTsxMjk7MDFtb3JcdTAwMWJbMzk7MDBtIFx1MDAxYlszMm0wXHUwMDFiWzM5bVxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybX4vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi8udmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL3BhbmRhcy9jb3JlL2luZGV4aW5nLnB5OjEzNzhcdTAwMWJbMzltLCBpbiBcdTAwMWJbMzZtX0xvY0luZGV4ZXIuX2dldGl0ZW1fdHVwbGVcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCB0dXApXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDEzNzVcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5fbXVsdGlfdGFrZV9vcHBvcnR1bml0eSh0dXApOlxuXHUwMDFiWzMybSAgIDEzNzZcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1yZXR1cm5cdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLl9tdWx0aV90YWtlKHR1cClcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTEzNzhcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7Mjg7NDNtc2VsZlx1MDAxYlszOTs0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtX2dldGl0ZW1fdHVwbGVfc2FtZV9kaW1cdTAwMWJbNDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbXR1cFx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblxuXHUwMDFiWzM2bUZpbGUgXHUwMDFiWzM5bVx1MDAxYlszMm1+L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vLnZlbnYvbGliL3B5dGhvbjMuMTMvc2l0ZS1wYWNrYWdlcy9wYW5kYXMvY29yZS9pbmRleGluZy5weToxMDIxXHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bV9Mb2NhdGlvbkluZGV4ZXIuX2dldGl0ZW1fdHVwbGVfc2FtZV9kaW1cdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCB0dXApXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDEwMThcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBjb20uaXNfbnVsbF9zbGljZShrZXkpOlxuXHUwMDFiWzMybSAgIDEwMTlcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1jb250aW51ZVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTEwMjFcdTAwMWJbMzltIHJldHZhbCA9IFx1MDAxYlszODs1OzI4OzQzbWdldGF0dHJcdTAwMWJbMzk7NDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbXJldHZhbFx1MDAxYls0OW1cdTAwMWJbNDNtLFx1MDAxYls0OW1cdTAwMWJbNDNtIFx1MDAxYls0OW1cdTAwMWJbMzg7NTsyODs0M21zZWxmXHUwMDFiWzM5OzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21uYW1lXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21fZ2V0aXRlbV9heGlzXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21rZXlcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNcdTAwMWJbNDltXHUwMDFiWzQzbT1cdTAwMWJbNDltXHUwMDFiWzQzbWlcdTAwMWJbNDltXHUwMDFiWzQzbSlcdTAwMWJbNDltXG5cdTAwMWJbMzJtICAgMTAyMlx1MDAxYlszOW0gXHUwMDFiWzM4OzU7NjY7MDNtIyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSByZXR2YWwubmRpbSA8IHNlbGYubmRpbSwgYXMgdGhhdCBzaG91bGRcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgMTAyM1x1MDAxYlszOW0gXHUwMDFiWzM4OzU7NjY7MDNtIyAgYmUgaGFuZGxlZCBieSB0aGUgX2dldGl0ZW1fbG93ZXJkaW0gY2FsbCBhYm92ZS5cdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgMTAyNFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtYXNzZXJ0XHUwMDFiWzM5OzAwbSByZXR2YWwubmRpbSA9PSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5uZGltXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTQyMVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0aXRlbV9heGlzXHUwMDFiWzM5bVx1MDAxYlszNG0oc2VsZiwga2V5LCBheGlzKVx1MDAxYlszOW1cblx1MDAxYlszMm0gICAxNDE4XHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bWhhc2F0dHJcdTAwMWJbMzltKGtleSwgXHUwMDFiWzMzbVwiXHUwMDFiWzM5bVx1MDAxYlszM21uZGltXHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW0pIFx1MDAxYlszODs1OzEyOTswMW1hbmRcdTAwMWJbMzk7MDBtIGtleS5uZGltID4gXHUwMDFiWzMybTFcdTAwMWJbMzltOlxuXHUwMDFiWzMybSAgIDE0MTlcdTAwMWJbMzltICAgICAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtcmFpc2VcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzE2NzswMW1WYWx1ZUVycm9yXHUwMDFiWzM5OzAwbShcdTAwMWJbMzNtXCJcdTAwMWJbMzltXHUwMDFiWzMzbUNhbm5vdCBpbmRleCB3aXRoIG11bHRpZGltZW5zaW9uYWwga2V5XHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW0pXG5cdTAwMWJbMzJtLT4gXHUwMDFiWzM5bVx1MDAxYlszMm0xNDIxXHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtcmV0dXJuXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsyODs0M21zZWxmXHUwMDFiWzM5OzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21fZ2V0aXRlbV9pdGVyYWJsZVx1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNta2V5XHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M209XHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgIDE0MjNcdTAwMWJbMzltIFx1MDAxYlszODs1OzY2OzAzbSMgbmVzdGVkIHR1cGxlIHNsaWNpbmdcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgMTQyNFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIGlzX25lc3RlZF90dXBsZShrZXksIGxhYmVscyk6XG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTM2MVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0aXRlbV9pdGVyYWJsZVx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIGtleSwgYXhpcylcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgMTM1OFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0uX3ZhbGlkYXRlX2tleShrZXksIGF4aXMpXG5cdTAwMWJbMzJtICAgMTM2MFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7NjY7MDNtIyBBIGNvbGxlY3Rpb24gb2Yga2V5c1x1MDAxYlszOTswMG1cblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTEzNjFcdTAwMWJbMzltIGtleWFyciwgaW5kZXhlciA9IFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9nZXRfbGlzdGxpa2VfaW5kZXhlclx1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNta2V5XHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYls0M21heGlzXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgIDEzNjJcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbXJldHVyblx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0ub2JqLl9yZWluZGV4X3dpdGhfaW5kZXhlcnMoXG5cdTAwMWJbMzJtICAgMTM2M1x1MDAxYlszOW0gICAgIHtheGlzOiBba2V5YXJyLCBpbmRleGVyXX0sIGNvcHk9XHUwMDFiWzM4OzU7Mjg7MDFtVHJ1ZVx1MDAxYlszOTswMG0sIGFsbG93X2R1cHM9XHUwMDFiWzM4OzU7Mjg7MDFtVHJ1ZVx1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICAxMzY0XHUwMDFiWzM5bSApXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhpbmcucHk6MTU1OVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1fTG9jSW5kZXhlci5fZ2V0X2xpc3RsaWtlX2luZGV4ZXJcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXksIGF4aXMpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDE1NTZcdTAwMWJbMzltIGF4ID0gXHUwMDFiWzM4OzU7Mjhtc2VsZlx1MDAxYlszOW0ub2JqLl9nZXRfYXhpcyhheGlzKVxuXHUwMDFiWzMybSAgIDE1NTdcdTAwMWJbMzltIGF4aXNfbmFtZSA9IFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLm9iai5fZ2V0X2F4aXNfbmFtZShheGlzKVxuXHUwMDFiWzMybS0+IFx1MDAxYlszOW1cdTAwMWJbMzJtMTU1OVx1MDAxYlszOW0ga2V5YXJyLCBpbmRleGVyID0gXHUwMDFiWzQzbWF4XHUwMDFiWzQ5bVx1MDAxYls0M20uXHUwMDFiWzQ5bVx1MDAxYls0M21fZ2V0X2luZGV4ZXJfc3RyaWN0XHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21rZXlcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNfbmFtZVx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblx1MDAxYlszMm0gICAxNTYxXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1yZXR1cm5cdTAwMWJbMzk7MDBtIGtleWFyciwgaW5kZXhlclxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybX4vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi8udmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL3BhbmRhcy9jb3JlL2luZGV4ZXMvYmFzZS5weTo2MjEyXHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bUluZGV4Ll9nZXRfaW5kZXhlcl9zdHJpY3RcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXksIGF4aXNfbmFtZSlcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgNjIwOVx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtZWxzZVx1MDAxYlszOTswMG06XG5cdTAwMWJbMzJtICAgNjIxMFx1MDAxYlszOW0gICAgIGtleWFyciwgaW5kZXhlciwgbmV3X2luZGV4ZXIgPSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS5fcmVpbmRleF9ub25fdW5pcXVlKGtleWFycilcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTYyMTJcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzQzbXNlbGZcdTAwMWJbMzk7NDltXHUwMDFiWzQzbS5cdTAwMWJbNDltXHUwMDFiWzQzbV9yYWlzZV9pZl9taXNzaW5nXHUwMDFiWzQ5bVx1MDAxYls0M20oXHUwMDFiWzQ5bVx1MDAxYls0M21rZXlhcnJcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWluZGV4ZXJcdTAwMWJbNDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzQzbWF4aXNfbmFtZVx1MDAxYls0OW1cdTAwMWJbNDNtKVx1MDAxYls0OW1cblx1MDAxYlszMm0gICA2MjE0XHUwMDFiWzM5bSBrZXlhcnIgPSBcdTAwMWJbMzg7NTsyOG1zZWxmXHUwMDFiWzM5bS50YWtlKGluZGV4ZXIpXG5cdTAwMWJbMzJtICAgNjIxNVx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzI4bWlzaW5zdGFuY2VcdTAwMWJbMzltKGtleSwgSW5kZXgpOlxuXHUwMDFiWzMybSAgIDYyMTZcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTs2NjswM20jIEdIIDQyNzkwIC0gUHJlc2VydmUgbmFtZSBmcm9tIGFuIEluZGV4XHUwMDFiWzM5OzAwbVxuXG5cdTAwMWJbMzZtRmlsZSBcdTAwMWJbMzltXHUwMDFiWzMybX4vc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi8udmVudi9saWIvcHl0aG9uMy4xMy9zaXRlLXBhY2thZ2VzL3BhbmRhcy9jb3JlL2luZGV4ZXMvYmFzZS5weTo2MjYxXHUwMDFiWzM5bSwgaW4gXHUwMDFiWzM2bUluZGV4Ll9yYWlzZV9pZl9taXNzaW5nXHUwMDFiWzM5bVx1MDAxYlszNG0oc2VsZiwga2V5LCBpbmRleGVyLCBheGlzX25hbWUpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDYyNTlcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4OzAxbWlmXHUwMDFiWzM5OzAwbSBubWlzc2luZzpcblx1MDAxYlszMm0gICA2MjYwXHUwMDFiWzM5bSAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIG5taXNzaW5nID09IFx1MDAxYlszODs1OzI4bWxlblx1MDAxYlszOW0oaW5kZXhlcik6XG5cdTAwMWJbMzJtLT4gXHUwMDFiWzM5bVx1MDAxYlszMm02MjYxXHUwMDFiWzM5bSAgICAgICAgIFx1MDAxYlszODs1OzI4OzAxbXJhaXNlXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsxNjc7MDFtS2V5RXJyb3JcdTAwMWJbMzk7MDBtKFx1MDAxYlszM21mXHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW1cdTAwMWJbMzNtTm9uZSBvZiBbXHUwMDFiWzM5bVx1MDAxYlszODs1OzEzMjswMW17XHUwMDFiWzM5OzAwbWtleVx1MDAxYlszODs1OzEzMjswMW19XHUwMDFiWzM5OzAwbVx1MDAxYlszM21dIGFyZSBpbiB0aGUgW1x1MDAxYlszOW1cdTAwMWJbMzg7NTsxMzI7MDFte1x1MDAxYlszOTswMG1heGlzX25hbWVcdTAwMWJbMzg7NTsxMzI7MDFtfVx1MDAxYlszOTswMG1cdTAwMWJbMzNtXVx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltKVxuXHUwMDFiWzMybSAgIDYyNjNcdTAwMWJbMzltICAgICBub3RfZm91bmQgPSBcdTAwMWJbMzg7NTsyOG1saXN0XHUwMDFiWzM5bShlbnN1cmVfaW5kZXgoa2V5KVttaXNzaW5nX21hc2subm9uemVybygpW1x1MDAxYlszMm0wXHUwMDFiWzM5bV1dLnVuaXF1ZSgpKVxuXHUwMDFiWzMybSAgIDYyNjRcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1yYWlzZVx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7MTY3OzAxbUtleUVycm9yXHUwMDFiWzM5OzAwbShcdTAwMWJbMzNtZlx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltXHUwMDFiWzM4OzU7MTMyOzAxbXtcdTAwMWJbMzk7MDBtbm90X2ZvdW5kXHUwMDFiWzM4OzU7MTMyOzAxbX1cdTAwMWJbMzk7MDBtXHUwMDFiWzMzbSBub3QgaW4gaW5kZXhcdTAwMWJbMzltXHUwMDFiWzMzbVwiXHUwMDFiWzM5bSlcblxuXHUwMDFiWzMxbUtleUVycm9yXHUwMDFiWzM5bTogXCJOb25lIG9mIFtJbmRleChbJ2hpZ2gnLCAnbG93JywgJ2Nsb3NlJ10sIGR0eXBlPSdvYmplY3QnKV0gYXJlIGluIHRoZSBbY29sdW1uc11cIiIKfQ==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.error\\\"}]}],\\\"source\\\":\\\"# Investigate middle NaNs - specifically stochastic features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Investigating Middle NaNs in Stochastic Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get stochastic features\\\\nstoch_features = [col for col in features.columns if 'stoch_pos' in col]\\\\nprint(f\\\\\\\"\\\\\\\\nStochastic features: {stoch_features}\\\\\\\")\\\\n\\\\n# Check where NaNs occur\\\\nstoch_3h = features['stoch_pos_3h']\\\\nnan_mask = stoch_3h.isna()\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal NaNs in stoch_pos_3h: {nan_mask.sum()}\\\\\\\")\\\\n\\\\n# Find the NaN rows\\\\nnan_rows = features[nan_mask]\\\\nprint(f\\\\\\\"\\\\\\\\nDate range of NaN occurrences:\\\\\\\")\\\\nprint(f\\\\\\\"  First NaN: {nan_rows.index[0]}\\\\\\\")\\\\nprint(f\\\\\\\"  Last NaN: {nan_rows.index[-1]}\\\\\\\")\\\\n\\\\n# Sample some NaN periods\\\\nprint(f\\\\\\\"\\\\\\\\nSample NaN periods (showing 10 random samples):\\\\\\\")\\\\nsample_nans = nan_rows.sample(min(10, len(nan_rows)))\\\\nfor idx in sample_nans.index:\\\\n    print(f\\\\\\\"  {idx}\\\\\\\")\\\\n\\\\n# Check if these correspond to flat price periods\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Checking if NaNs coincide with flat price periods\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Need to access raw OHLC data to verify\\\\nif 'raw_history' in globals():\\\\n    # Get a few NaN samples and check the raw data around them\\\\n    sample_nan_times = nan_rows.index[:5]\\\\n    \\\\n    for nan_time in sample_nan_times:\\\\n        # Get 3h window around this time\\\\n        window_start = nan_time - pd.Timedelta(hours=3)\\\\n        window_end = nan_time\\\\n        \\\\n        window_data = raw_history.loc[window_start:window_end, ['high', 'low', 'close']]\\\\n        \\\\n        if len(window_data) > 0:\\\\n            price_range = window_data['high'].max() - window_data['low'].min()\\\\n            print(f\\\\\\\"\\\\\\\\n{nan_time}:\\\\\\\")\\\\n            print(f\\\\\\\"  High-Low range over 3h: ${price_range:.2f}\\\\\\\")\\\\n            print(f\\\\\\\"  High: ${window_data['high'].max():.2f}, Low: ${window_data['low'].min():.2f}\\\\\\\")\\\\n            \\\\n            if price_range < 0.01:\\\\n                print(f\\\\\\\"   FLAT PERIOD - price range < $0.01\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\nraw_history not available - cannot verify flat periods\\\\\\\")\\\\n    print(\\\\\\\"But this is the expected cause: high == low over the window  stoch denominator = 0\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"f009c158\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"b017e1c9-7b0a-45e5-bbd2-9ba4b21a9d5e\\\",\\\"runStartTime\\\":1764181079328,\\\"runEndTime\\\":1764181079415,\\\"lastRunSuccess\\\":false,\\\"executionOrder\\\":19,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":7},\\\"error\\\":{\\\"name\\\":\\\"KeyError\\\",\\\"message\\\":\\\"\\\\\\\"None of [Index(['high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"stack\\\":\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\\n\\\\u001b[31mKeyError\\\\u001b[39m                                  Traceback (most recent call last)\\\\n\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[19]\\\\u001b[39m\\\\u001b[32m, line 43\\\\u001b[39m\\\\n\\\\u001b[32m     40\\\\u001b[39m window_start = nan_time - pd.Timedelta(hours=\\\\u001b[32m3\\\\u001b[39m)\\\\n\\\\u001b[32m     41\\\\u001b[39m window_end = nan_time\\\\n\\\\u001b[32m---> \\\\u001b[39m\\\\u001b[32m43\\\\u001b[39m window_data = \\\\u001b[43mraw_history\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mloc\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[43mwindow_start\\\\u001b[49m\\\\u001b[43m:\\\\u001b[49m\\\\u001b[43mwindow_end\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mhigh\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mlow\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mclose\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m]\\\\u001b[49m\\\\u001b[43m]\\\\u001b[49m\\\\n\\\\u001b[32m     45\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mlen\\\\u001b[39m(window_data) > \\\\u001b[32m0\\\\u001b[39m:\\\\n\\\\u001b[32m     46\\\\u001b[39m     price_range = window_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m].max() - window_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m].min()\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1185\\\\u001b[39m, in \\\\u001b[36m_LocationIndexer.__getitem__\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m   1183\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._is_scalar_access(key):\\\\n\\\\u001b[32m   1184\\\\u001b[39m         \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_value(*key, takeable=\\\\u001b[38;5;28mself\\\\u001b[39m._takeable)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1185\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_tuple\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1186\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   1187\\\\u001b[39m     \\\\u001b[38;5;66;03m# we by definition only have the 0th axis\\\\u001b[39;00m\\\\n\\\\u001b[32m   1188\\\\u001b[39m     axis = \\\\u001b[38;5;28mself\\\\u001b[39m.axis \\\\u001b[38;5;129;01mor\\\\u001b[39;00m \\\\u001b[32m0\\\\u001b[39m\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1378\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_tuple\\\\u001b[39m\\\\u001b[34m(self, tup)\\\\u001b[39m\\\\n\\\\u001b[32m   1375\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._multi_take_opportunity(tup):\\\\n\\\\u001b[32m   1376\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m._multi_take(tup)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1378\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_tuple_same_dim\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mtup\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1021\\\\u001b[39m, in \\\\u001b[36m_LocationIndexer._getitem_tuple_same_dim\\\\u001b[39m\\\\u001b[34m(self, tup)\\\\u001b[39m\\\\n\\\\u001b[32m   1018\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m com.is_null_slice(key):\\\\n\\\\u001b[32m   1019\\\\u001b[39m     \\\\u001b[38;5;28;01mcontinue\\\\u001b[39;00m\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1021\\\\u001b[39m retval = \\\\u001b[38;5;28;43mgetattr\\\\u001b[39;49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mretval\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mname\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_axis\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43mi\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1022\\\\u001b[39m \\\\u001b[38;5;66;03m# We should never have retval.ndim < self.ndim, as that should\\\\u001b[39;00m\\\\n\\\\u001b[32m   1023\\\\u001b[39m \\\\u001b[38;5;66;03m#  be handled by the _getitem_lowerdim call above.\\\\u001b[39;00m\\\\n\\\\u001b[32m   1024\\\\u001b[39m \\\\u001b[38;5;28;01massert\\\\u001b[39;00m retval.ndim == \\\\u001b[38;5;28mself\\\\u001b[39m.ndim\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1421\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_axis\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1418\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mhasattr\\\\u001b[39m(key, \\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mndim\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m) \\\\u001b[38;5;129;01mand\\\\u001b[39;00m key.ndim > \\\\u001b[32m1\\\\u001b[39m:\\\\n\\\\u001b[32m   1419\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mValueError\\\\u001b[39;00m(\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mCannot index with multidimensional key\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1421\\\\u001b[39m     \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_getitem_iterable\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m=\\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1423\\\\u001b[39m \\\\u001b[38;5;66;03m# nested tuple slicing\\\\u001b[39;00m\\\\n\\\\u001b[32m   1424\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m is_nested_tuple(key, labels):\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1361\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._getitem_iterable\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1358\\\\u001b[39m \\\\u001b[38;5;28mself\\\\u001b[39m._validate_key(key, axis)\\\\n\\\\u001b[32m   1360\\\\u001b[39m \\\\u001b[38;5;66;03m# A collection of keys\\\\u001b[39;00m\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1361\\\\u001b[39m keyarr, indexer = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_listlike_indexer\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1362\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m \\\\u001b[38;5;28mself\\\\u001b[39m.obj._reindex_with_indexers(\\\\n\\\\u001b[32m   1363\\\\u001b[39m     {axis: [keyarr, indexer]}, copy=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m, allow_dups=\\\\u001b[38;5;28;01mTrue\\\\u001b[39;00m\\\\n\\\\u001b[32m   1364\\\\u001b[39m )\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexing.py:1559\\\\u001b[39m, in \\\\u001b[36m_LocIndexer._get_listlike_indexer\\\\u001b[39m\\\\u001b[34m(self, key, axis)\\\\u001b[39m\\\\n\\\\u001b[32m   1556\\\\u001b[39m ax = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis(axis)\\\\n\\\\u001b[32m   1557\\\\u001b[39m axis_name = \\\\u001b[38;5;28mself\\\\u001b[39m.obj._get_axis_name(axis)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m1559\\\\u001b[39m keyarr, indexer = \\\\u001b[43max\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_indexer_strict\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   1561\\\\u001b[39m \\\\u001b[38;5;28;01mreturn\\\\u001b[39;00m keyarr, indexer\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6212\\\\u001b[39m, in \\\\u001b[36mIndex._get_indexer_strict\\\\u001b[39m\\\\u001b[34m(self, key, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6209\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   6210\\\\u001b[39m     keyarr, indexer, new_indexer = \\\\u001b[38;5;28mself\\\\u001b[39m._reindex_non_unique(keyarr)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6212\\\\u001b[39m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_raise_if_missing\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkeyarr\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   6214\\\\u001b[39m keyarr = \\\\u001b[38;5;28mself\\\\u001b[39m.take(indexer)\\\\n\\\\u001b[32m   6215\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, Index):\\\\n\\\\u001b[32m   6216\\\\u001b[39m     \\\\u001b[38;5;66;03m# GH 42790 - Preserve name from an Index\\\\u001b[39;00m\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6261\\\\u001b[39m, in \\\\u001b[36mIndex._raise_if_missing\\\\u001b[39m\\\\u001b[34m(self, key, indexer, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6259\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing:\\\\n\\\\u001b[32m   6260\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing == \\\\u001b[38;5;28mlen\\\\u001b[39m(indexer):\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6261\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mNone of [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mkey\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m] are in the [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00maxis_name\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m]\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m   6263\\\\u001b[39m     not_found = \\\\u001b[38;5;28mlist\\\\u001b[39m(ensure_index(key)[missing_mask.nonzero()[\\\\u001b[32m0\\\\u001b[39m]].unique())\\\\n\\\\u001b[32m   6264\\\\u001b[39m     \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mnot_found\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m not in index\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\n\\\\u001b[31mKeyError\\\\u001b[39m: \\\\\\\"None of [Index(['high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"location\\\":{\\\"startLineNumber\\\":42,\\\"startColumn\\\":8,\\\"endLineNumber\\\":42,\\\"endColumn\\\":88},\\\"uri\\\":{\\\"$mid\\\":1,\\\"fsPath\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"external\\\":\\\"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X16sZmlsZQ%3D%3D\\\",\\\"path\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"scheme\\\":\\\"vscode-notebook-cell\\\",\\\"fragment\\\":\\\"X16sZmlsZQ==\\\"}}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":17,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"0ee02236-5196-4bc5-8010-8b9b4d6e748a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"UmVtb3ZpbmcgZGF0YSBiZWZvcmUgMjAxOS0xMS0wMSAoZmlyc3QgMSBtb250aHMpCk5hTiByb3dzIGFmdGVyIGN1dG9mZiByZW1vdmFsOiAxNzMgLyA1MzIyMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"6b9a7617-09f3-4f74-a636-6946075ccdaa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":17,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+OTE1MS4yPC90ZD4KICAgICAgPHRkPjkxNTUuODwvdGQ+CiAgICAgIDx0ZD45MTE1LjA8L3RkPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjExNzQuMDwvdGQ+CiAgICAgIDx0ZD43LjA8L3RkPgogICAgICA8dGQ+MTcuMDwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MS4wODg3NzM8L3RkPgogICAgICA8dGQ+MC4xMjUwNzQ8L3RkPgogICAgICA8dGQ+MC4xMjE1Mjc8L3RkPgogICAgICA8dGQ+LTQuNjkxMjk2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC41NzIwODI8L3RkPgogICAgICA8dGQ+MS4xNDQxNjM8L3RkPgogICAgICA8dGQ+MC4wMDYzODc8L3RkPgogICAgICA8dGQ+MC4wMDgzNjg8L3RkPgogICAgICA8dGQ+MC4wMDU5MDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDE6MDA6MDA8L3RoPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjkxNDkuMDwvdGQ+CiAgICAgIDx0ZD45MTA4Ljg8L3RkPgogICAgICA8dGQ+OTEwOC44PC90ZD4KICAgICAgPHRkPjk4Ny4wPC90ZD4KICAgICAgPHRkPjYuMDwvdGQ+CiAgICAgIDx0ZD4xOC4wPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjExNzU4ODwvdGQ+CiAgICAgIDx0ZD4wLjEyNzYwNzwvdGQ+CiAgICAgIDx0ZD4wLjEyMjMwNTwvdGQ+CiAgICAgIDx0ZD4tMy45NzQ1NTQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MTUwODwvdGQ+CiAgICAgIDx0ZD4xLjI4MzAxNzwvdGQ+CiAgICAgIDx0ZD4wLjAwNjYxMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTY4NjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD45MTA4Ljk8L3RkPgogICAgICA8dGQ+OTE0OC44PC90ZD4KICAgICAgPHRkPjkwNzUuMjwvdGQ+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+MTY1NS4wPC90ZD4KICAgICAgPHRkPjUuMDwvdGQ+CiAgICAgIDx0ZD4xOS4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjA2MzkxNDwvdGQ+CiAgICAgIDx0ZD4wLjEwMDA5NTwvdGQ+CiAgICAgIDx0ZD4wLjA5ODQ5NzwvdGQ+CiAgICAgIDx0ZD4tNS4yMzE1OTY8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2MTY3MjwvdGQ+CiAgICAgIDx0ZD4wLjkyMzM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MjwvdGQ+CiAgICAgIDx0ZD4wLjAwNDgyNjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+OTEzNy4zPC90ZD4KICAgICAgPHRkPjkwNjEuNTwvdGQ+CiAgICAgIDx0ZD45MDgyLjk8L3RkPgogICAgICA8dGQ+MTMxNS4wPC90ZD4KICAgICAgPHRkPjQuMDwvdGQ+CiAgICAgIDx0ZD4yMC4wPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjU2ODcyODwvdGQ+CiAgICAgIDx0ZD4wLjAyMzk2MTwvdGQ+CiAgICAgIDx0ZD4wLjA2NDc3NTwvdGQ+CiAgICAgIDx0ZD4tMi4yNTMwMjg8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MDM4NzwvdGQ+CiAgICAgIDx0ZD4xLjI4MDc3NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzUyOTwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTAwMTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwNDowMDowMDwvdGg+CiAgICAgIDx0ZD45MDgzLjA8L3RkPgogICAgICA8dGQ+OTEyMy40PC90ZD4KICAgICAgPHRkPjkwNjAuMDwvdGQ+CiAgICAgIDx0ZD45MDk5Ljc8L3RkPgogICAgICA8dGQ+MTQ5Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjQ3ODcwNTwvdGQ+CiAgICAgIDx0ZD4tMC4xMTQ3NTA8L3RkPgogICAgICA8dGQ+MC4wNjk5MDk8L3RkPgogICAgICA8dGQ+LTQuNDI4MDIzPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42NjE0ODg8L3RkPgogICAgICA8dGQ+MS4zMjI5NzY8L3RkPgogICAgICA8dGQ+MC4wMDY3MTk8L3RkPgogICAgICA8dGQ+MC4wMDgyNzM8L3RkPgogICAgICA8dGQ+MC4wMDU1NDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40NjczNzM8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDYzOTM8L3RkPgogICAgICA8dGQ+MC4wMDU0ODM8L3RkPgogICAgICA8dGQ+MC4wMDM4NjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc4NzIuNzwvdGQ+CiAgICAgIDx0ZD44Nzg4MS44PC90ZD4KICAgICAgPHRkPjg3MzQyLjk8L3RkPgogICAgICA8dGQ+ODczNjEuNzwvdGQ+CiAgICAgIDx0ZD4yMzIuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMTQ1NzI8L3RkPgogICAgICA8dGQ+LTEuMTE1MjQyPC90ZD4KICAgICAgPHRkPjAuMDI2OTcyPC90ZD4KICAgICAgPHRkPi02LjMxODY5MTwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMjQ5NTAxPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA3MjA0PC90ZD4KICAgICAgPHRkPjAuMDA1NDgxPC90ZD4KICAgICAgPHRkPjAuMDAzNDI3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjg3MzUzLjU8L3RkPgogICAgICA8dGQ+ODczOTYuNzwvdGQ+CiAgICAgIDx0ZD44NjYyNy45PC90ZD4KICAgICAgPHRkPjg2Nzc2LjI8L3RkPgogICAgICA8dGQ+NTY3LjA8L3RkPgogICAgICA8dGQ+MjIuMDwvdGQ+CiAgICAgIDx0ZD4yLjA8L3RkPgogICAgICA8dGQ+MTA8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wNTQ3OTc8L3RkPgogICAgICA8dGQ+LTEuMTM5NTQ0PC90ZD4KICAgICAgPHRkPjAuMDMwMTI2PC90ZD4KICAgICAgPHRkPi00Ljk4OTM3NjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMDkyNzIwPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA1NjY4PC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA0MzY3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTc0NjE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDgxOTg8L3RkPgogICAgICA8dGQ+MC4wMDU1MDM8L3RkPgogICAgICA8dGQ+MC4wMDMwMjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTE6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44Njg3OS43PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+ODY4MTguODwvdGQ+CiAgICAgIDx0ZD41LjA8L3RkPgogICAgICA8dGQ+MjAuMDwvdGQ+CiAgICAgIDx0ZD40LjA8L3RkPgogICAgICA8dGQ+MTI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wOTQ4NTk8L3RkPgogICAgICA8dGQ+LTAuOTQzNTkzPC90ZD4KICAgICAgPHRkPjAuMDMyOTE1PC90ZD4KICAgICAgPHRkPi01LjQwNjkwMzwvdGQ+CiAgICAgIDx0ZD4mbHQ7TkEmZ3Q7PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+MC4wMDk1NTA8L3RkPgogICAgICA8dGQ+MC4wMDU0Nzg8L3RkPgogICAgICA8dGQ+MC4wMDI1ODM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD41MzIyMCByb3dzIMOXIDQ1NiBjb2x1bW5zPC9wPgo8L2Rpdj4=\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICA5MTUxLjIgICA5MTU1LjggICA5MTE1LjAgICA5MTM1LjAgIDExNzQuMCAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgOTEzNS4wICAgOTE0OS4wICAgOTEwOC44ICAgOTEwOC44ICAgOTg3LjAgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgIDkxMDguOSAgIDkxNDguOCAgIDkwNzUuMiAgIDkxMzcuMyAgMTY1NS4wICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICA5MTM3LjMgICA5MTM3LjMgICA5MDYxLjUgICA5MDgyLjkgIDEzMTUuMCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgOTA4My4wICAgOTEyMy40ICAgOTA2MC4wICAgOTA5OS43ICAxNDk2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgIDg3NzI1LjIgIDg3OTAwLjAgIDg3NjM3LjcgIDg3ODcyLjYgICAxOTUuMCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICA4Nzg3Mi43ICA4Nzg4MS44ICA4NzM0Mi45ICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgODczNTMuNSAgODczOTYuNyAgODY2MjcuOSAgODY3NzYuMiAgIDU2Ny4wICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgIDg2NzcyLjIgIDg2OTk5LjkgIDg2NTk1LjggIDg2ODc5LjcgICAxOTUuMCAgIAoyMDI1LTExLTI2IDExOjAwOjAwICA4Njg3OS43ICA4Njg3OS43ICA4NjgxOC44ICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTExLTAxIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA0ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNCAgIAoyMDE5LTExLTAxIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA0ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAxLjA4ODc3MyAgICAgICAgICAgICAgMC4xMjUwNzQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDEuMTE3NTg4ICAgICAgICAgICAgICAwLjEyNzYwNyAgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMS4wNjM5MTQgICAgICAgICAgICAgIDAuMTAwMDk1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjU2ODcyOCAgICAgICAgICAgICAgMC4wMjM5NjEgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuNDc4NzA1ICAgICAgICAgICAgIC0wLjExNDc1MCAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAxMzkwMyAgICAgICAgICAgICAtMS4xNDkzOTUgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDE0NTcyICAgICAgICAgICAgIC0xLjExNTI0MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAtMC4wNTQ3OTcgICAgICAgICAgICAgLTEuMTM5NTQ0ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjEwODAzMyAgICAgICAgICAgICAtMC45ODU5MjMgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMDk0ODU5ICAgICAgICAgICAgIC0wLjk0MzU5MyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMTIxNTI3ICAgICAgICAgICAgICAgIC00LjY5MTI5NiAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgICAgICAgICAgICAwLjEyMjMwNSAgICAgICAgICAgICAgICAtMy45NzQ1NTQgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgICAgICAgICAgICAgMC4wOTg0OTcgICAgICAgICAgICAgICAgLTUuMjMxNTk2ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDY0Nzc1ICAgICAgICAgICAgICAgIC0yLjI1MzAyOCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgICAgICAgICAgICAwLjA2OTkwOSAgICAgICAgICAgICAgICAtNC40MjgwMjMgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgIDAuMDI4MDY4ICAgICAgICAgICAgICAgIC0xLjk3MjA0MCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAwLjAyNjk3MiAgICAgICAgICAgICAgICAtNi4zMTg2OTEgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgMC4wMzAxMjYgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgIDAuMDMzNjQzICAgICAgICAgICAgICAgICA3LjEzMDI3MiAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAwLjAzMjkxNSAgICAgICAgICAgICAgICAtNS40MDY5MDMgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNTcyMDgyICAgICAgICAgIDEuMTQ0MTYzICAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQxNTA4ICAgICAgICAgIDEuMjgzMDE3ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDYxNjcyICAgICAgICAgIDAuOTIzMzQ1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQwMzg3ICAgICAgICAgIDEuMjgwNzc1ICAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjYxNDg4ICAgICAgICAgIDEuMzIyOTc2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgPE5BPiAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgTmFOICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMS0wMSAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM4NyAgICAgMC4wMDgzNjggICAgICAwLjAwNTkwMCAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY2MTAgICAgIDAuMDA4MzQ1ICAgICAgMC4wMDU2ODYgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3ODA0ICAgICAwLjAwODM2MiAgICAgIDAuMDA0ODI2ICAKMjAxOS0xMS0wMSAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzUyOSAgICAgMC4wMDgzNjEgICAgICAwLjAwNTAwMSAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY3MTkgICAgIDAuMDA4MjczICAgICAgMC4wMDU1NDYgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM5MyAgICAgMC4wMDU0ODMgICAgICAwLjAwMzg2MyAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDcyMDQgICAgIDAuMDA1NDgxICAgICAgMC4wMDM0MjcgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA1NjY4ICAgICAwLjAwNTQ5NSAgICAgIDAuMDA0MzY3ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAwLjAwODE5OCAgICAgMC4wMDU1MDMgICAgICAwLjAwMzAyMyAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDk1NTAgICAgIDAuMDA1NDc4ICAgICAgMC4wMDI1ODMgIAoKWzUzMjIwIHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\n\\\\nnan_mask_clean = combined_df_clean.isna().any(axis=1)\\\\nprint(f\\\\\\\"NaN rows after cutoff removal: {nan_mask_clean.sum()} / {combined_df_clean.shape[0]}\\\\\\\")\\\\ncombined_df_clean\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"12d0618e-4a5b-45a0-b040-8fb4aa1c38e9\\\",\\\"runStartTime\\\":1764180761320,\\\"runEndTime\\\":1764180761376,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":17,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":55,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":20,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"39c9d8e5-7b7b-4cef-bbd1-36bef455dfff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"957df78c-8e58-4b2b-a850-5a7c258f1de4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"8289a205-2f21-4755-8d5c-52f78aa08186\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjcwcyBbc3RhdGVsZXNzOjI1MC4ybXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTMuMm1zLCByb2xsaW5nOjY1Mi4zbXMsIHByZXZfd2Vla19jeWNsZTo0Ni43bXMsIGN1cnJlbnRfY3ljbGU6OTI5NC4wbXMsIG5vbl9saW5lYXI6MjQ5LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy45bXMsIGNsZWFudXA6MTY2LjRtc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC43MXMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM1MS4wM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzUxLjAzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":20,\\\"executionId\\\":\\\"2437fd19-fa6b-4462-bb05-1c7f2dcfb249\\\",\\\"runStartTime\\\":1764181303307,\\\"runEndTime\\\":1764182000332,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":22,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"68affb76-e55e-499e-a125-82d3835cf62f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = True  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"04e86cbb-66d4-4a7d-b484-0992182967e2\\\",\\\"runStartTime\\\":1764182014900,\\\"runEndTime\\\":1764182015339,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":22,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":23,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"9b361830-a6b3-4499-91ab-9ccf0481937c\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ab02104d-8695-4b1a-8120-ef06ae1687cf\\\",\\\"runStartTime\\\":1764182020408,\\\"runEndTime\\\":1764182020445,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":23,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":17,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"0ee02236-5196-4bc5-8010-8b9b4d6e748a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"UmVtb3ZpbmcgZGF0YSBiZWZvcmUgMjAxOS0xMS0wMSAoZmlyc3QgMSBtb250aHMpCk5hTiByb3dzIGFmdGVyIGN1dG9mZiByZW1vdmFsOiAxNzMgLyA1MzIyMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"6b9a7617-09f3-4f74-a636-6946075ccdaa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":17,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+OTE1MS4yPC90ZD4KICAgICAgPHRkPjkxNTUuODwvdGQ+CiAgICAgIDx0ZD45MTE1LjA8L3RkPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjExNzQuMDwvdGQ+CiAgICAgIDx0ZD43LjA8L3RkPgogICAgICA8dGQ+MTcuMDwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MS4wODg3NzM8L3RkPgogICAgICA8dGQ+MC4xMjUwNzQ8L3RkPgogICAgICA8dGQ+MC4xMjE1Mjc8L3RkPgogICAgICA8dGQ+LTQuNjkxMjk2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC41NzIwODI8L3RkPgogICAgICA8dGQ+MS4xNDQxNjM8L3RkPgogICAgICA8dGQ+MC4wMDYzODc8L3RkPgogICAgICA8dGQ+MC4wMDgzNjg8L3RkPgogICAgICA8dGQ+MC4wMDU5MDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDE6MDA6MDA8L3RoPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjkxNDkuMDwvdGQ+CiAgICAgIDx0ZD45MTA4Ljg8L3RkPgogICAgICA8dGQ+OTEwOC44PC90ZD4KICAgICAgPHRkPjk4Ny4wPC90ZD4KICAgICAgPHRkPjYuMDwvdGQ+CiAgICAgIDx0ZD4xOC4wPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjExNzU4ODwvdGQ+CiAgICAgIDx0ZD4wLjEyNzYwNzwvdGQ+CiAgICAgIDx0ZD4wLjEyMjMwNTwvdGQ+CiAgICAgIDx0ZD4tMy45NzQ1NTQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MTUwODwvdGQ+CiAgICAgIDx0ZD4xLjI4MzAxNzwvdGQ+CiAgICAgIDx0ZD4wLjAwNjYxMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTY4NjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD45MTA4Ljk8L3RkPgogICAgICA8dGQ+OTE0OC44PC90ZD4KICAgICAgPHRkPjkwNzUuMjwvdGQ+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+MTY1NS4wPC90ZD4KICAgICAgPHRkPjUuMDwvdGQ+CiAgICAgIDx0ZD4xOS4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjA2MzkxNDwvdGQ+CiAgICAgIDx0ZD4wLjEwMDA5NTwvdGQ+CiAgICAgIDx0ZD4wLjA5ODQ5NzwvdGQ+CiAgICAgIDx0ZD4tNS4yMzE1OTY8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2MTY3MjwvdGQ+CiAgICAgIDx0ZD4wLjkyMzM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MjwvdGQ+CiAgICAgIDx0ZD4wLjAwNDgyNjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+OTEzNy4zPC90ZD4KICAgICAgPHRkPjkwNjEuNTwvdGQ+CiAgICAgIDx0ZD45MDgyLjk8L3RkPgogICAgICA8dGQ+MTMxNS4wPC90ZD4KICAgICAgPHRkPjQuMDwvdGQ+CiAgICAgIDx0ZD4yMC4wPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjU2ODcyODwvdGQ+CiAgICAgIDx0ZD4wLjAyMzk2MTwvdGQ+CiAgICAgIDx0ZD4wLjA2NDc3NTwvdGQ+CiAgICAgIDx0ZD4tMi4yNTMwMjg8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MDM4NzwvdGQ+CiAgICAgIDx0ZD4xLjI4MDc3NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzUyOTwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTAwMTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwNDowMDowMDwvdGg+CiAgICAgIDx0ZD45MDgzLjA8L3RkPgogICAgICA8dGQ+OTEyMy40PC90ZD4KICAgICAgPHRkPjkwNjAuMDwvdGQ+CiAgICAgIDx0ZD45MDk5Ljc8L3RkPgogICAgICA8dGQ+MTQ5Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjQ3ODcwNTwvdGQ+CiAgICAgIDx0ZD4tMC4xMTQ3NTA8L3RkPgogICAgICA8dGQ+MC4wNjk5MDk8L3RkPgogICAgICA8dGQ+LTQuNDI4MDIzPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42NjE0ODg8L3RkPgogICAgICA8dGQ+MS4zMjI5NzY8L3RkPgogICAgICA8dGQ+MC4wMDY3MTk8L3RkPgogICAgICA8dGQ+MC4wMDgyNzM8L3RkPgogICAgICA8dGQ+MC4wMDU1NDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40NjczNzM8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDYzOTM8L3RkPgogICAgICA8dGQ+MC4wMDU0ODM8L3RkPgogICAgICA8dGQ+MC4wMDM4NjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc4NzIuNzwvdGQ+CiAgICAgIDx0ZD44Nzg4MS44PC90ZD4KICAgICAgPHRkPjg3MzQyLjk8L3RkPgogICAgICA8dGQ+ODczNjEuNzwvdGQ+CiAgICAgIDx0ZD4yMzIuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMTQ1NzI8L3RkPgogICAgICA8dGQ+LTEuMTE1MjQyPC90ZD4KICAgICAgPHRkPjAuMDI2OTcyPC90ZD4KICAgICAgPHRkPi02LjMxODY5MTwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMjQ5NTAxPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA3MjA0PC90ZD4KICAgICAgPHRkPjAuMDA1NDgxPC90ZD4KICAgICAgPHRkPjAuMDAzNDI3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjg3MzUzLjU8L3RkPgogICAgICA8dGQ+ODczOTYuNzwvdGQ+CiAgICAgIDx0ZD44NjYyNy45PC90ZD4KICAgICAgPHRkPjg2Nzc2LjI8L3RkPgogICAgICA8dGQ+NTY3LjA8L3RkPgogICAgICA8dGQ+MjIuMDwvdGQ+CiAgICAgIDx0ZD4yLjA8L3RkPgogICAgICA8dGQ+MTA8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wNTQ3OTc8L3RkPgogICAgICA8dGQ+LTEuMTM5NTQ0PC90ZD4KICAgICAgPHRkPjAuMDMwMTI2PC90ZD4KICAgICAgPHRkPi00Ljk4OTM3NjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMDkyNzIwPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA1NjY4PC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA0MzY3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTc0NjE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDgxOTg8L3RkPgogICAgICA8dGQ+MC4wMDU1MDM8L3RkPgogICAgICA8dGQ+MC4wMDMwMjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTE6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44Njg3OS43PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+ODY4MTguODwvdGQ+CiAgICAgIDx0ZD41LjA8L3RkPgogICAgICA8dGQ+MjAuMDwvdGQ+CiAgICAgIDx0ZD40LjA8L3RkPgogICAgICA8dGQ+MTI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wOTQ4NTk8L3RkPgogICAgICA8dGQ+LTAuOTQzNTkzPC90ZD4KICAgICAgPHRkPjAuMDMyOTE1PC90ZD4KICAgICAgPHRkPi01LjQwNjkwMzwvdGQ+CiAgICAgIDx0ZD4mbHQ7TkEmZ3Q7PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+MC4wMDk1NTA8L3RkPgogICAgICA8dGQ+MC4wMDU0Nzg8L3RkPgogICAgICA8dGQ+MC4wMDI1ODM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD41MzIyMCByb3dzIMOXIDQ1NiBjb2x1bW5zPC9wPgo8L2Rpdj4=\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICA5MTUxLjIgICA5MTU1LjggICA5MTE1LjAgICA5MTM1LjAgIDExNzQuMCAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgOTEzNS4wICAgOTE0OS4wICAgOTEwOC44ICAgOTEwOC44ICAgOTg3LjAgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgIDkxMDguOSAgIDkxNDguOCAgIDkwNzUuMiAgIDkxMzcuMyAgMTY1NS4wICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICA5MTM3LjMgICA5MTM3LjMgICA5MDYxLjUgICA5MDgyLjkgIDEzMTUuMCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgOTA4My4wICAgOTEyMy40ICAgOTA2MC4wICAgOTA5OS43ICAxNDk2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgIDg3NzI1LjIgIDg3OTAwLjAgIDg3NjM3LjcgIDg3ODcyLjYgICAxOTUuMCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICA4Nzg3Mi43ICA4Nzg4MS44ICA4NzM0Mi45ICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgODczNTMuNSAgODczOTYuNyAgODY2MjcuOSAgODY3NzYuMiAgIDU2Ny4wICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgIDg2NzcyLjIgIDg2OTk5LjkgIDg2NTk1LjggIDg2ODc5LjcgICAxOTUuMCAgIAoyMDI1LTExLTI2IDExOjAwOjAwICA4Njg3OS43ICA4Njg3OS43ICA4NjgxOC44ICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTExLTAxIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA0ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNCAgIAoyMDE5LTExLTAxIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA0ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAxLjA4ODc3MyAgICAgICAgICAgICAgMC4xMjUwNzQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDEuMTE3NTg4ICAgICAgICAgICAgICAwLjEyNzYwNyAgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMS4wNjM5MTQgICAgICAgICAgICAgIDAuMTAwMDk1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjU2ODcyOCAgICAgICAgICAgICAgMC4wMjM5NjEgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuNDc4NzA1ICAgICAgICAgICAgIC0wLjExNDc1MCAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAxMzkwMyAgICAgICAgICAgICAtMS4xNDkzOTUgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDE0NTcyICAgICAgICAgICAgIC0xLjExNTI0MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAtMC4wNTQ3OTcgICAgICAgICAgICAgLTEuMTM5NTQ0ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjEwODAzMyAgICAgICAgICAgICAtMC45ODU5MjMgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMDk0ODU5ICAgICAgICAgICAgIC0wLjk0MzU5MyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMTIxNTI3ICAgICAgICAgICAgICAgIC00LjY5MTI5NiAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgICAgICAgICAgICAwLjEyMjMwNSAgICAgICAgICAgICAgICAtMy45NzQ1NTQgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgICAgICAgICAgICAgMC4wOTg0OTcgICAgICAgICAgICAgICAgLTUuMjMxNTk2ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDY0Nzc1ICAgICAgICAgICAgICAgIC0yLjI1MzAyOCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgICAgICAgICAgICAwLjA2OTkwOSAgICAgICAgICAgICAgICAtNC40MjgwMjMgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgIDAuMDI4MDY4ICAgICAgICAgICAgICAgIC0xLjk3MjA0MCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAwLjAyNjk3MiAgICAgICAgICAgICAgICAtNi4zMTg2OTEgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgMC4wMzAxMjYgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgIDAuMDMzNjQzICAgICAgICAgICAgICAgICA3LjEzMDI3MiAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAwLjAzMjkxNSAgICAgICAgICAgICAgICAtNS40MDY5MDMgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNTcyMDgyICAgICAgICAgIDEuMTQ0MTYzICAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQxNTA4ICAgICAgICAgIDEuMjgzMDE3ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDYxNjcyICAgICAgICAgIDAuOTIzMzQ1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQwMzg3ICAgICAgICAgIDEuMjgwNzc1ICAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjYxNDg4ICAgICAgICAgIDEuMzIyOTc2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgPE5BPiAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgTmFOICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMS0wMSAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM4NyAgICAgMC4wMDgzNjggICAgICAwLjAwNTkwMCAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY2MTAgICAgIDAuMDA4MzQ1ICAgICAgMC4wMDU2ODYgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3ODA0ICAgICAwLjAwODM2MiAgICAgIDAuMDA0ODI2ICAKMjAxOS0xMS0wMSAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzUyOSAgICAgMC4wMDgzNjEgICAgICAwLjAwNTAwMSAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY3MTkgICAgIDAuMDA4MjczICAgICAgMC4wMDU1NDYgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM5MyAgICAgMC4wMDU0ODMgICAgICAwLjAwMzg2MyAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDcyMDQgICAgIDAuMDA1NDgxICAgICAgMC4wMDM0MjcgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA1NjY4ICAgICAwLjAwNTQ5NSAgICAgIDAuMDA0MzY3ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAwLjAwODE5OCAgICAgMC4wMDU1MDMgICAgICAwLjAwMzAyMyAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDk1NTAgICAgIDAuMDA1NDc4ICAgICAgMC4wMDI1ODMgIAoKWzUzMjIwIHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\\\\nmonths_to_drop = 1  # Only 1 month for small dataset\\\\ntail_rows_to_drop = 11\\\\n\\\\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\\\\nprint(f\\\\\\\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\\\\\\\")\\\\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\\\\n\\\\n\\\\nnan_mask_clean = combined_df_clean.isna().any(axis=1)\\\\nprint(f\\\\\\\"NaN rows after cutoff removal: {nan_mask_clean.sum()} / {combined_df_clean.shape[0]}\\\\\\\")\\\\ncombined_df_clean\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"12d0618e-4a5b-45a0-b040-8fb4aa1c38e9\\\",\\\"runStartTime\\\":1764180761320,\\\"runEndTime\\\":1764180761376,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":17,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"\\\\n\\\\n\\\\nif tail_rows_to_drop > 0:\\\\n    print(f\\\\\\\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\\\\\\\")\\\\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\\\\n\\\\nprint(f\\\\\\\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n\\\\n# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Quick NaN check on training data\\\\ntrain_nans = X_train.isna().sum()\\\\nif train_nans.sum() > 0:\\\\n    print(f\\\\\\\"\\\\\\\\n Training features with NaNs: {(train_nans > 0).sum()} columns\\\\\\\")\\\\n    print(f\\\\\\\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in training features\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":59,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_3676fdae-cdcc-4867-91e4-99d4b4c0f9a6",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3676fdae-cdcc-4867-91e4-99d4b4c0f9a6","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":20,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"39c9d8e5-7b7b-4cef-bbd1-36bef455dfff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"957df78c-8e58-4b2b-a850-5a7c258f1de4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"8289a205-2f21-4755-8d5c-52f78aa08186\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjcwcyBbc3RhdGVsZXNzOjI1MC4ybXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTMuMm1zLCByb2xsaW5nOjY1Mi4zbXMsIHByZXZfd2Vla19jeWNsZTo0Ni43bXMsIGN1cnJlbnRfY3ljbGU6OTI5NC4wbXMsIG5vbl9saW5lYXI6MjQ5LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy45bXMsIGNsZWFudXA6MTY2LjRtc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC43MXMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM1MS4wM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzUxLjAzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":20,\\\"executionId\\\":\\\"2437fd19-fa6b-4462-bb05-1c7f2dcfb249\\\",\\\"runStartTime\\\":1764181303307,\\\"runEndTime\\\":1764182000332,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":22,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"68affb76-e55e-499e-a125-82d3835cf62f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = True  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"04e86cbb-66d4-4a7d-b484-0992182967e2\\\",\\\"runStartTime\\\":1764182014900,\\\"runEndTime\\\":1764182015339,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":22,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":23,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"9b361830-a6b3-4499-91ab-9ccf0481937c\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ab02104d-8695-4b1a-8120-ef06ae1687cf\\\",\\\"runStartTime\\\":1764182020408,\\\"runEndTime\\\":1764182020445,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":23,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"0ee02236-5196-4bc5-8010-8b9b4d6e748a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"UmVtb3ZpbmcgZGF0YSBiZWZvcmUgMjAxOS0xMS0wMSAoZmlyc3QgMSBtb250aHMpCk5hTiByb3dzIGFmdGVyIGN1dG9mZiByZW1vdmFsOiAxNzMgLyA1MzIyMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"6b9a7617-09f3-4f74-a636-6946075ccdaa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":17,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+OTE1MS4yPC90ZD4KICAgICAgPHRkPjkxNTUuODwvdGQ+CiAgICAgIDx0ZD45MTE1LjA8L3RkPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjExNzQuMDwvdGQ+CiAgICAgIDx0ZD43LjA8L3RkPgogICAgICA8dGQ+MTcuMDwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MS4wODg3NzM8L3RkPgogICAgICA8dGQ+MC4xMjUwNzQ8L3RkPgogICAgICA8dGQ+MC4xMjE1Mjc8L3RkPgogICAgICA8dGQ+LTQuNjkxMjk2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC41NzIwODI8L3RkPgogICAgICA8dGQ+MS4xNDQxNjM8L3RkPgogICAgICA8dGQ+MC4wMDYzODc8L3RkPgogICAgICA8dGQ+MC4wMDgzNjg8L3RkPgogICAgICA8dGQ+MC4wMDU5MDA8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTEtMDEgMDE6MDA6MDA8L3RoPgogICAgICA8dGQ+OTEzNS4wPC90ZD4KICAgICAgPHRkPjkxNDkuMDwvdGQ+CiAgICAgIDx0ZD45MTA4Ljg8L3RkPgogICAgICA8dGQ+OTEwOC44PC90ZD4KICAgICAgPHRkPjk4Ny4wPC90ZD4KICAgICAgPHRkPjYuMDwvdGQ+CiAgICAgIDx0ZD4xOC4wPC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjExNzU4ODwvdGQ+CiAgICAgIDx0ZD4wLjEyNzYwNzwvdGQ+CiAgICAgIDx0ZD4wLjEyMjMwNTwvdGQ+CiAgICAgIDx0ZD4tMy45NzQ1NTQ8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MTUwODwvdGQ+CiAgICAgIDx0ZD4xLjI4MzAxNzwvdGQ+CiAgICAgIDx0ZD4wLjAwNjYxMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTY4NjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD45MTA4Ljk8L3RkPgogICAgICA8dGQ+OTE0OC44PC90ZD4KICAgICAgPHRkPjkwNzUuMjwvdGQ+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+MTY1NS4wPC90ZD4KICAgICAgPHRkPjUuMDwvdGQ+CiAgICAgIDx0ZD4xOS4wPC90ZD4KICAgICAgPHRkPjM8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4xLjA2MzkxNDwvdGQ+CiAgICAgIDx0ZD4wLjEwMDA5NTwvdGQ+CiAgICAgIDx0ZD4wLjA5ODQ5NzwvdGQ+CiAgICAgIDx0ZD4tNS4yMzE1OTY8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2MTY3MjwvdGQ+CiAgICAgIDx0ZD4wLjkyMzM0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzgwNDwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MjwvdGQ+CiAgICAgIDx0ZD4wLjAwNDgyNjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD45MTM3LjM8L3RkPgogICAgICA8dGQ+OTEzNy4zPC90ZD4KICAgICAgPHRkPjkwNjEuNTwvdGQ+CiAgICAgIDx0ZD45MDgyLjk8L3RkPgogICAgICA8dGQ+MTMxNS4wPC90ZD4KICAgICAgPHRkPjQuMDwvdGQ+CiAgICAgIDx0ZD4yMC4wPC90ZD4KICAgICAgPHRkPjQ8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjU2ODcyODwvdGQ+CiAgICAgIDx0ZD4wLjAyMzk2MTwvdGQ+CiAgICAgIDx0ZD4wLjA2NDc3NTwvdGQ+CiAgICAgIDx0ZD4tMi4yNTMwMjg8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjY0MDM4NzwvdGQ+CiAgICAgIDx0ZD4xLjI4MDc3NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNzUyOTwvdGQ+CiAgICAgIDx0ZD4wLjAwODM2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTAwMTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMS0wMSAwNDowMDowMDwvdGg+CiAgICAgIDx0ZD45MDgzLjA8L3RkPgogICAgICA8dGQ+OTEyMy40PC90ZD4KICAgICAgPHRkPjkwNjAuMDwvdGQ+CiAgICAgIDx0ZD45MDk5Ljc8L3RkPgogICAgICA8dGQ+MTQ5Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjQ3ODcwNTwvdGQ+CiAgICAgIDx0ZD4tMC4xMTQ3NTA8L3RkPgogICAgICA8dGQ+MC4wNjk5MDk8L3RkPgogICAgICA8dGQ+LTQuNDI4MDIzPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42NjE0ODg8L3RkPgogICAgICA8dGQ+MS4zMjI5NzY8L3RkPgogICAgICA8dGQ+MC4wMDY3MTk8L3RkPgogICAgICA8dGQ+MC4wMDgyNzM8L3RkPgogICAgICA8dGQ+MC4wMDU1NDY8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPi4uLjwvdGg+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwNzowMDowMDwvdGg+CiAgICAgIDx0ZD44NzcyNS4yPC90ZD4KICAgICAgPHRkPjg3OTAwLjA8L3RkPgogICAgICA8dGQ+ODc2MzcuNzwvdGQ+CiAgICAgIDx0ZD44Nzg3Mi42PC90ZD4KICAgICAgPHRkPjE5NS4wPC90ZD4KICAgICAgPHRkPjI0LjA8L3RkPgogICAgICA8dGQ+MC4wPC90ZD4KICAgICAgPHRkPjg8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxMzkwMzwvdGQ+CiAgICAgIDx0ZD4tMS4xNDkzOTU8L3RkPgogICAgICA8dGQ+MC4wMjgwNjg8L3RkPgogICAgICA8dGQ+LTEuOTcyMDQwPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC40NjczNzM8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDYzOTM8L3RkPgogICAgICA8dGQ+MC4wMDU0ODM8L3RkPgogICAgICA8dGQ+MC4wMDM4NjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDg6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc4NzIuNzwvdGQ+CiAgICAgIDx0ZD44Nzg4MS44PC90ZD4KICAgICAgPHRkPjg3MzQyLjk8L3RkPgogICAgICA8dGQ+ODczNjEuNzwvdGQ+CiAgICAgIDx0ZD4yMzIuMDwvdGQ+CiAgICAgIDx0ZD4yMy4wPC90ZD4KICAgICAgPHRkPjEuMDwvdGQ+CiAgICAgIDx0ZD45PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMTQ1NzI8L3RkPgogICAgICA8dGQ+LTEuMTE1MjQyPC90ZD4KICAgICAgPHRkPjAuMDI2OTcyPC90ZD4KICAgICAgPHRkPi02LjMxODY5MTwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMjQ5NTAxPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA3MjA0PC90ZD4KICAgICAgPHRkPjAuMDA1NDgxPC90ZD4KICAgICAgPHRkPjAuMDAzNDI3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA5OjAwOjAwPC90aD4KICAgICAgPHRkPjg3MzUzLjU8L3RkPgogICAgICA8dGQ+ODczOTYuNzwvdGQ+CiAgICAgIDx0ZD44NjYyNy45PC90ZD4KICAgICAgPHRkPjg2Nzc2LjI8L3RkPgogICAgICA8dGQ+NTY3LjA8L3RkPgogICAgICA8dGQ+MjIuMDwvdGQ+CiAgICAgIDx0ZD4yLjA8L3RkPgogICAgICA8dGQ+MTA8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wNTQ3OTc8L3RkPgogICAgICA8dGQ+LTEuMTM5NTQ0PC90ZD4KICAgICAgPHRkPjAuMDMwMTI2PC90ZD4KICAgICAgPHRkPi00Ljk4OTM3NjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMDkyNzIwPC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA1NjY4PC90ZD4KICAgICAgPHRkPjAuMDA1NDk1PC90ZD4KICAgICAgPHRkPjAuMDA0MzY3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDEwOjAwOjAwPC90aD4KICAgICAgPHRkPjg2NzcyLjI8L3RkPgogICAgICA8dGQ+ODY5OTkuOTwvdGQ+CiAgICAgIDx0ZD44NjU5NS44PC90ZD4KICAgICAgPHRkPjg2ODc5Ljc8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjEuMDwvdGQ+CiAgICAgIDx0ZD4zLjA8L3RkPgogICAgICA8dGQ+MTE8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4xMDgwMzM8L3RkPgogICAgICA8dGQ+LTAuOTg1OTIzPC90ZD4KICAgICAgPHRkPjAuMDMzNjQzPC90ZD4KICAgICAgPHRkPjcuMTMwMjcyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wMTc0NjE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDgxOTg8L3RkPgogICAgICA8dGQ+MC4wMDU1MDM8L3RkPgogICAgICA8dGQ+MC4wMDMwMjM8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTE6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD44Njg3OS43PC90ZD4KICAgICAgPHRkPjg2ODE4Ljg8L3RkPgogICAgICA8dGQ+ODY4MTguODwvdGQ+CiAgICAgIDx0ZD41LjA8L3RkPgogICAgICA8dGQ+MjAuMDwvdGQ+CiAgICAgIDx0ZD40LjA8L3RkPgogICAgICA8dGQ+MTI8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4wOTQ4NTk8L3RkPgogICAgICA8dGQ+LTAuOTQzNTkzPC90ZD4KICAgICAgPHRkPjAuMDMyOTE1PC90ZD4KICAgICAgPHRkPi01LjQwNjkwMzwvdGQ+CiAgICAgIDx0ZD4mbHQ7TkEmZ3Q7PC90ZD4KICAgICAgPHRkPk5hTjwvdGQ+CiAgICAgIDx0ZD5OYU48L3RkPgogICAgICA8dGQ+MC4wMDk1NTA8L3RkPgogICAgICA8dGQ+MC4wMDU0Nzg8L3RkPgogICAgICA8dGQ+MC4wMDI1ODM8L3RkPgogICAgPC90cj4KICA8L3Rib2R5Pgo8L3RhYmxlPgo8cD41MzIyMCByb3dzIMOXIDQ1NiBjb2x1bW5zPC9wPgo8L2Rpdj4=\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICA5MTUxLjIgICA5MTU1LjggICA5MTE1LjAgICA5MTM1LjAgIDExNzQuMCAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgOTEzNS4wICAgOTE0OS4wICAgOTEwOC44ICAgOTEwOC44ICAgOTg3LjAgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgIDkxMDguOSAgIDkxNDguOCAgIDkwNzUuMiAgIDkxMzcuMyAgMTY1NS4wICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICA5MTM3LjMgICA5MTM3LjMgICA5MDYxLjUgICA5MDgyLjkgIDEzMTUuMCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgOTA4My4wICAgOTEyMy40ICAgOTA2MC4wICAgOTA5OS43ICAxNDk2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgIDg3NzI1LjIgIDg3OTAwLjAgIDg3NjM3LjcgIDg3ODcyLjYgICAxOTUuMCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICA4Nzg3Mi43ICA4Nzg4MS44ICA4NzM0Mi45ICA4NzM2MS43ICAgMjMyLjAgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgODczNTMuNSAgODczOTYuNyAgODY2MjcuOSAgODY3NzYuMiAgIDU2Ny4wICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgIDg2NzcyLjIgIDg2OTk5LjkgIDg2NTk1LjggIDg2ODc5LjcgICAxOTUuMCAgIAoyMDI1LTExLTI2IDExOjAwOjAwICA4Njg3OS43ICA4Njg3OS43ICA4NjgxOC44ICA4NjgxOC44ICAgICA1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTExLTAxIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA0ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNCAgIAoyMDE5LTExLTAxIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDQgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA0ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgIDI0LjAgICAgICAgICAgIDAuMCAgICAgOCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAyMy4wICAgICAgICAgICAxLjAgICAgIDkgICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMjIuMCAgICAgICAgICAgMi4wICAgIDEwICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgIDIxLjAgICAgICAgICAgIDMuMCAgICAxMSAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgICAyMC4wICAgICAgICAgICA0LjAgICAgMTIgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAxLjA4ODc3MyAgICAgICAgICAgICAgMC4xMjUwNzQgICAKMjAxOS0xMS0wMSAwMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDEuMTE3NTg4ICAgICAgICAgICAgICAwLjEyNzYwNyAgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMS4wNjM5MTQgICAgICAgICAgICAgIDAuMTAwMDk1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjU2ODcyOCAgICAgICAgICAgICAgMC4wMjM5NjEgICAKMjAxOS0xMS0wMSAwNDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuNDc4NzA1ICAgICAgICAgICAgIC0wLjExNDc1MCAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAxMzkwMyAgICAgICAgICAgICAtMS4xNDkzOTUgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDE0NTcyICAgICAgICAgICAgIC0xLjExNTI0MiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAtMC4wNTQ3OTcgICAgICAgICAgICAgLTEuMTM5NTQ0ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjEwODAzMyAgICAgICAgICAgICAtMC45ODU5MjMgICAKMjAyNS0xMS0yNiAxMTowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMDk0ODU5ICAgICAgICAgICAgIC0wLjk0MzU5MyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMTIxNTI3ICAgICAgICAgICAgICAgIC00LjY5MTI5NiAgIAoyMDE5LTExLTAxIDAxOjAwOjAwICAgICAgICAgICAgICAwLjEyMjMwNSAgICAgICAgICAgICAgICAtMy45NzQ1NTQgICAKMjAxOS0xMS0wMSAwMjowMDowMCAgICAgICAgICAgICAgMC4wOTg0OTcgICAgICAgICAgICAgICAgLTUuMjMxNTk2ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDY0Nzc1ICAgICAgICAgICAgICAgIC0yLjI1MzAyOCAgIAoyMDE5LTExLTAxIDA0OjAwOjAwICAgICAgICAgICAgICAwLjA2OTkwOSAgICAgICAgICAgICAgICAtNC40MjgwMjMgICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgIDAuMDI4MDY4ICAgICAgICAgICAgICAgIC0xLjk3MjA0MCAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAwLjAyNjk3MiAgICAgICAgICAgICAgICAtNi4zMTg2OTEgICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgMC4wMzAxMjYgICAgICAgICAgICAgICAgLTQuOTg5Mzc2ICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgIDAuMDMzNjQzICAgICAgICAgICAgICAgICA3LjEzMDI3MiAgIAoyMDI1LTExLTI2IDExOjAwOjAwICAgICAgICAgICAgICAwLjAzMjkxNSAgICAgICAgICAgICAgICAtNS40MDY5MDMgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTEtMDEgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNTcyMDgyICAgICAgICAgIDEuMTQ0MTYzICAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQxNTA4ICAgICAgICAgIDEuMjgzMDE3ICAgCjIwMTktMTEtMDEgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDYxNjcyICAgICAgICAgIDAuOTIzMzQ1ICAgCjIwMTktMTEtMDEgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjQwMzg3ICAgICAgICAgIDEuMjgwNzc1ICAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjYxNDg4ICAgICAgICAgIDEuMzIyOTc2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgPE5BPiAgICAgICAgICAgICAgTmFOICAgICAgICAgICAgICAgTmFOICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMS0wMSAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM4NyAgICAgMC4wMDgzNjggICAgICAwLjAwNTkwMCAgCjIwMTktMTEtMDEgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY2MTAgICAgIDAuMDA4MzQ1ICAgICAgMC4wMDU2ODYgIAoyMDE5LTExLTAxIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3ODA0ICAgICAwLjAwODM2MiAgICAgIDAuMDA0ODI2ICAKMjAxOS0xMS0wMSAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzUyOSAgICAgMC4wMDgzNjEgICAgICAwLjAwNTAwMSAgCjIwMTktMTEtMDEgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDY3MTkgICAgIDAuMDA4MjczICAgICAgMC4wMDU1NDYgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAgICAwLjAwNjM5MyAgICAgMC4wMDU0ODMgICAgICAwLjAwMzg2MyAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDcyMDQgICAgIDAuMDA1NDgxICAgICAgMC4wMDM0MjcgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA1NjY4ICAgICAwLjAwNTQ5NSAgICAgIDAuMDA0MzY3ICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAgICAwLjAwODE5OCAgICAgMC4wMDU1MDMgICAgICAwLjAwMzAyMyAgCjIwMjUtMTEtMjYgMTE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDk1NTAgICAgIDAuMDA1NDc4ICAgICAgMC4wMDI1ODMgIAoKWzUzMjIwIHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe based on actual NaN patterns\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\n# Drop rows with NaNs (all at the start from lookback windows)\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\nfirst_clean_idx = combined_df[~rows_with_nans].index[0]\\\\n\\\\nprint(f\\\\\\\"First row without NaNs: {first_clean_idx}\\\\\\\")\\\\nprint(f\\\\\\\"Dropping {rows_with_nans.sum()} rows with NaNs (all at start)\\\\\\\")\\\\n\\\\ncombined_df_clean = combined_df[~rows_with_nans].copy()\\\\n\\\\nprint(f\\\\\\\"Rows after NaN removal: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\nprint(f\\\\\\\"Date range: {(combined_df_clean.index[-1] - combined_df_clean.index[0]).days} days\\\\\\\")\\\\n\\\\n# Final check\\\\nfinal_nan_check = combined_df_clean.isna().sum().sum()\\\\nprint(f\\\\\\\"\\\\\\\\nFinal NaN check: {final_nan_check} total NaNs remaining\\\\\\\")\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"12d0618e-4a5b-45a0-b040-8fb4aa1c38e9\\\",\\\"runStartTime\\\":1764180761320,\\\"runEndTime\\\":1764180761376,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":17,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":63,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_338f27d9-6b23-4aad-a745-773b1b4384a6",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_338f27d9-6b23-4aad-a745-773b1b4384a6","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":20,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"39c9d8e5-7b7b-4cef-bbd1-36bef455dfff\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pyTIFVzaW5nIGhlYXZ5IGNhY2hlIChvbmx5IHByZXZfY3ljbGUgZmVhdHVyZXMgY2FjaGVkKQogIE5vdGU6IFJvbGxpbmcvc3RhdGVsZXNzIGZlYXR1cmVzIHN0aWxsIGNvbXB1dGVkIG9uLXRoZS1mbHkK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"957df78c-8e58-4b2b-a850-5a7c258f1de4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTgyOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg5OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA1OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDU6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxNjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjE6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NTogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2Nzg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MDogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"8289a205-2f21-4755-8d5c-52f78aa08186\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjcwcyBbc3RhdGVsZXNzOjI1MC4ybXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTMuMm1zLCByb2xsaW5nOjY1Mi4zbXMsIHByZXZfd2Vla19jeWNsZTo0Ni43bXMsIGN1cnJlbnRfY3ljbGU6OTI5NC4wbXMsIG5vbl9saW5lYXI6MjQ5LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyNy45bXMsIGNsZWFudXA6MTY2LjRtc10KICBGZWF0dXJlcyBjb21wdXRlZCBpbiAxMC43MXMgLT4gc2hhcGU6ICg1Mzk2NCwgNDUwKQoKLS0tIEJ1aWxkaW5nIFZvbGF0aWxpdHkgUmVnaW1lIFRhcmdldHMgLS0tClJlZ2ltZSB0YXJnZXRzIGJ1aWx0IGluIDM1MS4wM3MgLT4gc2hhcGU6ICg1Mzk2NCwgNikKUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzUxLjAzcyAtPiBzaGFwZTogKDUzOTY0LCA2KQoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwoKUmVnaW1lIGRpc3RyaWJ1dGlvbjoKcmVnaW1lX2xhYmVsCjAgICAgNDM2NzMKMSAgICAgNjM2NAoyICAgICAzNzk1Ck5hbWU6IGNvdW50LCBkdHlwZTogSW50NjQKCkNvbWJpbmVkIHNoYXBlOiAoNTM5NjQsIDQ1NikKVG90YWwgcGlwZWxpbmUgdGltZTogNjk3LjAycwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\n\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":20,\\\"executionId\\\":\\\"2437fd19-fa6b-4462-bb05-1c7f2dcfb249\\\",\\\"runStartTime\\\":1764181303307,\\\"runEndTime\\\":1764182000332,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"51ceeab3-bab2-4ddf-a6c5-4377304cd349\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ1cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDVzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d5166470-6de3-439e-a279-3211bd1a8b86\\\",\\\"runStartTime\\\":1764182243319,\\\"runEndTime\\\":1764182243771,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":27,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":28,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"6741a3fb-46d3-4516-8e3a-b44022148595\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f25079d2-1f04-4b8c-b7e2-fa0d4a1b088c\\\",\\\"runStartTime\\\":1764182252111,\\\"runEndTime\\\":1764182252146,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":28,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":29,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1b307f9d-2b9f-4616-ab21-af960825712a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiAxNzIKICDimqDvuI8gV0FSTklORzogMTcyIHJvd3Mgd2l0aCBOYU5zIGluIG1pZGRsZSAtIHByZXNlcnZlZCBmb3IgZGVidWdnaW5nCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"090b7518-b4be-43f7-b468-ad9737c52cad\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":29,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"b067ce73-86f6-41a8-b8c1-b2459790bdd2\\\",\\\"runStartTime\\\":1764182260747,\\\"runEndTime\\\":1764182260878,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":29,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":5}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":66,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_18c89704-8cd3-4be9-b079-5a7dee1a30c8",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_18c89704-8cd3-4be9-b079-5a7dee1a30c8","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"615ead44-ff48-4e72-9aee-67ec601adca9\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"a57be68e-3ac9-46b7-8f30-b5a581205edc\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"1bc9ff45-3b6d-4f34-8fa7-fe9657c72c48\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3My4zOHMgW3N0YXRlbGVzczoyNTEuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi40bXMsIHRlbXBvcmFsOjE1Ljdtcywgcm9sbGluZzo2NDIuMG1zLCBwcmV2X3dlZWtfY3ljbGU6MTYzMTU1LjdtcywgY3VycmVudF9jeWNsZTo4ODU3Ljltcywgbm9uX2xpbmVhcjoyNjUuMW1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI3LjBtcywgY2xlYW51cDoxNjcuMm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3My4zOXMKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"2ea509ce-3f27-4495-8076-aeda24f5885f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"c161b715-15fb-48fe-86fe-81ba4102ba89\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjUxcyBbc3RhdGVsZXNzOjIzNC43bXMsIG1lcmdlX3N0YXRlbGVzczoyLjFtcywgdGVtcG9yYWw6MTIuOW1zLCByb2xsaW5nOjYzOS4xbXMsIHByZXZfd2Vla19jeWNsZTo1MS45bXMsIGN1cnJlbnRfY3ljbGU6OTEwNi40bXMsIG5vbl9saW5lYXI6MjY0LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC41bXMsIGNsZWFudXA6MTY4Ljdtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC41MXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgzLjkwcyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQwLjAxcyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzNDAuMDFzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"178989f5-8687-46f0-b21f-bc1b143e632f\\\",\\\"runStartTime\\\":1764185671734,\\\"runEndTime\\\":1764186534299,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":10},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1e433f26-e798-4901-829c-0804468fbbbd\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"611eba9d-4d5b-465d-8905-9338cb65b928\\\",\\\"runStartTime\\\":1764186605776,\\\"runEndTime\\\":1764186606218,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":5,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":28,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"6741a3fb-46d3-4516-8e3a-b44022148595\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f25079d2-1f04-4b8c-b7e2-fa0d4a1b088c\\\",\\\"runStartTime\\\":1764182252111,\\\"runEndTime\\\":1764182252146,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":28,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":6,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"accf8b25-0e08-4d81-9852-87dc569c6e45\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"1e4fd285-3a7e-4901-8e5a-5138afbe4354\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":6,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"46972c04-f4c6-4b6a-84cb-751c7223a29f\\\",\\\"runStartTime\\\":1764186623482,\\\"runEndTime\\\":1764186623616,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":6,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"source\\\":\\\"# Analyze which features have the middle NaNs\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 10 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(10).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n        # Explanation\\\\n        print(f\\\\\\\"\\\\\\\\n{'='*70}\\\\\\\")\\\\n        print(\\\\\\\"Expected cause: Stochastic features produce NaN when price is flat\\\\\\\")\\\\n        print(\\\\\\\"(high == low over window  0/0 = NaN)\\\\\\\")\\\\n        print(f\\\\\\\"{'='*70}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\"}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":70,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_9d694dd5-b50c-4dd8-9cbc-d1e314dc8ebb",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_9d694dd5-b50c-4dd8-9cbc-d1e314dc8ebb","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"615ead44-ff48-4e72-9aee-67ec601adca9\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"a57be68e-3ac9-46b7-8f30-b5a581205edc\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"1bc9ff45-3b6d-4f34-8fa7-fe9657c72c48\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3My4zOHMgW3N0YXRlbGVzczoyNTEuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi40bXMsIHRlbXBvcmFsOjE1Ljdtcywgcm9sbGluZzo2NDIuMG1zLCBwcmV2X3dlZWtfY3ljbGU6MTYzMTU1LjdtcywgY3VycmVudF9jeWNsZTo4ODU3Ljltcywgbm9uX2xpbmVhcjoyNjUuMW1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI3LjBtcywgY2xlYW51cDoxNjcuMm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3My4zOXMKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"2ea509ce-3f27-4495-8076-aeda24f5885f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"c161b715-15fb-48fe-86fe-81ba4102ba89\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjUxcyBbc3RhdGVsZXNzOjIzNC43bXMsIG1lcmdlX3N0YXRlbGVzczoyLjFtcywgdGVtcG9yYWw6MTIuOW1zLCByb2xsaW5nOjYzOS4xbXMsIHByZXZfd2Vla19jeWNsZTo1MS45bXMsIGN1cnJlbnRfY3ljbGU6OTEwNi40bXMsIG5vbl9saW5lYXI6MjY0LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC41bXMsIGNsZWFudXA6MTY4Ljdtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC41MXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgzLjkwcyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQwLjAxcyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzNDAuMDFzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"178989f5-8687-46f0-b21f-bc1b143e632f\\\",\\\"runStartTime\\\":1764185671734,\\\"runEndTime\\\":1764186534299,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":10},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1e433f26-e798-4901-829c-0804468fbbbd\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"611eba9d-4d5b-465d-8905-9338cb65b928\\\",\\\"runStartTime\\\":1764186605776,\\\"runEndTime\\\":1764186606218,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":5,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":28,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"6741a3fb-46d3-4516-8e3a-b44022148595\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f25079d2-1f04-4b8c-b7e2-fa0d4a1b088c\\\",\\\"runStartTime\\\":1764182252111,\\\"runEndTime\\\":1764182252146,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":28,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":9,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ac865a40-6bfa-4dcb-88ba-acd90e05fdf2\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"638882dc-ecd7-4313-91e0-701f6f9bcd08\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":9,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"1d10b816-3ef6-4de3-b0e4-db94f40914d6\\\",\\\"runStartTime\\\":1764186715106,\\\"runEndTime\\\":1764186715237,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":7,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"96062d86-8e85-424b-8318-529fb4eeffa7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpBbmFseXppbmcgTWlkZGxlIE5hTiBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpGZWF0dXJlcyB3aXRoIG1pZGRsZSBOYU5zOiA0CgpUb3AgMjAgZmVhdHVyZXMgYnkgTmFOIGNvdW50OgogIHJlZ2ltZV9sYWJlbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA5NiBOYU5zICggMC4xOCUpCiAgbWF4X2Z3ZF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgIDk2IE5hTnMgKCAwLjE4JSkKICBtYXhfanVtcF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgOTYgTmFOcyAoIDAuMTglKQogIHZvbF9yYXRpb18yNGhfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAyMyBOYU5zICggMC4wNCUpCgpHcm91cGVkIGJ5IGZlYXR1cmUgdHlwZToKICBtYXggICAgICAgICAgICAgICAgICAgICAxOTIgdG90YWwgTmFOcwogIHJlZ2ltZSAgICAgICAgICAgICAgICAgICA5NiB0b3RhbCBOYU5zCiAgdm9sICAgICAgICAgICAgICAgICAgICAgIDIzIHRvdGFsIE5hTnMKClN0b2NoYXN0aWMgZmVhdHVyZXMgd2l0aCBOYU5zOiAwCiAg4pyTIE5vIHN0b2NoYXN0aWMgTmFOcyAtIGZpeCBpcyB3b3JraW5nIQoKRGF0ZSByYW5nZSBvZiBtaWRkbGUgTmFOczoKICBGaXJzdDogMjAyMC0wMS0wNSAxNjowMDowMAogIExhc3Q6IDIwMjAtMDEtMDkgMTY6MDA6MDAK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Analyze which features have the middle NaNs and verify stochastic fix\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 20 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(20).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Check specifically for stochastic features\\\\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\\\\n        print(f\\\\\\\"\\\\\\\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\\\\\\\")\\\\n        if stoch_features_in_nans:\\\\n            print(\\\\\\\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\\\\\\\")\\\\n            for feat in stoch_features_in_nans:\\\\n                print(f\\\\\\\"    {feat}: {features_with_middle_nans[feat]} NaNs\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"   No stochastic NaNs - fix is working!\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"29548500-873c-40a5-9b94-960e388e8e9e\\\",\\\"runStartTime\\\":1764186685717,\\\"runEndTime\\\":1764186685742,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":7,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02e8ec0b-3b6f-441d-90a6-675f52319ac7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"U3BsaXQgc2l6ZXM6CiAgVHJhaW46IDQyLDk0MCByb3dzICg4MC4wJSkKICBWYWw6ICAgNSwzNjcgcm93cyAoMTAuMCUpCiAgVGVzdDogIDUsMzY4IHJvd3MgKDEwLjAlKQoKWCBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA0NTApLCB2YWwgKDUzNjcsIDQ1MCksIHRlc3QgKDUzNjgsIDQ1MCkKeSBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA2KSwgdmFsICg1MzY3LCA2KSwgdGVzdCAoNTM2OCwgNikKCuKaoCBOYU5zIGZvdW5kOgogIFRyYWluOiAyMyBOYU5zCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d6a62885-4d1d-40be-b86b-517d649e6240\\\",\\\"runStartTime\\\":1764186701691,\\\"runEndTime\\\":1764186701778,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":8,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":73,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_668f889f-1529-48c7-a0f0-c7536b019d14",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_668f889f-1529-48c7-a0f0-c7536b019d14","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"615ead44-ff48-4e72-9aee-67ec601adca9\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"a57be68e-3ac9-46b7-8f30-b5a581205edc\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"1bc9ff45-3b6d-4f34-8fa7-fe9657c72c48\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3My4zOHMgW3N0YXRlbGVzczoyNTEuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi40bXMsIHRlbXBvcmFsOjE1Ljdtcywgcm9sbGluZzo2NDIuMG1zLCBwcmV2X3dlZWtfY3ljbGU6MTYzMTU1LjdtcywgY3VycmVudF9jeWNsZTo4ODU3Ljltcywgbm9uX2xpbmVhcjoyNjUuMW1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI3LjBtcywgY2xlYW51cDoxNjcuMm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3My4zOXMKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"2ea509ce-3f27-4495-8076-aeda24f5885f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"c161b715-15fb-48fe-86fe-81ba4102ba89\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjUxcyBbc3RhdGVsZXNzOjIzNC43bXMsIG1lcmdlX3N0YXRlbGVzczoyLjFtcywgdGVtcG9yYWw6MTIuOW1zLCByb2xsaW5nOjYzOS4xbXMsIHByZXZfd2Vla19jeWNsZTo1MS45bXMsIGN1cnJlbnRfY3ljbGU6OTEwNi40bXMsIG5vbl9saW5lYXI6MjY0LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC41bXMsIGNsZWFudXA6MTY4Ljdtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC41MXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgzLjkwcyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQwLjAxcyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzNDAuMDFzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"178989f5-8687-46f0-b21f-bc1b143e632f\\\",\\\"runStartTime\\\":1764185671734,\\\"runEndTime\\\":1764186534299,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":10},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1e433f26-e798-4901-829c-0804468fbbbd\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"611eba9d-4d5b-465d-8905-9338cb65b928\\\",\\\"runStartTime\\\":1764186605776,\\\"runEndTime\\\":1764186606218,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":5,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":28,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"6741a3fb-46d3-4516-8e3a-b44022148595\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f25079d2-1f04-4b8c-b7e2-fa0d4a1b088c\\\",\\\"runStartTime\\\":1764182252111,\\\"runEndTime\\\":1764182252146,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":28,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":9,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ac865a40-6bfa-4dcb-88ba-acd90e05fdf2\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"638882dc-ecd7-4313-91e0-701f6f9bcd08\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":9,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"1d10b816-3ef6-4de3-b0e4-db94f40914d6\\\",\\\"runStartTime\\\":1764186715106,\\\"runEndTime\\\":1764186715237,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":7,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"96062d86-8e85-424b-8318-529fb4eeffa7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpBbmFseXppbmcgTWlkZGxlIE5hTiBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpGZWF0dXJlcyB3aXRoIG1pZGRsZSBOYU5zOiA0CgpUb3AgMjAgZmVhdHVyZXMgYnkgTmFOIGNvdW50OgogIHJlZ2ltZV9sYWJlbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA5NiBOYU5zICggMC4xOCUpCiAgbWF4X2Z3ZF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgIDk2IE5hTnMgKCAwLjE4JSkKICBtYXhfanVtcF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgOTYgTmFOcyAoIDAuMTglKQogIHZvbF9yYXRpb18yNGhfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAyMyBOYU5zICggMC4wNCUpCgpHcm91cGVkIGJ5IGZlYXR1cmUgdHlwZToKICBtYXggICAgICAgICAgICAgICAgICAgICAxOTIgdG90YWwgTmFOcwogIHJlZ2ltZSAgICAgICAgICAgICAgICAgICA5NiB0b3RhbCBOYU5zCiAgdm9sICAgICAgICAgICAgICAgICAgICAgIDIzIHRvdGFsIE5hTnMKClN0b2NoYXN0aWMgZmVhdHVyZXMgd2l0aCBOYU5zOiAwCiAg4pyTIE5vIHN0b2NoYXN0aWMgTmFOcyAtIGZpeCBpcyB3b3JraW5nIQoKRGF0ZSByYW5nZSBvZiBtaWRkbGUgTmFOczoKICBGaXJzdDogMjAyMC0wMS0wNSAxNjowMDowMAogIExhc3Q6IDIwMjAtMDEtMDkgMTY6MDA6MDAK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Analyze which features have the middle NaNs and verify stochastic fix\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 20 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(20).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Check specifically for stochastic features\\\\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\\\\n        print(f\\\\\\\"\\\\\\\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\\\\\\\")\\\\n        if stoch_features_in_nans:\\\\n            print(\\\\\\\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\\\\\\\")\\\\n            for feat in stoch_features_in_nans:\\\\n                print(f\\\\\\\"    {feat}: {features_with_middle_nans[feat]} NaNs\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"   No stochastic NaNs - fix is working!\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"29548500-873c-40a5-9b94-960e388e8e9e\\\",\\\"runStartTime\\\":1764186685717,\\\"runEndTime\\\":1764186685742,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":7,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"975b86cf\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"33be4f3f-4070-428a-a604-91d308292d75\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpJbnZlc3RpZ2F0aW5nIFJlZ2ltZSBMYWJlbCBOYU5zCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClRvdGFsIHJvd3Mgd2l0aCByZWdpbWVfbGFiZWwgTmFOOiA5NgpEYXRlIHJhbmdlOiAyMDIwLTAxLTA1IDE2OjAwOjAwIHRvIDIwMjAtMDEtMDkgMTU6MDA6MDAKCkZpcnN0IDEwIE5hTiB0aW1lc3RhbXBzOgogIDIwMjAtMDEtMDUgMTY6MDA6MDAKICAyMDIwLTAxLTA1IDE3OjAwOjAwCiAgMjAyMC0wMS0wNSAxODowMDowMAogIDIwMjAtMDEtMDUgMTk6MDA6MDAKICAyMDIwLTAxLTA1IDIwOjAwOjAwCiAgMjAyMC0wMS0wNSAyMTowMDowMAogIDIwMjAtMDEtMDUgMjI6MDA6MDAKICAyMDIwLTAxLTA1IDIzOjAwOjAwCiAgMjAyMC0wMS0wNiAwMDowMDowMAogIDIwMjAtMDEtMDYgMDE6MDA6MDAKCkNoZWNraW5nIHJhdyBkYXRhIGFyb3VuZCBOYU4gcGVyaW9kOgogIFJhdyBkYXRhIHJvd3MgaW4gdGhpcyBwZXJpb2Q6IDE0NAogIEV4cGVjdGVkIHJvd3MgKGhvdXJseSk6IDE0MwogIOKckyBObyB0aW1lIGdhcHMgZm91bmQKCkZlYXR1cmUgdmFsdWVzIGR1cmluZyBOYU4gcGVyaW9kIChmaXJzdCBOYU4gcm93KToKICB2b2xfcnNfMjRoOiBOL0EKICB2b2xfcnNfNzJoOiBOL0EKICB0cmVuZF9zdHJlbmd0aF8yNGg6IDAuMAogIGxvZ3JldF8yNGg6IDAuMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Investigate why regime_label has NaNs in Jan 2020\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Investigating Regime Label NaNs\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get the rows with regime NaNs\\\\nregime_nans = combined_df_clean['regime_label'].isna()\\\\nnan_rows = combined_df_clean[regime_nans]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal rows with regime_label NaN: {regime_nans.sum()}\\\\\\\")\\\\nprint(f\\\\\\\"Date range: {nan_rows.index[0]} to {nan_rows.index[-1]}\\\\\\\")\\\\n\\\\n# Check if this is a continuous block\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 10 NaN timestamps:\\\\\\\")\\\\nfor ts in nan_rows.index[:10]:\\\\n    print(f\\\\\\\"  {ts}\\\\\\\")\\\\n\\\\n# Check the raw data around this period\\\\nif 'raw_history' in globals():\\\\n    print(f\\\\\\\"\\\\\\\\nChecking raw data around NaN period:\\\\\\\")\\\\n    check_start = nan_rows.index[0] - pd.Timedelta(hours=24)\\\\n    check_end = nan_rows.index[-1] + pd.Timedelta(hours=24)\\\\n    \\\\n    raw_slice = raw_history.loc[check_start:check_end]\\\\n    print(f\\\\\\\"  Raw data rows in this period: {len(raw_slice)}\\\\\\\")\\\\n    print(f\\\\\\\"  Expected rows (hourly): {int((check_end - check_start).total_seconds() / 3600)}\\\\\\\")\\\\n    \\\\n    # Check for gaps\\\\n    if len(raw_slice) > 0:\\\\n        time_diffs = raw_slice.index.to_series().diff()\\\\n        gaps = time_diffs[time_diffs > pd.Timedelta(hours=1)]\\\\n        if len(gaps) > 0:\\\\n            print(f\\\\\\\"\\\\\\\\n   Found {len(gaps)} time gaps:\\\\\\\")\\\\n            for gap_time, gap_size in gaps.items():\\\\n                print(f\\\\\\\"    {gap_time}: {gap_size}\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"   No time gaps found\\\\\\\")\\\\n\\\\n# Check what features look like during this period\\\\nprint(f\\\\\\\"\\\\\\\\nFeature values during NaN period (first NaN row):\\\\\\\")\\\\nfirst_nan_row = combined_df_clean.loc[nan_rows.index[0]]\\\\nprint(f\\\\\\\"  vol_rs_24h: {first_nan_row.get('vol_rs_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  vol_rs_72h: {first_nan_row.get('vol_rs_72h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  trend_strength_24h: {first_nan_row.get('trend_strength_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  logret_24h: {first_nan_row.get('logret_24h', 'N/A')}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"a5e0731a\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ca74f128-bd54-421a-8294-4612ff6dc990\\\",\\\"runStartTime\\\":1764186766749,\\\"runEndTime\\\":1764186766756,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02e8ec0b-3b6f-441d-90a6-675f52319ac7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"U3BsaXQgc2l6ZXM6CiAgVHJhaW46IDQyLDk0MCByb3dzICg4MC4wJSkKICBWYWw6ICAgNSwzNjcgcm93cyAoMTAuMCUpCiAgVGVzdDogIDUsMzY4IHJvd3MgKDEwLjAlKQoKWCBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA0NTApLCB2YWwgKDUzNjcsIDQ1MCksIHRlc3QgKDUzNjgsIDQ1MCkKeSBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA2KSwgdmFsICg1MzY3LCA2KSwgdGVzdCAoNTM2OCwgNikKCuKaoCBOYU5zIGZvdW5kOgogIFRyYWluOiAyMyBOYU5zCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d6a62885-4d1d-40be-b86b-517d649e6240\\\",\\\"runStartTime\\\":1764186701691,\\\"runEndTime\\\":1764186701778,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":8,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":76,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":4,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"615ead44-ff48-4e72-9aee-67ec601adca9\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"a57be68e-3ac9-46b7-8f30-b5a581205edc\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"1bc9ff45-3b6d-4f34-8fa7-fe9657c72c48\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3My4zOHMgW3N0YXRlbGVzczoyNTEuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi40bXMsIHRlbXBvcmFsOjE1Ljdtcywgcm9sbGluZzo2NDIuMG1zLCBwcmV2X3dlZWtfY3ljbGU6MTYzMTU1LjdtcywgY3VycmVudF9jeWNsZTo4ODU3Ljltcywgbm9uX2xpbmVhcjoyNjUuMW1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI3LjBtcywgY2xlYW51cDoxNjcuMm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3My4zOXMKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"2ea509ce-3f27-4495-8076-aeda24f5885f\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"c161b715-15fb-48fe-86fe-81ba4102ba89\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjUxcyBbc3RhdGVsZXNzOjIzNC43bXMsIG1lcmdlX3N0YXRlbGVzczoyLjFtcywgdGVtcG9yYWw6MTIuOW1zLCByb2xsaW5nOjYzOS4xbXMsIHByZXZfd2Vla19jeWNsZTo1MS45bXMsIGN1cnJlbnRfY3ljbGU6OTEwNi40bXMsIG5vbl9saW5lYXI6MjY0LjdtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC41bXMsIGNsZWFudXA6MTY4Ljdtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC41MXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgzLjkwcyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzQwLjAxcyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzNDAuMDFzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzY3MwoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4NjIuNTZzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\nregime_engineer.fit(features)\\\\ntargets = regime_engineer.transform(features)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(features)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":4,\\\"executionId\\\":\\\"178989f5-8687-46f0-b21f-bc1b143e632f\\\",\\\"runStartTime\\\":1764185671734,\\\"runEndTime\\\":1764186534299,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":10},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":null,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1e433f26-e798-4901-829c-0804468fbbbd\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"611eba9d-4d5b-465d-8905-9338cb65b928\\\",\\\"runStartTime\\\":1764186605776,\\\"runEndTime\\\":1764186606218,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":5,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":28,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"6741a3fb-46d3-4516-8e3a-b44022148595\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpTVE9DSCBmZWF0dXJlczogNyBmZWF0dXJlcywgMSwwMzIgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18zaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE3MyBOYU5zICggMC4zMiUpCiAgc3RvY2hfcG9zXzZoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTY5IE5hTnMgKCAwLjMxJSkKICBzdG9jaF9wb3NfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNjIgTmFOcyAoIDAuMzAlKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1NiBOYU5zICggMC4yOSUpCiAgc3RvY2hfcG9zXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKClZMTSBmZWF0dXJlczogMTggZmVhdHVyZXMsIDU5NyB0b3RhbCBOYU5zCiAgdmxtX3pzY29yZV8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fbWFfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICB2bG1fenNjb3JlXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJJQ0UgZmVhdHVyZXM6IDcgZmVhdHVyZXMsIDU0OSB0b3RhbCBOYU5zCiAgcHJpY2VfcmFua18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICBwcmljZV9yYW5rXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIHByaWNlX3JhbmtfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgcHJpY2VfcmFua18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmljZV9yYW5rXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIgTmFOcyAoIDAuMDIlKQoKRElTVCBmZWF0dXJlczogMTQgZmVhdHVyZXMsIDU0OCB0b3RhbCBOYU5zCiAgZGlzdF9mcm9tX2xvd18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21faGlnaF8yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNDQgTmFOcyAoIDAuMjclKQogIGRpc3RfZnJvbV9sb3dfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBkaXN0X2Zyb21faGlnaF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQoKUFJFViBmZWF0dXJlczogNDAgZmVhdHVyZXMsIDU0MSB0b3RhbCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQoKRVhUUkVNRSBmZWF0dXJlczogNiBmZWF0dXJlcywgMTU0IHRvdGFsIE5hTnMKICBleHRyZW1lX3Byb2IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX2N1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9zcXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCgpMT0dSRVQgZmVhdHVyZXM6IDExIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIGxvZ3JldF83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MyBOYU5zICggMC4xNCUpCiAgbG9ncmV0XzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI1IE5hTnMgKCAwLjA1JSkKICBsb2dyZXRfMTJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMgTmFOcyAoIDAuMDIlKQogIGxvZ3JldF82aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNyBOYU5zICggMC4wMSUpCiAgbG9ncmV0XzVoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKClJFQUxJWkVEIGZlYXR1cmVzOiAyIGZlYXR1cmVzLCAxNDIgdG90YWwgTmFOcwogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCiAgcmVhbGl6ZWRfdG9fZXhwZWN0ZWRfdHRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcxIE5hTnMgKCAwLjEzJSkKCkRJU1RBTkNFIGZlYXR1cmVzOiAxIGZlYXR1cmVzLCA3MiB0b3RhbCBOYU5zCiAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KTmFOIExvY2F0aW9uIEFuYWx5c2lzIChUb3AgMTAgd29yc3QgZmVhdHVyZXMpOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmljZV9yYW5rXzI4OGg6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcXJ0OgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGU6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9jb3M6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zaW46CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aF94X3R0ZV9zcToKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnN0b2NoX3Bvc18zaDoKICBUb3RhbCBOYU5zOiAxNzMgKDAuMzIlKQogIFN0YXJ0IE5hTnM6IDAgKGJlZm9yZSAyMDE5LTEwLTAxIDAxOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNzQKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpzdG9jaF9wb3NfNmg6CiAgVG90YWwgTmFOczogMTY5ICgwLjMxJSkKICBTdGFydCBOYU5zOiAyIChiZWZvcmUgMjAxOS0xMC0wMSAwMzowMDowMCkKICBNaWRkbGUgTmFOczogMTY4CiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKc3RvY2hfcG9zXzEyaDoKICBUb3RhbCBOYU5zOiAxNjIgKDAuMzAlKQogIFN0YXJ0IE5hTnM6IDUgKGJlZm9yZSAyMDE5LTEwLTAxIDA2OjAwOjAwKQogIE1pZGRsZSBOYU5zOiAxNTgKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkV4cGVjdGVkIE5hTiBTb3VyY2VzIChwcmV2X3dlZWtlbmQsIGVtcGlyaWNhbCwgZXRjLik6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCnByZXZfc2F0dXJkYXkvc3VuZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMjYKICBwcmV2X3NhdHVyZGF5X1Byb2dNaW5QX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3N1bmRheV9Qcm9nVmxtX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3NhdHVyZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCgplbXBfIChlbXBpcmljYWwpIGZlYXR1cmVzIHdpdGggTmFOczogMAoKcHJldl93ZWVrZGF5IGZlYXR1cmVzIHdpdGggTmFOczogMTMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfd2Vla2RheV9yYW5nZV94X3ZvbDogMTIgTmFOcwoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpSb3ctd2lzZSBOYU4gQW5hbHlzaXM6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93cyB3aXRoIEFOWSBOYU5zOiA0NjAgLyA1Myw5NjQgKDAuODUlKQpGaXJzdCByb3cgd2l0aCBOYU5zOiAyMDE5LTEwLTAxIDAwOjAwOjAwCkxhc3Qgcm93IHdpdGggTmFOczogMjAyMi0xMi0xOCAxODowMDowMApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBzdGFydDogMjg4CkNvbnNlY3V0aXZlIE5hTiByb3dzIGF0IGVuZDogMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"f25079d2-1f04-4b8c-b7e2-fa0d4a1b088c\\\",\\\"runStartTime\\\":1764182252111,\\\"runEndTime\\\":1764182252146,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":28,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":9,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ac865a40-6bfa-4dcb-88ba-acd90e05fdf2\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"638882dc-ecd7-4313-91e0-701f6f9bcd08\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":9,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"1d10b816-3ef6-4de3-b0e4-db94f40914d6\\\",\\\"runStartTime\\\":1764186715106,\\\"runEndTime\\\":1764186715237,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":9,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":4}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":7,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"96062d86-8e85-424b-8318-529fb4eeffa7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpBbmFseXppbmcgTWlkZGxlIE5hTiBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpGZWF0dXJlcyB3aXRoIG1pZGRsZSBOYU5zOiA0CgpUb3AgMjAgZmVhdHVyZXMgYnkgTmFOIGNvdW50OgogIHJlZ2ltZV9sYWJlbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA5NiBOYU5zICggMC4xOCUpCiAgbWF4X2Z3ZF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgIDk2IE5hTnMgKCAwLjE4JSkKICBtYXhfanVtcF96X3Njb3JlICAgICAgICAgICAgICAgICAgICAgICAgICAgOTYgTmFOcyAoIDAuMTglKQogIHZvbF9yYXRpb18yNGhfMTQ0aCAgICAgICAgICAgICAgICAgICAgICAgICAyMyBOYU5zICggMC4wNCUpCgpHcm91cGVkIGJ5IGZlYXR1cmUgdHlwZToKICBtYXggICAgICAgICAgICAgICAgICAgICAxOTIgdG90YWwgTmFOcwogIHJlZ2ltZSAgICAgICAgICAgICAgICAgICA5NiB0b3RhbCBOYU5zCiAgdm9sICAgICAgICAgICAgICAgICAgICAgIDIzIHRvdGFsIE5hTnMKClN0b2NoYXN0aWMgZmVhdHVyZXMgd2l0aCBOYU5zOiAwCiAg4pyTIE5vIHN0b2NoYXN0aWMgTmFOcyAtIGZpeCBpcyB3b3JraW5nIQoKRGF0ZSByYW5nZSBvZiBtaWRkbGUgTmFOczoKICBGaXJzdDogMjAyMC0wMS0wNSAxNjowMDowMAogIExhc3Q6IDIwMjAtMDEtMDkgMTY6MDA6MDAK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Analyze which features have the middle NaNs and verify stochastic fix\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 20 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(20).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Check specifically for stochastic features\\\\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\\\\n        print(f\\\\\\\"\\\\\\\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\\\\\\\")\\\\n        if stoch_features_in_nans:\\\\n            print(\\\\\\\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\\\\\\\")\\\\n            for feat in stoch_features_in_nans:\\\\n                print(f\\\\\\\"    {feat}: {features_with_middle_nans[feat]} NaNs\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"   No stochastic NaNs - fix is working!\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"29548500-873c-40a5-9b94-960e388e8e9e\\\",\\\"runStartTime\\\":1764186685717,\\\"runEndTime\\\":1764186685742,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":7,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"975b86cf\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"33be4f3f-4070-428a-a604-91d308292d75\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpJbnZlc3RpZ2F0aW5nIFJlZ2ltZSBMYWJlbCBOYU5zCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClRvdGFsIHJvd3Mgd2l0aCByZWdpbWVfbGFiZWwgTmFOOiA5NgpEYXRlIHJhbmdlOiAyMDIwLTAxLTA1IDE2OjAwOjAwIHRvIDIwMjAtMDEtMDkgMTU6MDA6MDAKCkZpcnN0IDEwIE5hTiB0aW1lc3RhbXBzOgogIDIwMjAtMDEtMDUgMTY6MDA6MDAKICAyMDIwLTAxLTA1IDE3OjAwOjAwCiAgMjAyMC0wMS0wNSAxODowMDowMAogIDIwMjAtMDEtMDUgMTk6MDA6MDAKICAyMDIwLTAxLTA1IDIwOjAwOjAwCiAgMjAyMC0wMS0wNSAyMTowMDowMAogIDIwMjAtMDEtMDUgMjI6MDA6MDAKICAyMDIwLTAxLTA1IDIzOjAwOjAwCiAgMjAyMC0wMS0wNiAwMDowMDowMAogIDIwMjAtMDEtMDYgMDE6MDA6MDAKCkNoZWNraW5nIHJhdyBkYXRhIGFyb3VuZCBOYU4gcGVyaW9kOgogIFJhdyBkYXRhIHJvd3MgaW4gdGhpcyBwZXJpb2Q6IDE0NAogIEV4cGVjdGVkIHJvd3MgKGhvdXJseSk6IDE0MwogIOKckyBObyB0aW1lIGdhcHMgZm91bmQKCkZlYXR1cmUgdmFsdWVzIGR1cmluZyBOYU4gcGVyaW9kIChmaXJzdCBOYU4gcm93KToKICB2b2xfcnNfMjRoOiBOL0EKICB2b2xfcnNfNzJoOiBOL0EKICB0cmVuZF9zdHJlbmd0aF8yNGg6IDAuMAogIGxvZ3JldF8yNGg6IDAuMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Investigate why regime_label has NaNs in Jan 2020\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Investigating Regime Label NaNs\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get the rows with regime NaNs\\\\nregime_nans = combined_df_clean['regime_label'].isna()\\\\nnan_rows = combined_df_clean[regime_nans]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal rows with regime_label NaN: {regime_nans.sum()}\\\\\\\")\\\\nprint(f\\\\\\\"Date range: {nan_rows.index[0]} to {nan_rows.index[-1]}\\\\\\\")\\\\n\\\\n# Check if this is a continuous block\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 10 NaN timestamps:\\\\\\\")\\\\nfor ts in nan_rows.index[:10]:\\\\n    print(f\\\\\\\"  {ts}\\\\\\\")\\\\n\\\\n# Check the raw data around this period\\\\nif 'raw_history' in globals():\\\\n    print(f\\\\\\\"\\\\\\\\nChecking raw data around NaN period:\\\\\\\")\\\\n    check_start = nan_rows.index[0] - pd.Timedelta(hours=24)\\\\n    check_end = nan_rows.index[-1] + pd.Timedelta(hours=24)\\\\n    \\\\n    raw_slice = raw_history.loc[check_start:check_end]\\\\n    print(f\\\\\\\"  Raw data rows in this period: {len(raw_slice)}\\\\\\\")\\\\n    print(f\\\\\\\"  Expected rows (hourly): {int((check_end - check_start).total_seconds() / 3600)}\\\\\\\")\\\\n    \\\\n    # Check for gaps\\\\n    if len(raw_slice) > 0:\\\\n        time_diffs = raw_slice.index.to_series().diff()\\\\n        gaps = time_diffs[time_diffs > pd.Timedelta(hours=1)]\\\\n        if len(gaps) > 0:\\\\n            print(f\\\\\\\"\\\\\\\\n   Found {len(gaps)} time gaps:\\\\\\\")\\\\n            for gap_time, gap_size in gaps.items():\\\\n                print(f\\\\\\\"    {gap_time}: {gap_size}\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"   No time gaps found\\\\\\\")\\\\n\\\\n# Check what features look like during this period\\\\nprint(f\\\\\\\"\\\\\\\\nFeature values during NaN period (first NaN row):\\\\\\\")\\\\nfirst_nan_row = combined_df_clean.loc[nan_rows.index[0]]\\\\nprint(f\\\\\\\"  vol_rs_24h: {first_nan_row.get('vol_rs_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  vol_rs_72h: {first_nan_row.get('vol_rs_72h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  trend_strength_24h: {first_nan_row.get('trend_strength_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  logret_24h: {first_nan_row.get('logret_24h', 'N/A')}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"a5e0731a\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ca74f128-bd54-421a-8294-4612ff6dc990\\\",\\\"runStartTime\\\":1764186766749,\\\"runEndTime\\\":1764186766756,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":11,\\\"id\\\":\\\"d7da7604\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"d4406837-56f1-45e0-875a-35d5b077fee7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpDaGVja2luZyBBdmFpbGFibGUgVm9sYXRpbGl0eSBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpUb3RhbCB2b2xhdGlsaXR5IGZlYXR1cmVzOiAxNDcKCkZpcnN0IDIwIHZvbCBmZWF0dXJlczoKICBhc3ltX3ZvbF92bG1faW1wYWN0CiAgY29tcHJlc3NlZF9yYW5nZV92b2wKICBjeWNsaWNhbF92b2xfY29tcHJlc3Npb24KICBkaXN0YW5jZV92b2xfZXh0cmVtZQogIGV4dHJlbWVfcmFuZ2Vfdm9sCiAga3VydG9zaXNfdm9sX2V4dHJlbWUKICBsaXFfdm9sCiAgbGlxX3ZvbF9yYXRpb19jaGFuZ2UKICBsb2dfdm9sXzEyaAogIGxvZ192b2xfMTQ0aAogIGxvZ192b2xfMjRoCiAgbG9nX3ZvbF8yODhoCiAgbG9nX3ZvbF8zaAogIGxvZ192b2xfNmgKICBsb2dfdm9sXzcyaAogIG1vbV92b2xfaW50ZXJhY3Rpb24KICBwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sMTJoCiAgcHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDI0aAogIHByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfeF92b2w2aAogIHByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2wxMmgKClJvZ2Vycy1TYXRjaGVsbCB2b2wgZmVhdHVyZXM6IDAKICDimqDvuI8gTk8gUm9nZXJzLVNhdGNoZWxsIHZvbGF0aWxpdHkgZmVhdHVyZXMgZm91bmQhCiAgVGhpcyBtZWFucyB0aGUgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIGNhbm5vdCBjb21wdXRlIHZvbGF0aWxpdHkuCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CldoYXQgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIG5lZWRzOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClRoZSByZWdpbWUgZW5naW5lZXIgY29tcHV0ZXMgUm9nZXJzLVNhdGNoZWxsIHZvbCBpbnRlcm5hbGx5IGZyb20gT0hMQwpJdCBkb2VzIE5PVCB1c2UgcHJlLWNvbXB1dGVkIHZvbF9ycyBmZWF0dXJlcyBmcm9tIGZlYXR1cmVFbmdpbmVlciEKCkJ1dCBpdCdzIHBhc3NlZCB0aGUgZmVhdHVyZXMgRGF0YUZyYW1lLCBhbmQgaXQgc2hvdWxkIGhhdmUgT0hMQyBjb2x1bW5zLi4uCgpPSExDIGNvbHVtbnMgaW4gZmVhdHVyZXM6IFtdCiAg4pqg77iPIE1JU1NJTkcgT0hMQyEgUmVnaW1lIGVuZ2luZWVyIG5lZWRzIGFsbCA0IE9ITEMgY29sdW1ucwogIE1pc3Npbmc6IFsnb3BlbicsICdoaWdoJywgJ2xvdycsICdjbG9zZSddCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Check what volatility features actually exist\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Checking Available Volatility Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get all vol features\\\\nvol_features = [col for col in features.columns if 'vol' in col.lower()]\\\\nprint(f\\\\\\\"\\\\\\\\nTotal volatility features: {len(vol_features)}\\\\\\\")\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 20 vol features:\\\\\\\")\\\\nfor feat in sorted(vol_features)[:20]:\\\\n    print(f\\\\\\\"  {feat}\\\\\\\")\\\\n\\\\n# Specifically look for Rogers-Satchell vol\\\\nrs_vol_features = [col for col in features.columns if 'vol_rs' in col]\\\\nprint(f\\\\\\\"\\\\\\\\nRogers-Satchell vol features: {len(rs_vol_features)}\\\\\\\")\\\\nif rs_vol_features:\\\\n    for feat in rs_vol_features:\\\\n        print(f\\\\\\\"  {feat}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"   NO Rogers-Satchell volatility features found!\\\\\\\")\\\\n    print(\\\\\\\"  This means the VolatilityRegimeEngineer cannot compute volatility.\\\\\\\")\\\\n    \\\\n# Check what the regime engineer expects\\\\nprint(f\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"What VolatilityRegimeEngineer needs:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"The regime engineer computes Rogers-Satchell vol internally from OHLC\\\\\\\")\\\\nprint(\\\\\\\"It does NOT use pre-computed vol_rs features from featureEngineer!\\\\\\\")\\\\nprint(\\\\\\\"\\\\\\\\nBut it's passed the features DataFrame, and it should have OHLC columns...\\\\\\\")\\\\n\\\\n# Check if features has OHLC\\\\nohlc_cols = ['open', 'high', 'low', 'close']\\\\nhas_ohlc = [col for col in ohlc_cols if col in features.columns]\\\\nprint(f\\\\\\\"\\\\\\\\nOHLC columns in features: {has_ohlc}\\\\\\\")\\\\nif len(has_ohlc) < 4:\\\\n    print(f\\\\\\\"   MISSING OHLC! Regime engineer needs all 4 OHLC columns\\\\\\\")\\\\n    print(f\\\\\\\"  Missing: {[c for c in ohlc_cols if c not in features.columns]}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"eba3e393\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d4fccd2c-6cfa-49ea-8edc-87ca880eb6c6\\\",\\\"runStartTime\\\":1764186813314,\\\"runEndTime\\\":1764186813315,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":11,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02e8ec0b-3b6f-441d-90a6-675f52319ac7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"U3BsaXQgc2l6ZXM6CiAgVHJhaW46IDQyLDk0MCByb3dzICg4MC4wJSkKICBWYWw6ICAgNSwzNjcgcm93cyAoMTAuMCUpCiAgVGVzdDogIDUsMzY4IHJvd3MgKDEwLjAlKQoKWCBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA0NTApLCB2YWwgKDUzNjcsIDQ1MCksIHRlc3QgKDUzNjgsIDQ1MCkKeSBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA2KSwgdmFsICg1MzY3LCA2KSwgdGVzdCAoNTM2OCwgNikKCuKaoCBOYU5zIGZvdW5kOgogIFRyYWluOiAyMyBOYU5zCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d6a62885-4d1d-40be-b86b-517d649e6240\\\",\\\"runStartTime\\\":1764186701691,\\\"runEndTime\\\":1764186701778,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":8,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":80,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_ab239e5c-3640-4e58-99d5-329005c0207e",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_ab239e5c-3640-4e58-99d5-329005c0207e","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            try:\n                reference_price = row['prev_close']\n                if isinstance(reference_price, pd.Series):\n                    reference_price = reference_price.iloc[0]\n                if pd.isna(reference_price) or reference_price <= 1e-9: continue\n            except KeyError: continue\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts: continue\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                if not prices1_h.empty:\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n                    \n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    if window_length > 0:\n                        results['exp1_peak_frac'] = (max_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                        results['exp1_trough_frac'] = (min_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                    \n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError: pass\n                    for k, v in results.items(): targets_df.at[current_ts, k] = v\n        return targets_df\n\n    def _calculate_absolute_expiry_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0: continue\n            \n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            \n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx < 0: continue\n            window_prev_close = X.iloc[prev_idx]['c']\n            if pd.isna(window_prev_close) or window_prev_close <= 1e-9 or window_h.empty: continue\n\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            \n            # Exp1 Targets\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = (abs_max / window_prev_close) - 1.0\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = (abs_min / window_prev_close) - 1.0\n            \n            # Exp2 Targets\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            \n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = (abs_max_p2 / window_prev_close) - 1.0\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = (abs_min_p2 / window_prev_close) - 1.0\n\n        return abs_targets\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n        \n        # Engineered logrets\n        for i in [1, 3, 6, 12, 24]:\n            df[f'logret_up_{i}h'] = np.log(df['h'].shift(-i).rolling(window=i, min_periods=i).max() / df['c'])\n            df[f'logret_down_{i}h'] = np.log(df['l'].shift(-i).rolling(window=i, min_periods=i).min() / df['c'])\n        \n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n        \n        # Select engineered columns\n        eng_cols = [c for c in df.columns if 'logret_' in c or c == 'next_24h_vol']\n        df_targets = pd.concat([price_targets, abs_targets, df[eng_cols]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Classifies market regimes using deseasonalized volatility and path efficiency.\n    \"\"\"\n    def __init__(self, \n                 lookback_window: int = 24,\n                 seasonal_window: int = 720,\n                 forward_window: int = 24,\n                 trend_std: float = 1.2,\n                 jump_std: float = 1.6,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5,\n                 trend_min_efficiency: float = 0.25, # NEW\n                 trend_min_r2: float = 0.6           # NEW\n                 ):\n        self.lookback_window = lookback_window\n        self.seasonal_window = seasonal_window\n        self.forward_window = forward_window\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self.trend_min_efficiency = trend_min_efficiency\n        self.trend_min_r2 = trend_min_r2\n        \n        self._feature_names_out = None\n        self._seasonal_vol_lookup = None\n        self.global_vol_median = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            raise ValueError(f\"Missing cols: {required_cols}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Index must be DatetimeIndex\")\n            \n        self._seasonal_vol_lookup = self._build_seasonal_vol_lookup(X)\n        self.global_vol_median = self._seasonal_vol_lookup.median()\n        return self\n    \n    def _build_seasonal_vol_lookup(self, X: pd.DataFrame) -> pd.DataFrame:\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        rs_vol = np.sqrt((term1 + term2).clip(lower=0))\n        \n        vol_df = pd.DataFrame({'vol': rs_vol, 'h': X.index.hour, 'd': X.index.dayofweek}, index=X.index)\n        \n        seasonal_vol = vol_df.groupby(['h', 'd'])['vol'].rolling(\n            window=max(4, self.seasonal_window // 168), min_periods=4\n        ).median().reset_index(level=[0, 1], drop=True)\n        \n        lookup = vol_df.copy()\n        lookup['seasonal_vol'] = seasonal_vol\n        return lookup.groupby(['h', 'd'])['seasonal_vol'].last()\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n        df = pd.DataFrame(index=X.index)\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        raw_vol = np.sqrt(((term1 + term2).clip(lower=0)).rolling(\n            window=self.lookback_window, min_periods=int(self.lookback_window/2)).mean())\n        \n        time_keys = pd.Series(list(zip(X.index.hour, X.index.dayofweek)), index=X.index)\n        seasonal_vol_series = time_keys.map(self._seasonal_vol_lookup).fillna(self.global_vol_median)\n\n        deseasonalized_ratio = raw_vol / seasonal_vol_series.replace(0, np.nan)\n        adjusted_vol = deseasonalized_ratio * self.global_vol_median\n        \n        df['box_std'] = adjusted_vol\n        df['raw_vol'] = raw_vol\n        df['seasonal_vol'] = seasonal_vol_series\n        df['reference_price'] = safe_close\n        return df\n\n    def _assign_regime_labels(self, X: pd.DataFrame, box_df: pd.DataFrame) -> pd.DataFrame:\n        results = pd.DataFrame(index=X.index)\n        results['regime_label'] = pd.Series(dtype='Int64')\n        results['max_fwd_z_score'] = np.nan \n        results['max_jump_z_score'] = np.nan \n        \n        # Scale Jump threshold to be consistent with Daily units\n        time_scaling_factor = np.sqrt(self.forward_window / self.jump_speed_window)\n        REAL_JUMP_THRESHOLD = self.jump_std * time_scaling_factor\n        \n        safe_close = X['c'].replace(0, np.nan)\n        high = X['h']\n        low = X['l']\n        sqrt_fwd = np.sqrt(self.forward_window)\n        sqrt_jump = np.sqrt(self.jump_speed_window)\n        \n        # Pre-calc 1-period moves for Efficiency\n        abs_diffs = np.abs(np.log(safe_close / safe_close.shift(1)))\n        \n        for idx in X.index:\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0: continue\n            \n            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            if fwd_end_pos <= idx_pos + 1: continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            if fwd_highs.empty: continue\n\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            final_close = X.iloc[fwd_end_pos-1]['c']\n            \n            ret_max = np.log(max_high / ref_price)\n            ret_min = np.log(min_low / ref_price)\n            max_abs_ret = max(abs(ret_max), abs(ret_min))\n            \n            fwd_z_score = max_abs_ret / (box_std * sqrt_fwd)\n            results.at[idx, 'max_fwd_z_score'] = fwd_z_score\n            \n            # Check JUMP\n            max_jump_z = 0.0\n            for i in range(len(fwd_indices) - self.jump_speed_window + 1):\n                sub_indices = fwd_indices[i : i + self.jump_speed_window]\n                s_high = high.loc[sub_indices].max()\n                s_low = low.loc[sub_indices].min()\n                s_ret = max(abs(np.log(s_high/ref_price)), abs(np.log(s_low/ref_price)))\n                current_z = s_ret / (box_std * sqrt_jump)\n                if current_z > max_jump_z: max_jump_z = current_z\n            results.at[idx, 'max_jump_z_score'] = max_jump_z\n\n            if max_jump_z > REAL_JUMP_THRESHOLD:\n                results.at[idx, 'regime_label'] = 2\n                continue\n            \n            # Check TREND with Hardening\n            if fwd_z_score > self.trend_std:\n                # 1. Efficiency\n                total_path = abs_diffs.loc[fwd_indices].sum()\n                net_move = abs(np.log(final_close / ref_price))\n                efficiency = net_move / total_path if total_path > 1e-9 else 0.0\n                \n                # 2. Linearity (R2)\n                fwd_prices = safe_close.loc[fwd_indices].values\n                if len(fwd_prices) > 2:\n                    corr = np.corrcoef(fwd_prices, np.arange(len(fwd_prices)))[0, 1]\n                    r2 = corr**2\n                else: r2 = 0.0\n                \n                if efficiency >= self.trend_min_efficiency and r2 >= self.trend_min_r2:\n                    # Retracement (Persistence)\n                    if ret_max > abs(ret_min): # Up\n                        if np.log(max_high / final_close) / ret_max <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                    else: # Down\n                        if np.log(final_close / min_low) / abs(ret_min) <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                \n                if not pd.isna(results.at[idx, 'regime_label']): continue\n            \n            results.at[idx, 'regime_label'] = 0\n            \n        return results\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_seasonal_vol_lookup')\n        box_df = self._calculate_lookback_box(X)\n        results = self._assign_regime_labels(X, box_df)\n        \n        output = results.copy()\n        output['box_std_deseasonalized'] = box_df['box_std']\n        output['box_std_raw'] = box_df['raw_vol']\n        output['seasonal_vol'] = box_df['seasonal_vol']\n        \n        self._feature_names_out = list(output.columns)\n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        transformed = self.transform(X)\n        regime_counts = transformed['regime_label'].value_counts().sort_index()\n        return regime_counts","epoch":99,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_926b3694-cc27-4bf4-b344-24aa1dcd8cee",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            try:\n                reference_price = row['prev_close']\n                if isinstance(reference_price, pd.Series):\n                    reference_price = reference_price.iloc[0]\n                if pd.isna(reference_price) or reference_price <= 1e-9: continue\n            except KeyError: continue\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts: continue\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                if not prices1_h.empty:\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n                    \n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    if window_length > 0:\n                        results['exp1_peak_frac'] = (max_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                        results['exp1_trough_frac'] = (min_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                    \n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError: pass\n                    for k, v in results.items(): targets_df.at[current_ts, k] = v\n        return targets_df\n\n    def _calculate_absolute_expiry_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0: continue\n            \n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            \n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx < 0: continue\n            window_prev_close = X.iloc[prev_idx]['c']\n            if pd.isna(window_prev_close) or window_prev_close <= 1e-9 or window_h.empty: continue\n\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            \n            # Exp1 Targets\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = (abs_max / window_prev_close) - 1.0\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = (abs_min / window_prev_close) - 1.0\n            \n            # Exp2 Targets\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            \n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = (abs_max_p2 / window_prev_close) - 1.0\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = (abs_min_p2 / window_prev_close) - 1.0\n\n        return abs_targets\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n        \n        # Engineered logrets\n        for i in [1, 3, 6, 12, 24]:\n            df[f'logret_up_{i}h'] = np.log(df['h'].shift(-i).rolling(window=i, min_periods=i).max() / df['c'])\n            df[f'logret_down_{i}h'] = np.log(df['l'].shift(-i).rolling(window=i, min_periods=i).min() / df['c'])\n        \n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n        \n        # Select engineered columns\n        eng_cols = [c for c in df.columns if 'logret_' in c or c == 'next_24h_vol']\n        df_targets = pd.concat([price_targets, abs_targets, df[eng_cols]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Classifies market regimes using deseasonalized volatility and path efficiency.\n    \"\"\"\n    def __init__(self, \n                 lookback_window: int = 24,\n                 seasonal_window: int = 720,\n                 forward_window: int = 24,\n                 trend_std: float = 1.2,\n                 jump_std: float = 1.6,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5,\n                 trend_min_efficiency: float = 0.25, # NEW\n                 trend_min_r2: float = 0.6           # NEW\n                 ):\n        self.lookback_window = lookback_window\n        self.seasonal_window = seasonal_window\n        self.forward_window = forward_window\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self.trend_min_efficiency = trend_min_efficiency\n        self.trend_min_r2 = trend_min_r2\n        \n        self._feature_names_out = None\n        self._seasonal_vol_lookup = None\n        self.global_vol_median = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            raise ValueError(f\"Missing cols: {required_cols}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Index must be DatetimeIndex\")\n            \n        self._seasonal_vol_lookup = self._build_seasonal_vol_lookup(X)\n        self.global_vol_median = self._seasonal_vol_lookup.median()\n        return self\n    \n    def _build_seasonal_vol_lookup(self, X: pd.DataFrame) -> pd.DataFrame:\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        rs_vol = np.sqrt((term1 + term2).clip(lower=0))\n        \n        vol_df = pd.DataFrame({'vol': rs_vol, 'h': X.index.hour, 'd': X.index.dayofweek}, index=X.index)\n        \n        seasonal_vol = vol_df.groupby(['h', 'd'])['vol'].rolling(\n            window=max(4, self.seasonal_window // 168), min_periods=4\n        ).median().reset_index(level=[0, 1], drop=True)\n        \n        lookup = vol_df.copy()\n        lookup['seasonal_vol'] = seasonal_vol\n        return lookup.groupby(['h', 'd'])['seasonal_vol'].last()\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n        df = pd.DataFrame(index=X.index)\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        raw_vol = np.sqrt(((term1 + term2).clip(lower=0)).rolling(\n            window=self.lookback_window, min_periods=int(self.lookback_window/2)).mean())\n        \n        time_keys = pd.Series(list(zip(X.index.hour, X.index.dayofweek)), index=X.index)\n        seasonal_vol_series = time_keys.map(self._seasonal_vol_lookup).fillna(self.global_vol_median)\n\n        deseasonalized_ratio = raw_vol / seasonal_vol_series.replace(0, np.nan)\n        adjusted_vol = deseasonalized_ratio * self.global_vol_median\n        \n        df['box_std'] = adjusted_vol\n        df['raw_vol'] = raw_vol\n        df['seasonal_vol'] = seasonal_vol_series\n        df['reference_price'] = safe_close\n        return df\n\n    def _assign_regime_labels(self, X: pd.DataFrame, box_df: pd.DataFrame) -> pd.DataFrame:\n        results = pd.DataFrame(index=X.index)\n        results['regime_label'] = pd.Series(dtype='Int64')\n        results['max_fwd_z_score'] = np.nan \n        results['max_jump_z_score'] = np.nan \n        \n        # Scale Jump threshold to be consistent with Daily units\n        time_scaling_factor = np.sqrt(self.forward_window / self.jump_speed_window)\n        REAL_JUMP_THRESHOLD = self.jump_std * time_scaling_factor\n        \n        safe_close = X['c'].replace(0, np.nan)\n        high = X['h']\n        low = X['l']\n        sqrt_fwd = np.sqrt(self.forward_window)\n        sqrt_jump = np.sqrt(self.jump_speed_window)\n        \n        # Pre-calc 1-period moves for Efficiency\n        abs_diffs = np.abs(np.log(safe_close / safe_close.shift(1)))\n        \n        for idx in X.index:\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            # If box_std is NaN or too small (flat period), assign chop (0) and continue\n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0:\n                results.at[idx, 'regime_label'] = 0\n                continue\n            \n            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            if fwd_end_pos <= idx_pos + 1: continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            if fwd_highs.empty: continue\n\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            final_close = X.iloc[fwd_end_pos-1]['c']\n            \n            ret_max = np.log(max_high / ref_price)\n            ret_min = np.log(min_low / ref_price)\n            max_abs_ret = max(abs(ret_max), abs(ret_min))\n            \n            fwd_z_score = max_abs_ret / (box_std * sqrt_fwd)\n            results.at[idx, 'max_fwd_z_score'] = fwd_z_score\n            \n            # Check JUMP\n            max_jump_z = 0.0\n            for i in range(len(fwd_indices) - self.jump_speed_window + 1):\n                sub_indices = fwd_indices[i : i + self.jump_speed_window]\n                s_high = high.loc[sub_indices].max()\n                s_low = low.loc[sub_indices].min()\n                s_ret = max(abs(np.log(s_high/ref_price)), abs(np.log(s_low/ref_price)))\n                current_z = s_ret / (box_std * sqrt_jump)\n                if current_z > max_jump_z: max_jump_z = current_z\n            results.at[idx, 'max_jump_z_score'] = max_jump_z\n\n            if max_jump_z > REAL_JUMP_THRESHOLD:\n                results.at[idx, 'regime_label'] = 2\n                continue\n            \n            # Check TREND with Hardening\n            if fwd_z_score > self.trend_std:\n                # 1. Efficiency\n                total_path = abs_diffs.loc[fwd_indices].sum()\n                net_move = abs(np.log(final_close / ref_price))\n                efficiency = net_move / total_path if total_path > 1e-9 else 0.0\n                \n                # 2. Linearity (R2)\n                fwd_prices = safe_close.loc[fwd_indices].values\n                if len(fwd_prices) > 2:\n                    corr = np.corrcoef(fwd_prices, np.arange(len(fwd_prices)))[0, 1]\n                    r2 = corr**2\n                else: r2 = 0.0\n                \n                if efficiency >= self.trend_min_efficiency and r2 >= self.trend_min_r2:\n                    # Retracement (Persistence)\n                    if ret_max > abs(ret_min): # Up\n                        if np.log(max_high / final_close) / ret_max <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                    else: # Down\n                        if np.log(final_close / min_low) / abs(ret_min) <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                \n                if not pd.isna(results.at[idx, 'regime_label']): continue\n            \n            results.at[idx, 'regime_label'] = 0\n            \n        return results\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_seasonal_vol_lookup')\n        box_df = self._calculate_lookback_box(X)\n        results = self._assign_regime_labels(X, box_df)\n        \n        output = results.copy()\n        output['box_std_deseasonalized'] = box_df['box_std']\n        output['box_std_raw'] = box_df['raw_vol']\n        output['seasonal_vol'] = box_df['seasonal_vol']\n        \n        self._feature_names_out = list(output.columns)\n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        transformed = self.transform(X)\n        regime_counts = transformed['regime_label'].value_counts().sort_index()\n        return regime_counts","epoch":104,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py::request_926b3694-cc27-4bf4-b344-24aa1dcd8cee",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","content":"\"\"\"Tiered feature engineering pipeline with heavy cache and live state support.\n\nThis module reorganizes the legacy feature engineering code into three distinct\nfeature categories (stateless, rolling, and complex/grouped) and exposes a\nthree-tier caching strategy:\n\n* Tier 1 (Heavy cache): expensive grouped aggregations persisted to disk.\n* Tier 2 (Live state cache): in-memory rolling window state for incremental updates.\n* Tier 3 (On-demand row projection): combines cached state with the latest bar.\n\nQuick start (sklearn-compatible fit/transform pattern):\n\n1. **Training Phase**: Fit on historical data to build heavy cache and learn patterns::\n\n         from featureEngineer import FeatureEngineer\n\n         # Initialize with production settings\n         fe = FeatureEngineer()\n         \n         # Fit on training data (builds heavy cache, ~1-2s for 1000 rows)\n         fe.fit(historical_ohlcv_data)\n         \n         # Transform training data (reuses cache, fast)\n         training_features = fe.transform(historical_ohlcv_data)\n\n2. **Real-time Inference**: Transform new data using fitted pipeline::\n\n         # Transform single new row (target: <100ms latency)\n         new_features = fe.transform(latest_market_data)\n         \n         # Transform updated/corrected data (same performance)\n         corrected_features = fe.transform(corrected_market_data)\n\n3. **Performance**: Typical latency ~50-100ms per row for real-time inference.\n\nAdvanced usage for streaming:\n\n4. For high-frequency streaming updates, use the live state system::\n\n       live_state = fe.initialize_live_state(price_df)\n       # Append the next bar\n       next_features = fe.ingest_live_row(next_bar)\n       # Replace the latest bar with revised data\n       revised_features = fe.ingest_live_row(revised_bar)\n\nThe design targets low-fragmentation DataFrame operations while remaining fully\ncompatible with the existing offline batch workflow.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport pickle\nimport time\nimport warnings\nfrom collections import deque\nfrom contextlib import nullcontext\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Tuple\n\nimport numpy as np\nimport pandas as pd\nimport ta\nfrom sklearn.base import BaseEstimator, TransformerMixin\n\nfrom ML_general_tools import stat_tools\nfrom data_pipeline import is_europe_dst\n\n\nHEAVY_CACHE_VERSION = 1\nDEFAULT_PREV_DAYTYPE_WINDOW = 90\nDEFAULT_EMPIRICAL_THRESHOLDS = (0.0001, 0.0005, 0.001)\nDEFAULT_EMPIRICAL_WINDOW = 90\nDEFAULT_EMPIRICAL_MIN_COUNT = 20\nHOURS_PER_YEAR = 24 * 365\n# Standard normal quantiles for 90%, 50%, and 10% (fixed z-scores)\nZ_SCORE_90 = 1.2815515655446004\nZ_SCORE_75 = 0.6744897501960817\nZ_SCORE_25 = -Z_SCORE_75\nZ_SCORE_10 = -Z_SCORE_90\n\n@dataclass\nclass HeavyFeaturePayload:\n    \"\"\"Serialized representation of complex/grouped features.\"\"\"\n\n    prev_cycle_lookup: pd.DataFrame\n    prev_cycle_stats_lookup: pd.DataFrame\n    empirical_lookup: pd.DataFrame\n    metadata: Dict[str, Any]\n\n\nclass HeavyFeatureCache:\n    \"\"\"Persist heavy feature payloads to disk with version awareness.\"\"\"\n\n    def __init__(self, cache_dir: Optional[Path]) -> None:\n        self.cache_dir = Path(cache_dir or Path(\"cache\") / \"heavy_features\")\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        self.payload: Optional[HeavyFeaturePayload] = None\n\n    @property\n    def cache_path(self) -> Path:\n        return self.cache_dir / f\"heavy_features_v{HEAVY_CACHE_VERSION}.pkl\"\n\n    def load(self) -> bool:\n        cache_path = self.cache_path\n        if not cache_path.exists():\n            return False\n        try:\n            with cache_path.open(\"rb\") as fh:\n                payload = pickle.load(fh)\n        except Exception:\n            return False\n        if not isinstance(payload, HeavyFeaturePayload):\n            return False\n        metadata = payload.metadata if isinstance(payload.metadata, dict) else {}\n        if metadata.get(\"version\") != HEAVY_CACHE_VERSION:\n            return False\n        self.payload = payload\n        return True\n\n    def save(self, payload: HeavyFeaturePayload) -> None:\n        cache_path = self.cache_path\n        with cache_path.open(\"wb\") as fh:\n            pickle.dump(payload, fh)\n        self.payload = payload\n\n\n@dataclass\nclass LiveStateCache:\n    \"\"\"Hold incremental feature state for real-time updates.\"\"\"\n\n    features_df: pd.DataFrame\n    price_history: pd.DataFrame\n    rolling_states: Dict[str, Any]\n    ema_states: Dict[str, Any]\n    metadata: Dict[str, Any]\n\n    def append(self, features_row: pd.Series, price_row: pd.Series) -> None:\n        self.features_df = pd.concat([self.features_df, features_row.to_frame().T])\n        self.price_history = pd.concat([self.price_history, price_row.to_frame().T])\n\n\n@dataclass\nclass RollingWindowState:\n    \"\"\"Maintain running statistics for a fixed-length window.\"\"\"\n\n    window: int\n    values: deque = field(default_factory=deque)\n    sum_: float = 0.0\n    sum_sq: float = 0.0\n\n    def append(self, value: float) -> None:\n        self.values.append(value)\n        self.sum_ += value\n        self.sum_sq += value * value\n        if len(self.values) > self.window:\n            old = self.values.popleft()\n            self.sum_ -= old\n            self.sum_sq -= old * old\n\n    def mean(self, min_periods: int = 1) -> float:\n        n = len(self.values)\n        if n < max(1, min_periods):\n            return float(\"nan\")\n        return self.sum_ / n\n\n    def std(self, min_periods: int = 2) -> float:\n        n = len(self.values)\n        if n < max(2, min_periods):\n            return float(\"nan\")\n        mean = self.sum_ / n\n        variance = (self.sum_sq - n * mean * mean) / max(1, n - 1)\n        variance = max(variance, 0.0)\n        return float(np.sqrt(variance))\n\n\nclass StatelessFeatureBlock:\n    \"\"\"Generate row-wise features that only require the most recent bar.\"\"\"\n\n    def __init__(self, expiration_hour: int, include_dst: bool) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_dst = include_dst\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return a DataFrame of strictly causal, per-row features.\"\"\"\n\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Stateless features require a DatetimeIndex\")\n        if df.empty:\n            return pd.DataFrame(index=df.index)\n\n        idx = df.index\n        current_time = idx + pd.Timedelta(hours=1)\n        expiry_today = current_time.normalize() + pd.Timedelta(hours=self.expiration_hour)\n        expiry_tomorrow = expiry_today + pd.Timedelta(days=1)\n        time_diff = np.where(current_time < expiry_today, expiry_today - current_time, expiry_tomorrow - current_time)\n        time_to_exp = pd.Series(\n            [float(delta / pd.Timedelta(hours=1)) for delta in time_diff],\n            index=idx,\n            dtype=\"float64\",\n        )\n        time_to_exp[np.isclose(time_to_exp, 0.0, atol=1e-9)] = 24.0\n\n        stateless = pd.DataFrame(index=idx)\n        stateless[\"time_to_exp1_hr\"] = time_to_exp\n        stateless[\"time_elapsed\"] = 24.0 - time_to_exp\n        stateless[\"hour\"] = current_time.hour\n        stateless[\"day_of_week\"] = current_time.dayofweek\n        stateless[\"is_weekend\"] = stateless[\"day_of_week\"].isin([5, 6]).astype(int)\n\n        hour_of_week = stateless[\"day_of_week\"] * 24 + stateless[\"hour\"]\n        stateless[\"hour_of_week\"] = hour_of_week\n        stateless[\"hour_of_week_sin\"] = np.sin(2 * np.pi * hour_of_week / 168)\n        stateless[\"hour_of_week_cos\"] = np.cos(2 * np.pi * hour_of_week / 168)\n        stateless[\"hours_since_week_start\"] = hour_of_week.astype(float)\n\n        stateless[\"day_type_num\"] = np.select(\n            [stateless[\"day_of_week\"] < 5, stateless[\"day_of_week\"] == 5, stateless[\"day_of_week\"] == 6],\n            [0, 1, 2],\n            default=-1,\n        )\n\n        stateless[\"prev_close\"] = df[\"c\"].shift(1)\n        if \"volCcy\" in df.columns:\n            stateless[\"volCcy_prev\"] = df[\"volCcy\"].shift(1).round()\n        else:\n            stateless[\"volCcy_prev\"] = np.nan\n\n        cycle_start_mask = ((idx + pd.Timedelta(hours=1)).hour == self.expiration_hour)\n        cycle_start_flags = cycle_start_mask.astype(int)\n        cycle_ids = cycle_start_flags.cumsum()\n        stateless[\"cycle_id\"] = cycle_ids\n\n        cycle_anchor_close = df[\"c\"].where(cycle_start_mask)\n        stateless[\"window_prev_close\"] = cycle_anchor_close.ffill()\n        stateless.loc[stateless[\"window_prev_close\"].isna(), \"window_prev_close\"] = stateless.loc[\n            stateless[\"window_prev_close\"].isna(), \"prev_close\"\n        ]\n        stateless[\"_cycle_start_ts\"] = (idx + pd.Timedelta(hours=1)).to_series().where(cycle_start_mask).ffill().values\n\n        close_shift_1 = df[\"c\"].shift(1)\n        close_shift_2 = df[\"c\"].shift(2)\n        safe_close_shift_2 = close_shift_2.replace(0, np.nan)\n\n        stateless[\"returns_1h\"] = ((close_shift_1 / safe_close_shift_2) - 1).fillna(0)\n\n        horizons = [2, 3, 4, 5, 6, 12, 24, 72]\n        for horizon in horizons:\n            denominator = df[\"c\"].shift(horizon + 1).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[f\"returns_{horizon}h\"] = (ratio - 1).fillna(0)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[f\"logret_{horizon}h\"] = np.log(ratio.replace(0, np.nan))\n\n        for window_hours, label in [(24 * 7 + 1, \"returns_1wk\"), (24 * 30 + 1, \"returns_1M\")]:\n            denominator = df[\"c\"].shift(window_hours).replace(0, np.nan)\n            ratio = close_shift_1 / denominator\n            stateless[label] = (ratio - 1).fillna(0)\n\n        if {\"h\", \"l\"}.issubset(df.columns):\n            high_shift_1 = df[\"h\"].shift(1)\n            low_shift_1 = df[\"l\"].shift(1)\n            safe_low = low_shift_1.replace(0, np.nan)\n\n            stateless[\"ret_h_pc\"] = (high_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_l_pc\"] = (low_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_c_pc\"] = (close_shift_1 / safe_close_shift_2) - 1\n            stateless[\"ret_h_l\"] = (high_shift_1 / safe_low) - 1\n\n            for window in [2, 3, 6, 12, 24]:\n                rolling_high = high_shift_1.rolling(window=window, min_periods=1).max()\n                rolling_low = low_shift_1.rolling(window=window, min_periods=1).min()\n                stateless[f\"range_{window}h\"] = rolling_high - rolling_low\n                stateless[f\"range_pc_{window}h\"] = (\n                    (rolling_high - rolling_low) / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n                )\n\n            trading_range = high_shift_1 - low_shift_1\n            stateless[\"range\"] = trading_range\n            stateless[\"range_pc\"] = trading_range / stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            stateless[\"close_to_high\"] = (high_shift_1 - close_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            stateless[\"close_to_low\"] = (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n\n            same_high_low = high_shift_1 == low_shift_1\n            stateless.loc[same_high_low, [\"close_to_high\", \"close_to_low\"]] = 0.5\n\n            stateless[\"close_pos_in_bar\"] = (\n                (close_shift_1 - low_shift_1) / (high_shift_1 - low_shift_1).replace(0, np.nan)\n            ).clip(0, 1)\n            stateless.loc[same_high_low, \"close_pos_in_bar\"] = 0.5\n\n            prev_close_shift_1 = stateless[\"prev_close\"].shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                stateless[\"logret_h_pc\"] = np.log(high_shift_1 / prev_close_shift_1)\n                stateless[\"logret_l_pc\"] = np.log(low_shift_1 / prev_close_shift_1)\n                stateless[\"logret_c_pc\"] = np.log(close_shift_1 / prev_close_shift_1)\n\n        if self.include_dst:\n            stateless[\"is_dst\"] = is_europe_dst(idx).astype(int)\n\n        return stateless.replace([np.inf, -np.inf], np.nan)\n\n\nclass RollingFeatureBlock:\n    \"\"\"Produce fixed-window rolling statistics without duplicating logic elsewhere.\"\"\"\n\n    def __init__(self,\n                 vol_window_sizes: Iterable[int],\n                 vlm_window_sizes: Iterable[int],\n                 vol_types_to_calc: Iterable[str],\n                 vol_trading_periods: int) -> None:\n        self.vol_window_sizes = sorted(set(vol_window_sizes))\n        self.vlm_window_sizes = sorted(set(vlm_window_sizes))\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.stats = stat_tools()\n\n    def compute(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Return combined trend/volatility/liquidity/relative-position features.\"\"\"\n\n        features = []\n\n        if {\"c\", \"h\", \"l\"}.issubset(df.columns):\n            features.append(self._trend_features(df))\n            features.append(self._relative_position_features(df))\n        if \"volCcy_prev\" in df.columns or \"volCcy\" in df.columns:\n            features.append(self._liquidity_features(df))\n        features.append(self._volatility_features(df))\n\n        valid = [f for f in features if f is not None and not f.empty]\n        if not valid:\n            return pd.DataFrame(index=df.index)\n        return pd.concat(valid, axis=1)\n\n    # --- Private helpers -------------------------------------------------\n\n    def _trend_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        trend_df = pd.DataFrame(index=df.index)\n        closes = df[\"c\"].shift(1)\n        \n        # Calculate trend strength features (backward z-scores)\n        # How big was the move over the last N hours relative to volatility?\n        safe_close = closes.replace(0, np.nan)\n        \n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n\n            close_w_ago = df[\"c\"].shift(w + 1).replace(0, np.nan)\n            \n            # Standard momentum (returns)\n            momentum = ((closes / close_w_ago) - 1).fillna(0)\n            trend_df[f\"momentum_{w}h\"] = momentum\n            trend_df[f\"momentum_signed_sqrt_{w}h\"] = np.sign(momentum) * np.sqrt(np.abs(momentum))\n            \n            # Trend strength: backward return / volatility (z-score of move)\n            # This normalizes the move by historical volatility\n            backward_return = np.log(safe_close / close_w_ago)\n            \n            # Use realized volatility as the denominator\n            # Get log returns for volatility calculation\n            prev_close_lag = safe_close.shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                log_ret = np.log(safe_close / prev_close_lag)\n            log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n            \n            # Rolling std (annualized volatility)\n            box_std = log_ret.rolling(w, min_periods=min_p).std()\n            \n            # Per-period std for the window length (de-annualize for the period)\n            box_std_period = box_std * np.sqrt(w)  # Adjust for window length\n            \n            # Trend strength = realized move / expected move\n            # This gives you \"how many sigmas was this move?\"\n            trend_strength = backward_return / box_std_period.replace(0, np.nan)\n            trend_df[f\"trend_strength_{w}h\"] = trend_strength.fillna(0)\n\n        try:\n            macd = ta.trend.MACD(df[\"c\"].shift(1), window_slow=26, window_fast=12, window_sign=9, fillna=True)\n            trend_df[\"macd\"] = macd.macd()\n            trend_df[\"macd_signal\"] = macd.macd_signal()\n            trend_df[\"macd_hist\"] = macd.macd_diff()\n\n            adx = ta.trend.ADXIndicator(df[\"h\"].shift(1), df[\"l\"].shift(1), df[\"c\"].shift(1), window=14, fillna=True)\n            trend_df[\"adx\"] = adx.adx()\n            trend_df[\"adx_pos\"] = adx.adx_pos()\n            trend_df[\"adx_neg\"] = adx.adx_neg()\n        except Exception:\n            for col in [\"macd\", \"macd_signal\", \"macd_hist\", \"adx\", \"adx_pos\", \"adx_neg\"]:\n                trend_df[col] = np.nan\n\n        return trend_df\n\n    def _volatility_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vol_df = pd.DataFrame(index=df.index)\n        prev_close = df[\"prev_close\"].replace(0, np.nan)\n        prev_close_lag = prev_close.shift(1).replace(0, np.nan)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            log_ret = np.log(prev_close / prev_close_lag)\n        log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n\n        for w in self.vol_window_sizes:\n            if \"raw\" in self.vol_types_to_calc:\n                min_p = max(3, w // 4)\n                vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_raw_{w}h\"] = vol.fillna(0)\n            if \"gkyz\" in self.vol_types_to_calc:\n                try:\n                    gkyz = self.stats.get_GKYZ(df, w, self.vol_trading_periods)\n                    vol_df[f\"vol_gkyz_{w}h\"] = gkyz.reindex(df.index).ffill()\n                except Exception:\n                    vol_df[f\"vol_gkyz_{w}h\"] = pd.Series(0, index=df.index)\n            if \"atr\" in self.vol_types_to_calc:\n                vol_df[f\"atr_{w}h\"] = self._calculate_atr(df, w)\n            if \"parkinson\" in self.vol_types_to_calc:\n                # Parkinson volatility: range-based estimator using only H/L\n                # Formula:  = [(1/(4*ln(2))) * mean((ln(H/L)))] * (trading_periods)\n                # More efficient than close-to-close, captures intraday volatility\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                safe_low = low_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    hl_ratio = high_shifted / safe_low\n                    log_hl = np.log(hl_ratio.replace([0, np.inf, -np.inf], np.nan))\n                    log_hl_sq = log_hl ** 2\n                \n                min_p = max(3, w // 4)\n                # Parkinson coefficient: 1/(4*ln(2))  0.3607\n                parkinson_coef = 1.0 / (4.0 * np.log(2.0))\n                mean_log_hl_sq = log_hl_sq.rolling(w, min_periods=min_p).mean()\n                vol_parkinson = np.sqrt(parkinson_coef * mean_log_hl_sq) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_parkinson_{w}h\"] = vol_parkinson.fillna(0)\n            if \"rogers_satchell\" in self.vol_types_to_calc:\n                # Rogers-Satchell volatility: drift-independent OHLC estimator\n                # Formula:  = [mean(ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O))] * (trading_periods)\n                # Superior to Parkinson as it incorporates open/close (drift info)\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                close_shifted = df[\"c\"].shift(1)\n                open_shifted = df[\"o\"].shift(1) if \"o\" in df.columns else close_shifted\n                \n                safe_close = close_shifted.replace(0, np.nan).clip(lower=1e-9)\n                safe_open = open_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    log_hc = np.log(high_shifted / safe_close)\n                    log_ho = np.log(high_shifted / safe_open)\n                    log_lc = np.log(low_shifted / safe_close)\n                    log_lo = np.log(low_shifted / safe_open)\n                    \n                    # Rogers-Satchell formula\n                    rs_component = (log_hc * log_ho) + (log_lc * log_lo)\n                    rs_component = rs_component.replace([np.inf, -np.inf], np.nan)\n                \n                min_p = max(3, w // 4)\n                mean_rs = rs_component.rolling(w, min_periods=min_p).mean()\n                # Ensure non-negative before sqrt (numerical stability)\n                vol_rs = np.sqrt(mean_rs.clip(lower=0)) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_rs_{w}h\"] = vol_rs.fillna(0)\n            if \"vol_zscore\" in self.vol_types_to_calc:\n                # Z-score of volatility: (current_vol - rolling_mean) / rolling_std\n                # Use raw volatility as base, with longer lookback for mean/std calculation\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Use 2x window for mean/std to capture volatility regime\n                zscore_window = min(w * 2, max(self.vol_window_sizes))\n                min_p_zscore = max(w, zscore_window // 2)\n                vol_ma = base_vol.rolling(zscore_window, min_periods=min_p_zscore).mean()\n                vol_std = base_vol.rolling(zscore_window, min_periods=min_p_zscore).std().replace(0, 1e-9)\n                vol_df[f\"vol_zscore_{w}h\"] = ((base_vol - vol_ma) / vol_std).fillna(0)\n            if \"log_vol\" in self.vol_types_to_calc:\n                # Log-volatility: useful for multiplicative volatility models\n                # Use raw volatility as base\n                base_vol_col = f\"vol_raw_{w}h\"\n                if base_vol_col in vol_df.columns:\n                    base_vol = vol_df[base_vol_col]\n                else:\n                    # Calculate raw vol if not already computed\n                    min_p = max(3, w // 4)\n                    base_vol = log_ret.rolling(w, min_periods=min_p).std() * np.sqrt(self.vol_trading_periods)\n                \n                # Clip to avoid log(0) and handle very small volatilities\n                vol_clipped = base_vol.clip(lower=1e-6)\n                vol_df[f\"log_vol_{w}h\"] = np.log(vol_clipped).fillna(0)\n\n        if \"skew\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=3).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=3).std()\n            centered = log_ret - ewma\n            skew_num = (centered ** 3).ewm(span=24, min_periods=3).mean()\n            vol_df[\"returns_skew_24h\"] = (skew_num / (ewmstd ** 3 + 1e-9)).fillna(0)\n\n        if \"kurtosis\" in self.vol_types_to_calc:\n            ewma = log_ret.ewm(span=24, min_periods=4).mean()\n            ewmstd = log_ret.ewm(span=24, min_periods=4).std()\n            centered = log_ret - ewma\n            kurt_num = (centered ** 4).ewm(span=24, min_periods=4).mean()\n            vol_df[\"returns_kurtosis_24h\"] = (kurt_num / (ewmstd ** 4 + 1e-9) - 3).fillna(0)\n\n        def _lookup(col: str) -> Optional[pd.Series]:\n            if col in vol_df.columns:\n                return vol_df[col]\n            if col in df.columns:\n                return df[col]\n            return None\n\n        ## lets use raw vol as thats what blackscholes does and they actually got a noble prize somehow\n        vol_24 = _lookup(\"vol_raw_24h\")\n        vol_144 = _lookup(\"vol_raw_144h\")\n        vol_288 = _lookup(\"vol_raw_288h\")\n\n        vol_df[\"vol_ratio_24h_144h\"] = vol_24 / vol_144.replace(0, np.nan)\n        vol_df[\"vol_ratio_24h_288h\"] = vol_24 / vol_288.replace(0, np.nan)\n\n\n        ## essentially using pas 288 as more stable hour to predict blackscholes.\n        sigma_unit = vol_288 / np.sqrt(float(self.vol_trading_periods))\n        sigma_24h = sigma_unit * np.sqrt(24.0)\n\n        exp_ret_p90_24h = sigma_24h * Z_SCORE_90\n        exp_ret_p75_24h = sigma_24h * Z_SCORE_75\n        exp_ret_p25_24h = sigma_24h * Z_SCORE_25\n        exp_ret_p10_24h = sigma_24h * Z_SCORE_10\n\n        ## expected 24 hour moves based on blackschoels and \n        vol_df[\"exp_ret_p90_24h\"] = exp_ret_p90_24h\n        vol_df[\"exp_ret_p75_24h\"] = exp_ret_p75_24h\n        vol_df[\"exp_ret_p25_24h\"] = exp_ret_p25_24h\n        vol_df[\"exp_ret_p10_24h\"] = exp_ret_p10_24h\n\n        vol_df[\"exp_band_width_24h\"] = exp_ret_p90_24h - exp_ret_p10_24h\n        vol_df[\"exp_logmove_p90_24h\"] = np.log1p(exp_ret_p90_24h.clip(lower=-0.999999))\n        vol_df[\"exp_logmove_p10_24h\"] = np.log1p(exp_ret_p10_24h.clip(lower=-0.999999))\n\n\n\n        tte_series = df.get(\"time_to_exp1_hr\")\n        if vol_24 is not None and tte_series is not None:\n            tte_clipped = tte_series.clip(lower=1e-6)\n            with np.errstate(invalid=\"ignore\"):\n                sigma_tte = sigma_unit * np.sqrt(tte_clipped)\n                exp_ret_p90_tte = sigma_tte * Z_SCORE_90\n                exp_ret_p10_tte = sigma_tte * Z_SCORE_10\n\n            vol_df[\"exp_ret_p90_tte\"] = exp_ret_p90_tte\n            vol_df[\"exp_ret_p10_tte\"] = exp_ret_p10_tte\n            vol_df[\"exp_band_width_tte\"] = exp_ret_p90_tte - exp_ret_p10_tte\n            vol_df[\"exp_logmove_p90_tte\"] = np.log1p(exp_ret_p90_tte.clip(lower=-0.999999))\n            vol_df[\"exp_logmove_p10_tte\"] = np.log1p(exp_ret_p10_tte.clip(lower=-0.999999))\n\n\n        if \"returns_24h\" in df.columns and \"exp_band_width_24h\" in vol_df.columns:\n            band_24 = vol_df[\"exp_band_width_24h\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_24h\"] = df[\"returns_24h\"].abs() / band_24\n        if tte_series is not None and \"returns_1h\" in df.columns and \"exp_band_width_tte\" in vol_df.columns:\n            band_tte = vol_df[\"exp_band_width_tte\"].replace(0, np.nan)\n            vol_df[\"realized_to_expected_tte\"] = df[\"returns_1h\"].abs() / band_tte\n\n        return vol_df\n\n    def _liquidity_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        vlm_df = pd.DataFrame(index=df.index)\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None:\n            vol_series = df[\"volCcy\"].shift(1)\n        vol_adj = vol_series.replace(0, 1e-6)\n        for w in self.vlm_window_sizes:\n            min_p = max(1, w // 2)\n            ma = vol_adj.rolling(w, min_periods=min_p).mean()\n            std = vol_adj.rolling(w, min_periods=min_p).std().replace(0, 1e-6)\n            vlm_df[f\"vlm_ma_{w}h\"] = ma\n            vlm_df[f\"vlm_zscore_{w}h\"] = (vol_adj - ma) / std\n\n        ratio_frames = []\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_168h\" in vlm_df.columns:\n            if \"vlm_ma_3h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_3h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_3h_168h\",\n                    )\n                )\n            if \"vlm_ma_6h\" in vlm_df.columns:\n                ratio_frames.append(\n                    pd.Series(\n                        vlm_df[\"vlm_ma_6h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                        name=\"vlm_ratio_6h_168h\",\n                    )\n                )\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_168h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_168h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_720h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_720h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_720h\",\n                )\n            )\n        if \"vlm_ma_24h\" in vlm_df.columns and \"vlm_ma_2160h\" in vlm_df.columns:\n            ratio_frames.append(\n                pd.Series(\n                    vlm_df[\"vlm_ma_24h\"] / vlm_df[\"vlm_ma_2160h\"].replace(0, np.nan),\n                    name=\"vlm_ratio_24h_2160h\",\n                )\n            )\n\n        if ratio_frames:\n            vlm_df = pd.concat([vlm_df] + [s.to_frame() for s in ratio_frames], axis=1)\n\n        return vlm_df\n\n    def _relative_position_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        rel_df = pd.DataFrame(index=df.index)\n        high = df[\"h\"].shift(1)\n        low = df[\"l\"].shift(1)\n        close = df[\"c\"].shift(1)\n\n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n            rolling_high = high.rolling(window=w, min_periods=min_p).max()\n            rolling_low = low.rolling(window=w, min_periods=min_p).min()\n            range_w = rolling_high - rolling_low\n            # Add epsilon to avoid division by zero in flat periods; flat periods get 0.5 (neutral)\n            epsilon = 1e-10\n            rel_df[f\"stoch_pos_{w}h\"] = ((close - rolling_low) / (range_w + epsilon)).clip(0, 1)\n            rel_df[f\"dist_from_high_{w}h\"] = (rolling_high - close) / close.replace(0, np.nan)\n            rel_df[f\"dist_from_low_{w}h\"] = (close - rolling_low) / close.replace(0, np.nan)\n            rel_df[f\"price_rank_{w}h\"] = close.rolling(w).rank(pct=True)\n\n        if 24 in self.vol_window_sizes:\n            rel_df[\"new_24h_high\"] = (high > df[\"h\"].shift(2).rolling(23).max()).astype(int)\n            rel_df[\"new_24h_low\"] = (low < df[\"l\"].shift(2).rolling(23).min()).astype(int)\n\n        return rel_df\n\n    @staticmethod\n    def _calculate_atr(df: pd.DataFrame, window: int) -> pd.Series:\n        prev_close = df[\"prev_close\"]\n        tr_components = pd.concat(\n            [\n                df[\"h\"] - df[\"l\"],\n                (df[\"h\"] - prev_close).abs(),\n                (df[\"l\"] - prev_close).abs(),\n            ],\n            axis=1,\n        )\n        tr = tr_components.max(axis=1)\n        min_p = max(1, window // 2)\n        return tr.rolling(window=window, min_periods=min_p).mean().fillna(0)\n\n\nclass ComplexFeatureBlock:\n    def __init__(self,\n                 prev_daytype_window: int,\n                 empirical_window: int,\n                 empirical_min_count: int,\n                 empirical_thresholds: Iterable[float]) -> None:\n        self.prev_daytype_window = prev_daytype_window\n        self.empirical_window = empirical_window\n        self.empirical_min_count = empirical_min_count\n        self.empirical_thresholds = list(empirical_thresholds)\n        self.expiration_hour: Optional[int] = None\n\n    def build_payload(self, df: pd.DataFrame) -> HeavyFeaturePayload:\n        if self.expiration_hour is None:\n            raise RuntimeError(\"ComplexFeatureBlock requires expiration_hour to be set\")\n        if \"time_to_exp1_hr\" not in df.columns or \"day_type_num\" not in df.columns:\n            raise ValueError(\"Complex features require time_to_exp1_hr and day_type_num columns\")\n\n        working = df.copy()\n        if \"_cycle_start_ts\" not in working.columns:\n            working[\"_cycle_start_ts\"] = df.index.to_series().where((df.index.hour == self.expiration_hour))\n\n        working = self._add_current_cycle_progress_features(working)\n        prev_cycle = self._add_prev_daytype_cycle_slice_features(working)\n        prev_cycle_stats = self._add_rolling_stats_for_prev_daytype_features(prev_cycle)\n        empirical = self._add_empirical_probability_features(prev_cycle_stats)\n\n        time_bucket = self._bucket_time_to_exp(empirical[\"time_to_exp1_hr\"])\n        empirical = empirical.assign(_tte_bucket=time_bucket)\n\n        prev_slice_cols = [col for col in empirical.columns \n                          if col.startswith(\"prev_\") \n                          and not col.endswith(\"_tte_bucket\")\n                          and col != \"prev_close\"]  # Exclude prev_close to avoid duplication\n        stats_cols = [col for col in empirical.columns if any(col.endswith(suffix) for suffix in (\"_med\", \"_p10\", \"_p90\"))]\n        empirical_cols = [col for col in empirical.columns if col.startswith(\"emp_\")]\n\n        prev_cycle_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[prev_slice_cols]\n            .median()\n            .sort_index()\n        )\n\n        prev_cycle_stats_lookup = (\n            empirical.groupby([\"day_type_num\", \"_tte_bucket\"], dropna=False)[stats_cols]\n            .last()\n            .sort_index()\n        )\n\n        empirical_lookup = (\n            empirical.groupby([\"hour\", \"day_type_num\"], dropna=False)[empirical_cols]\n            .last()\n            .sort_index()\n        )\n\n        metadata = {\n            \"version\": HEAVY_CACHE_VERSION,\n            \"prev_daytype_window\": self.prev_daytype_window,\n            \"empirical_window\": self.empirical_window,\n            \"empirical_thresholds\": self.empirical_thresholds,\n            \"empirical_min_count\": self.empirical_min_count,\n        }\n\n        return HeavyFeaturePayload(\n            prev_cycle_lookup=prev_cycle_lookup,\n            prev_cycle_stats_lookup=prev_cycle_stats_lookup,\n            empirical_lookup=empirical_lookup,\n            metadata=metadata,\n        )\n\n    def lookup_for_row(self, row: pd.Series, payload: HeavyFeaturePayload) -> pd.Series:\n        out_parts: List[pd.Series] = []\n        tte_bucket = self._bucket_time_to_exp(pd.Series([row[\"time_to_exp1_hr\"]])).iloc[0]\n        day_type = row.get(\"day_type_num\", np.nan)\n        hour = row.get(\"hour\", np.nan)\n\n        if not np.isnan(day_type) and not np.isnan(tte_bucket):\n            idx = (day_type, tte_bucket)\n            if idx in payload.prev_cycle_lookup.index:\n                out_parts.append(payload.prev_cycle_lookup.loc[idx])\n            if idx in payload.prev_cycle_stats_lookup.index:\n                out_parts.append(payload.prev_cycle_stats_lookup.loc[idx])\n\n        if not np.isnan(day_type) and not np.isnan(hour):\n            idx_emp = (hour, day_type)\n            if idx_emp in payload.empirical_lookup.index:\n                out_parts.append(payload.empirical_lookup.loc[idx_emp])\n\n        if not out_parts:\n            return pd.Series(dtype=\"float64\")\n        return pd.concat(out_parts)\n\n    # --- Heavy feature helpers -------------------------------------------\n\n    @staticmethod\n    def _bucket_time_to_exp(series: pd.Series, precision: int = 2) -> pd.Series:\n        return series.round(precision)\n\n    def _add_current_cycle_progress_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        prog_cols = [\"cCProgActP\", \"cCProgMinP\", \"cCProgMaxP\", \"cCProgMinT\", \"cCProgMaxT\", \"cCProgVlm\"]\n        df = df.copy()\n        df[prog_cols] = np.nan\n\n        expiry_times = df.index[df.index.hour == self.expiration_hour].sort_values()\n        for i in range(len(expiry_times)):\n            cycle_start = expiry_times[i]\n            cycle_end = expiry_times[i + 1] - pd.Timedelta(hours=1) if i + 1 < len(expiry_times) else df.index[-1]\n            cycle_mask = (df.index >= cycle_start) & (df.index <= cycle_end)\n            cycle_df = df.loc[cycle_mask]\n            if cycle_df.empty:\n                continue\n\n            prog_start_price = cycle_df.iloc[0][\"prev_close\"]\n            cum_max = cycle_df[\"h\"].expanding().max()\n            cum_min = cycle_df[\"l\"].expanding().min()\n            idxs = cycle_df.index\n            cum_max_t = cycle_df[\"h\"].expanding().apply(\n                lambda x: (idxs[x.argmax()] - cycle_start).total_seconds() // 3600\n            )\n            cum_min_t = cycle_df[\"l\"].expanding().apply(\n                lambda x: (idxs[x.argmin()] - cycle_start).total_seconds() // 3600\n            )\n            vol_series = cycle_df.get(\"volCcy_prev\")\n            if vol_series is None and \"volCcy\" in cycle_df.columns:\n                # Fallback to shifted live volume if the pre-shifted field is missing.\n                vol_series = cycle_df[\"volCcy\"].shift(1)\n            if vol_series is None:\n                vol_series = pd.Series(0.0, index=cycle_df.index)\n            cum_vlm = vol_series.fillna(0.0).cumsum()\n            prog_actp = (cycle_df[\"c\"] / prog_start_price) - 1\n            prog_maxp = (cum_max / prog_start_price) - 1\n            prog_minp = (cum_min / prog_start_price) - 1\n\n            df.loc[cycle_mask, \"cCProgActP\"] = prog_actp.values\n            df.loc[cycle_mask, \"cCProgMaxP\"] = prog_maxp.values\n            df.loc[cycle_mask, \"cCProgMinP\"] = prog_minp.values\n            df.loc[cycle_mask, \"cCProgMaxT\"] = cum_max_t.values\n            df.loc[cycle_mask, \"cCProgMinT\"] = cum_min_t.values\n            df.loc[cycle_mask, \"cCProgVlm\"] = cum_vlm.values\n\n        return df\n\n    def _add_prev_daytype_cycle_slice_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        feature_types = [\"weekday\", \"saturday\", \"sunday\"]\n        base_names = [\n            \"ProgActP\",\n            \"ProgMinP\",\n            \"ProgMaxP\",\n            \"ProgMinT\",\n            \"ProgMaxT\",\n            \"ProgVlm\",\n            \"RemActP\",\n            \"RemMinP\",\n            \"RemMaxP\",\n            \"RemMinT\",\n            \"RemMaxT\",\n        ]\n        feature_names = [f\"prev_{ftype}_{bname}\" for ftype in feature_types for bname in base_names]\n        results = pd.DataFrame(np.nan, index=df.index, columns=feature_names)\n\n        for idx, row in df.iterrows():\n            stats = self._get_prev_daytype_cycle_stats(row, df)\n            results.loc[idx] = stats\n\n        return pd.concat([df, results], axis=1)\n\n    def _get_prev_daytype_cycle_stats(self, row: pd.Series, historical_df: pd.DataFrame) -> Tuple:\n        t_now = row.name\n        time_elapsed = 24 - row.get(\"time_to_exp1_hr\", 0)\n        nan_stats = (np.nan,) * 33\n\n        def get_prev_cycle_start(ref_time: pd.Timestamp, target_dow: int) -> Optional[pd.Timestamp]:\n            for i in range(1, 8):\n                candidate = (ref_time - pd.Timedelta(days=i)).normalize() + pd.Timedelta(hours=self.expiration_hour)\n                if candidate.dayofweek == target_dow:\n                    return candidate\n            return None\n\n        daytype_map = {\"weekday\": [0, 1, 2, 3, 4], \"saturday\": [5], \"sunday\": [6]}\n        stats: List[float] = []\n        for ftype, dows in daytype_map.items():\n            prev_cycle_start = None\n            for dow in dows:\n                candidate = get_prev_cycle_start(t_now, dow)\n                if candidate is not None and candidate in historical_df.index:\n                    prev_cycle_start = candidate\n                    break\n            if prev_cycle_start is None:\n                stats.extend([np.nan] * 11)\n                continue\n\n            try:\n                prog_end = prev_cycle_start + pd.Timedelta(hours=time_elapsed - 1)\n                prog_data = historical_df.loc[prev_cycle_start:prog_end]\n                rem_start = prev_cycle_start + pd.Timedelta(hours=time_elapsed)\n                rem_end = prev_cycle_start + pd.Timedelta(hours=23)\n                rem_data = historical_df.loc[rem_start:rem_end]\n\n                if prog_data.empty:\n                    prog_stats = [0.0] * 6\n                else:\n                    prog_start_price = prog_data.iloc[0][\"prev_close\"]\n                    prog_end_price = prog_data.iloc[-1][\"c\"]\n                    prog_max = prog_data[\"h\"].max()\n                    prog_min = prog_data[\"l\"].min()\n                    prog_max_t = int((prog_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    prog_min_t = int((prog_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    vol_series = prog_data.get(\"volCcy_prev\")\n                    if vol_series is None and \"volCcy\" in prog_data.columns:\n                        vol_series = prog_data[\"volCcy\"].shift(1)\n                    if vol_series is None:\n                        vol_series = pd.Series(0.0, index=prog_data.index)\n                    prog_vlm = vol_series.fillna(0.0).sum()\n                    prog_actp = (prog_end_price / prog_start_price) - 1\n                    prog_maxp = (prog_max / prog_start_price) - 1\n                    prog_minp = (prog_min / prog_start_price) - 1\n                    prog_stats = [prog_actp, prog_minp, prog_maxp, prog_min_t, prog_max_t, prog_vlm]\n\n                if rem_data.empty:\n                    rem_stats = [np.nan] * 5\n                else:\n                    rem_start_price = rem_data.iloc[0][\"prev_close\"]\n                    rem_end_price = rem_data.iloc[-1][\"c\"]\n                    rem_max = rem_data[\"h\"].max()\n                    rem_min = rem_data[\"l\"].min()\n                    rem_max_t = int((rem_data[\"h\"].idxmax() - prev_cycle_start).total_seconds() / 3600)\n                    rem_min_t = int((rem_data[\"l\"].idxmin() - prev_cycle_start).total_seconds() / 3600)\n                    rem_actp = (rem_end_price / rem_start_price) - 1\n                    rem_maxp = (rem_max / rem_start_price) - 1\n                    rem_minp = (rem_min / rem_start_price) - 1\n                    rem_stats = [rem_actp, rem_minp, rem_maxp, rem_min_t, rem_max_t]\n\n                stats.extend(prog_stats + rem_stats)\n            except Exception:\n                stats.extend([np.nan] * 11)\n\n        if len(stats) != 33:\n            return nan_stats\n        return tuple(stats)\n\n    def _add_rolling_stats_for_prev_daytype_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        stat_cols = [\n            col\n            for col in df.columns\n            if col.startswith(\"prev_\")\n            and (\n                col.endswith(\"_ProgMaxP\")\n                or col.endswith(\"_RemMaxP\")\n                or col.endswith(\"_ProgMinP\")\n                or col.endswith(\"_RemMinP\")\n            )\n        ]\n        grouped = df.groupby([\"day_type_num\", \"time_to_exp1_hr\"], group_keys=False)\n        for col in stat_cols:\n            df[f\"{col}_med_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).median()\n            )\n            df[f\"{col}_p10_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.1)\n            )\n            df[f\"{col}_p90_{self.prev_daytype_window}\"] = grouped[col].transform(\n                lambda s: s.rolling(self.prev_daytype_window, min_periods=max(5, self.prev_daytype_window // 5)).quantile(0.9)\n            )\n        return df\n\n    def _add_empirical_probability_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_cols = {\"logret_h_pc\", \"logret_l_pc\"}\n        if not required_cols.issubset(df.columns):\n            raise ValueError(\"Empirical probability features require logret_h_pc and logret_l_pc\")\n\n        thresholds = self.empirical_thresholds\n        for t in thresholds:\n            df[f\"emp_freq_logret_h_pc_ge_{t}\"] = np.nan\n            df[f\"emp_freq_logret_l_pc_le_-{t}\"] = np.nan\n\n        for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n            df[f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = np.nan\n            df[f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = np.nan\n\n        df[\"emp_median_logret_range\"] = np.nan\n        if \"realized_to_expected_24h\" in df.columns:\n            df[\"emp_median_realized_to_expected_24h\"] = np.nan\n        if \"realized_to_expected_tte\" in df.columns:\n            df[\"emp_median_realized_to_expected_tte\"] = np.nan\n\n        grouped = df.groupby([\"hour\", \"day_type_num\"])\n        for (hour, day_type), group in grouped:\n            idx = group.index\n            for t in thresholds:\n                up_mask = (group[\"logret_h_pc\"] >= t).astype(float)\n                down_mask = (group[\"logret_l_pc\"] <= -t).astype(float)\n                up_prob = up_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                down_prob = down_mask.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).mean().shift(1)\n                df.loc[idx, f\"emp_freq_logret_h_pc_ge_{t}\"] = up_prob.values\n                df.loc[idx, f\"emp_freq_logret_l_pc_le_-{t}\"] = down_prob.values\n\n            for p in [0.05, 0.3, 0.5, 0.7, 0.95]:\n                up_pct = group[\"logret_h_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                down_pct = group[\"logret_l_pc\"].rolling(window=self.empirical_window, min_periods=self.empirical_min_count).quantile(p).shift(1)\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_h_pc\"] = up_pct.values\n                df.loc[idx, f\"emp_pct_{int(p * 100)}_logret_l_pc\"] = down_pct.values\n\n            logret_range = group[\"logret_h_pc\"] - group[\"logret_l_pc\"]\n            median_range = logret_range.rolling(window=self.empirical_window, min_periods=self.empirical_min_count).median().shift(1)\n            df.loc[idx, \"emp_median_logret_range\"] = median_range.values\n\n            if \"realized_to_expected_24h\" in group.columns:\n                rte24 = group[\"realized_to_expected_24h\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_24h\"] = rte24.values\n\n            if \"realized_to_expected_tte\" in group.columns:\n                rtette = group[\"realized_to_expected_tte\"].rolling(\n                    window=self.empirical_window,\n                    min_periods=self.empirical_min_count,\n                ).median().shift(1)\n                df.loc[idx, \"emp_median_realized_to_expected_tte\"] = rtette.values\n\n        return df\n\n\nclass FeatureEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"High-level orchestrator for the tiered feature pipeline.\"\"\"\n\n    def __init__(self,\n                 expiration_hour: int = 8,\n                 vol_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vlm_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vol_types_to_calc: Iterable[str] = (\"raw\", \"gkyz\", \"parkinson\", \"rogers_satchell\", \"skew\", \"kurtosis\", \"vol_zscore\", \"log_vol\"),  ## remember to manage based on rocket or catboost\n                 vol_trading_periods: int = 24 * 365,\n                 include_price: bool = False,\n                 include_trend: bool = True,\n                 include_volatility: bool = True,\n                 include_relative_position: bool = True,\n                 include_temporal: bool = True,\n                 include_liquidity: bool = True,\n                 include_non_linear: bool = True,\n                 include_custom_interactions: bool = False,\n                 include_prev_week_cycle: bool = True,\n                 include_dst_feature: bool = True,\n                 cache_dir: Optional[Path] = Path(\"cache\") / \"heavy_features\",\n                 verbose: bool = False) -> None:\n        self.expiration_hour = expiration_hour\n        self.include_price = include_price\n        self.include_trend = include_trend\n        self.include_volatility = include_volatility\n        self.include_relative_position = include_relative_position\n        self.include_temporal = include_temporal\n        self.include_liquidity = include_liquidity\n        self.include_non_linear = include_non_linear\n        self.include_custom_interactions = include_custom_interactions\n        self.include_prev_week_cycle = include_prev_week_cycle\n        self.include_dst_feature = include_dst_feature\n        self.verbose = verbose\n        self.vol_window_sizes = list(vol_window_sizes)\n        self.vlm_window_sizes = list(vlm_window_sizes)\n        self.vol_types_to_calc = [v.lower() for v in vol_types_to_calc]\n        self.vol_trading_periods = vol_trading_periods\n        self.prev_daytype_window = DEFAULT_PREV_DAYTYPE_WINDOW\n        self.empirical_window = DEFAULT_EMPIRICAL_WINDOW\n        self.empirical_min_count = DEFAULT_EMPIRICAL_MIN_COUNT\n        self.empirical_thresholds = list(DEFAULT_EMPIRICAL_THRESHOLDS)\n\n        self.stateless_block = StatelessFeatureBlock(expiration_hour, include_dst_feature)\n        self.rolling_block = RollingFeatureBlock(self.vol_window_sizes,\n                                                 self.vlm_window_sizes,\n                                                 self.vol_types_to_calc,\n                                                 self.vol_trading_periods)\n        self.complex_block = ComplexFeatureBlock(self.prev_daytype_window,\n                                                 self.empirical_window,\n                                                 self.empirical_min_count,\n                                                 self.empirical_thresholds)\n        self.complex_block.expiration_hour = expiration_hour\n\n        self.heavy_cache = HeavyFeatureCache(cache_dir)\n        self.live_state = None\n        self.feature_names_out_ = None\n        self._full_reference = None\n        self._reference_features = None\n        self._heavy_payload: Optional[HeavyFeaturePayload] = None\n\n    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None):\n        reference = self._prepare_reference_frame(X)\n        self._full_reference = reference\n\n        self._log(f\"fit start; rows={len(reference)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(reference, build_heavy=True)\n        self.feature_names_out_ = features.columns.tolist()\n        self._reference_features = features\n        duration = time.perf_counter() - start\n        self._log(\n            f\"fit complete; rows={len(reference)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return self\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        if self._full_reference is None:\n            raise RuntimeError(\"fit() must be called before transform().\")\n        frame = self._prepare_reference_frame(X)\n        self._log(f\"transform start; rows={len(frame)}\")\n        start = time.perf_counter()\n        features = self._compute_all_features(frame, build_heavy=False)\n        duration = time.perf_counter() - start\n        self._log(\n            f\"transform complete; rows={len(frame)}, cols={features.shape[1]}, elapsed={duration:.2f}s\"\n        )\n        return features\n\n    # Live update API -------------------------------------------------\n    def initialize_live_state(self, historical_df: pd.DataFrame) -> LiveStateCache:\n        features = self.transform(historical_df)\n        price_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in historical_df.columns]\n        price_history = historical_df.loc[features.index, price_cols]\n        metadata = {\"max_history\": self._live_history_window()}\n        self.live_state = LiveStateCache(\n            features_df=features.copy(),\n            price_history=price_history.copy(),\n            rolling_states={},\n            ema_states={},\n            metadata=metadata,\n        )\n        return self.live_state\n\n    def compute_next_row(self, new_row: pd.Series, *, commit: bool = False) -> pd.Series:\n        self._ensure_live_state_ready()\n        if not isinstance(new_row.name, pd.Timestamp):\n            raise TypeError(\"New row must have a DatetimeIndex timestamp as its name.\")\n\n        if not self.live_state.price_history.empty:\n            last_index = self.live_state.price_history.index[-1]\n            if new_row.name <= last_index:\n                raise ValueError(\n                    f\"New row timestamp {new_row.name} must be greater than last history index {last_index}.\"\n                )\n\n        return self._append_live_row(new_row, commit=commit)\n\n    def _live_history_window(self) -> int:\n        return max(self.vol_window_sizes + self.vlm_window_sizes + [24 * 30]) + 5\n\n    def update_last_row(self, updated_row: pd.Series, *, commit: bool = True) -> pd.Series:\n        self._ensure_live_state_ready()\n        if self.live_state.price_history.empty:\n            raise RuntimeError(\"Live state history is empty; cannot update last row.\")\n        if not isinstance(updated_row.name, pd.Timestamp):\n            raise TypeError(\"Updated row must have a DatetimeIndex timestamp as its name.\")\n        last_index = self.live_state.price_history.index[-1]\n        if updated_row.name != last_index:\n            raise ValueError(\n                f\"Updated row timestamp {updated_row.name} does not match last history index {last_index}.\"\n            )\n        return self._update_live_last_row(updated_row, commit=commit)\n\n    def ingest_live_row(self, row: pd.Series, *, commit: bool = True) -> pd.Series:\n        \"\"\"Ingest a streaming bar, updating or appending as needed.\n\n        If ``row.name`` (timestamp) matches the most recent entry, the cached\n        features are recomputed for that bar. If the timestamp is newer than the\n        cached history, the bar is appended. Rows older than the last cached bar\n        raise a ``ValueError``.\n        \"\"\"\n\n        self._ensure_live_state_ready()\n        if not isinstance(row.name, pd.Timestamp):\n            raise TypeError(\"Row must have a DatetimeIndex timestamp as its name.\")\n\n        if self.live_state.price_history.empty:\n            return self._append_live_row(row, commit=commit)\n\n        last_index = self.live_state.price_history.index[-1]\n        if row.name > last_index:\n            return self._append_live_row(row, commit=commit)\n        if row.name == last_index:\n            return self._update_live_last_row(row, commit=commit)\n\n        raise ValueError(\n            f\"Row timestamp {row.name} precedes the last cached timestamp {last_index}; \"\n            \"historical backfills are not supported by ingest_live_row().\"\n        )\n\n    def _ensure_live_state_ready(self) -> None:\n        if self.live_state is None:\n            raise RuntimeError(\"Live state not initialized; call initialize_live_state() first.\")\n        if self._heavy_payload is None and self.include_prev_week_cycle:\n            if not self.heavy_cache.load():\n                raise RuntimeError(\"Heavy cache unavailable; run fit() to build heavy features.\")\n            self._heavy_payload = self.heavy_cache.payload\n\n    def _append_live_row(self, new_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_cols = self.live_state.price_history.columns\n        missing_cols = [col for col in price_cols if col not in new_row.index]\n        if missing_cols:\n            raise ValueError(f\"New row missing required columns: {missing_cols}\")\n\n        history_frame = self.live_state.price_history\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) >= max_history:\n            trimmed_history = history_frame.tail(max_history - 1)\n        else:\n            trimmed_history = history_frame\n\n        new_price_frame = new_row[price_cols].to_frame().T\n        candidate_history = pd.concat([trimmed_history, new_price_frame])\n        features = self._compute_all_features(candidate_history, build_heavy=False)\n        new_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.append(new_features, new_row[price_cols])\n        return new_features\n\n    def _update_live_last_row(self, updated_row: pd.Series, *, commit: bool) -> pd.Series:\n        price_history = self.live_state.price_history\n        price_cols = price_history.columns\n        missing_cols = [col for col in price_cols if col not in updated_row.index]\n        if missing_cols:\n            raise ValueError(f\"Updated row missing required columns: {missing_cols}\")\n\n        last_index = price_history.index[-1]\n        history_frame = price_history.copy()\n        history_frame.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        max_history = self.live_state.metadata.get(\"max_history\")\n        if max_history is not None and len(history_frame) > max_history:\n            trimmed_history = history_frame.tail(max_history)\n        else:\n            trimmed_history = history_frame\n\n        features = self._compute_all_features(trimmed_history, build_heavy=False)\n        updated_features = features.iloc[-1]\n\n        if commit:\n            self.live_state.features_df.loc[last_index] = updated_features\n            self.live_state.price_history.loc[last_index, price_cols] = updated_row[price_cols].values\n\n        return updated_features\n\n    # --- Internal helpers --------------------------------------------\n\n    def _prepare_reference_frame(self, df: pd.DataFrame) -> pd.DataFrame:\n        if not isinstance(df.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must use a DatetimeIndex.\")\n        frame = df.copy()\n        if frame.index.tz is not None:\n            frame = frame.tz_localize(None)\n        if not frame.index.is_monotonic_increasing:\n            frame = frame.sort_index()\n        return frame\n\n    def _compute_all_features(self, df: pd.DataFrame, *, build_heavy: bool) -> pd.DataFrame:\n        timings: List[Tuple[str, float]] = []\n\n        suppress_warnings = not self.verbose\n        warnings_ctx = warnings.catch_warnings() if suppress_warnings else nullcontext()\n        with warnings_ctx:\n            if suppress_warnings:\n                warnings.simplefilter(\"ignore\", category=pd.errors.PerformanceWarning)\n                warnings.simplefilter(\"ignore\", category=pd.errors.SettingWithCopyWarning)\n\n            t_start = time.perf_counter()\n            stateless = self.stateless_block.compute(df)\n            timings.append((\"stateless\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = pd.concat([df, stateless], axis=1)\n            if \"volCcy\" in working.columns:\n                working[\"volCcy\"] = working[\"volCcy\"].round()\n            timings.append((\"merge_stateless\", time.perf_counter() - t_start))\n\n            if self.include_temporal:\n                t_start = time.perf_counter()\n                working = self._add_temporal_features(working)\n                timings.append((\"temporal\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            rolling = self.rolling_block.compute(working)\n            working = pd.concat([working, rolling], axis=1)\n            timings.append((\"rolling\", time.perf_counter() - t_start))\n\n            if self.include_prev_week_cycle:\n                t_start = time.perf_counter()\n                if build_heavy or self._heavy_payload is None:\n                    payload = self.complex_block.build_payload(working)\n                    self.heavy_cache.save(payload)\n                    self._heavy_payload = payload\n                else:\n                    payload = self._heavy_payload\n                heavy_df = self._render_heavy_features(working, payload)\n                working = pd.concat([working, heavy_df], axis=1)\n                timings.append((\"prev_week_cycle\", time.perf_counter() - t_start))\n\n            # Add current cycle features (fast computation, not cached)\n            t_start = time.perf_counter()\n            working = self._add_current_cycle_features(working)\n            timings.append((\"current_cycle\", time.perf_counter() - t_start))\n\n            if self.include_non_linear:\n                t_start = time.perf_counter()\n                working = self._add_non_linear_features(working)\n                timings.append((\"non_linear\", time.perf_counter() - t_start))\n            if self.include_custom_interactions:\n                t_start = time.perf_counter()\n                working = self._add_custom_interactions(working)\n                timings.append((\"custom_interactions\", time.perf_counter() - t_start))\n\n            t_start = time.perf_counter()\n            working = working.replace([np.inf, -np.inf], np.nan)\n            working = self._apply_feature_toggles(working)\n            working = working.copy()\n            timings.append((\"cleanup\", time.perf_counter() - t_start))\n\n            if self.verbose:\n                total = sum(duration for _, duration in timings)\n                summary = \", \".join(\n                    f\"{name}:{duration * 1000:.1f}ms\" for name, duration in timings if duration > 0.0\n                )\n                self._log(\n                    f\"feature build complete; rows={len(df)}, cols={working.shape[1]}, total={total:.2f}s [{summary}]\"\n                )\n            return working\n\n    def _log(self, message: str) -> None:\n        if self.verbose:\n            print(f\"[FeatureEngineer] {message}\")\n\n    def _render_heavy_features(self, df: pd.DataFrame, payload: HeavyFeaturePayload) -> pd.DataFrame:\n        pieces: List[pd.DataFrame] = []\n        tte_bucket = self.complex_block._bucket_time_to_exp(df[\"time_to_exp1_hr\"])\n        day_type = df[\"day_type_num\"]\n        hour = df[\"hour\"]\n\n        if not payload.prev_cycle_lookup.empty:\n            idx = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_lookup.index.names,\n            )\n            prev_cycle = payload.prev_cycle_lookup.reindex(idx)\n            prev_cycle.index = df.index\n            pieces.append(prev_cycle)\n\n        if not payload.prev_cycle_stats_lookup.empty:\n            idx_stats = pd.MultiIndex.from_arrays(\n                [day_type.values, tte_bucket.values],\n                names=payload.prev_cycle_stats_lookup.index.names,\n            )\n            stats_df = payload.prev_cycle_stats_lookup.reindex(idx_stats)\n            stats_df.index = df.index\n            pieces.append(stats_df)\n\n        if not payload.empirical_lookup.empty:\n            idx_emp = pd.MultiIndex.from_arrays(\n                [hour.values, day_type.values],\n                names=payload.empirical_lookup.index.names,\n            )\n            emp_df = payload.empirical_lookup.reindex(idx_emp)\n            emp_df.index = df.index\n            pieces.append(emp_df)\n\n        if not pieces:\n            return pd.DataFrame(index=df.index)\n        heavy_df = pd.concat(pieces, axis=1)\n        return heavy_df\n\n    def _apply_feature_toggles(self, df: pd.DataFrame) -> pd.DataFrame:\n        result = df\n\n        if not self.include_price:\n            drop_cols = [col for col in [\"o\", \"h\", \"l\", \"c\", \"volCcy\"] if col in result.columns]\n            result = result.drop(columns=drop_cols)\n        if not self.include_trend:\n            #trend_prefixes = (\"sma_\", \"ema_\", \"momentum_\", \"macd\", \"adx\")  # dont want sma and ema in features as they are prices \n            trend_prefixes = (\"momentum_\", \"macd\", \"adx\")\n            trend_cols = [col for col in result.columns if col.startswith(trend_prefixes)]\n            result = result.drop(columns=trend_cols, errors=\"ignore\")\n        if not self.include_volatility:\n            vol_prefixes = (\"vol_\", \"returns_skew\", \"returns_kurtosis\", \"atr_\", \"log_vol_\")\n            vol_cols = [col for col in result.columns if col.startswith(vol_prefixes)]\n            result = result.drop(columns=vol_cols, errors=\"ignore\")\n        if not self.include_relative_position:\n            rel_prefixes = (\"stoch_pos_\", \"dist_from_\", \"price_rank_\", \"new_24h\")\n            rel_cols = [col for col in result.columns if col.startswith(rel_prefixes)]\n            result = result.drop(columns=rel_cols, errors=\"ignore\")\n        if not self.include_liquidity:\n            vlm_cols = [col for col in result.columns if col.startswith(\"vlm_\")]\n            result = result.drop(columns=vlm_cols, errors=\"ignore\")\n        if not self.include_temporal:\n            temporal_cols = [col for col in [\"tte_phase_cos\", \"tte_phase_sin\", \"is_dst\"] if col in result.columns]\n            result = result.drop(columns=temporal_cols, errors=\"ignore\")\n        helper_cols = [col for col in [\"cycle_id\", \"_cycle_start_ts\", \"_tte_bucket\"] if col in result.columns]\n        if helper_cols:\n            result = result.drop(columns=helper_cols, errors=\"ignore\")\n        return result\n\n    def _add_temporal_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        df = df.copy()\n        tte = df[\"time_to_exp1_hr\"]\n        df[\"tte_phase_cos\"] = np.cos(2 * np.pi * tte / 24)\n        df[\"tte_phase_sin\"] = np.sin(2 * np.pi * tte / 24)\n        return df\n\n    def _add_non_linear_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required_base = {\"c\", \"h\", \"l\"}\n        if not required_base.issubset(df.columns):\n            return df\n\n        vol_series = df.get(\"volCcy_prev\")\n        if vol_series is None and \"volCcy\" in df.columns:\n            vol_series = df[\"volCcy\"].shift(1)\n        if vol_series is None:\n            return df\n\n        working = df.copy()\n        if \"volCcy_prev\" not in working.columns:\n            working[\"volCcy_prev\"] = vol_series\n        if \"vol_gkyz_24h\" not in working.columns:\n            working[\"vol_gkyz_24h\"] = 0.0\n        if \"vlm_ma_24h\" not in working.columns:\n            working[\"vlm_ma_24h\"] = vol_series.rolling(24, min_periods=1).mean()\n\n        working = self._add_vol_volume_interactions(working)\n        working = self._add_higher_order_momentum(working)\n        working = self._add_non_linear_range_features(working)\n        working = self._add_liquidity_shock_features(working, vol_series)\n        working = self._add_time_decay_features(working)\n        working = self._add_tail_specific_features(working)\n        working = self._add_time_to_expiry_interactions(working)\n        return working\n\n    def _add_time_to_expiry_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes scaling: t\n        \n        key_features = [\n            \"vol_gkyz_24h\",\n            \"vlm_ma_24h\",\n            \"returns_kurtosis_24h\",\n            \"returns_skew_24h\",\n            \"extreme_prob\",\n            \"vol_clustering\",\n            \"exp_ret_p90_24h\",\n            \"exp_ret_p10_24h\",\n            \"exp_band_width_24h\",\n            \"exp_ret_p90_tte\",\n            \"exp_ret_p10_tte\",\n            \"exp_band_width_tte\",\n        ]\n        for feat in key_features:\n            if feat in df.columns:\n                # Black-Scholes t scaling (most important for volatility)\n                df[f\"{feat}_x_tte_sqrt\"] = df[feat] * tte_sqrt\n                # Linear scaling (for non-vol features)\n                df[f\"{feat}_x_tte\"] = df[feat] * tte\n                # Higher order terms for capturing non-linear time decay\n                df[f\"{feat}_x_tte_sq\"] = df[feat] * (tte ** 2)\n                df[f\"{feat}_x_tte_cu\"] = df[feat] * (tte ** 3)\n        return df\n\n    def _add_vol_volume_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        cols = [\"vol_gkyz_24h\", \"vlm_ma_24h\", \"returns_1h\"]\n        if not all(col in df.columns for col in cols):\n            return df\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"vol_weighted_vol\"] = safe_vol * np.log1p(safe_vlm)\n        df[\"vol_vlm_ratio_change\"] = (safe_vol / safe_vlm).pct_change().fillna(0)\n        df[\"asym_vol_vlm_impact\"] = np.sign(df[\"returns_1h\"]) * (safe_vol ** 2) * np.sqrt(safe_vlm)\n        return df\n\n    def _add_current_cycle_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add current cycle progress features to transform pipeline.\n        \n        Fast computation of current cycle state for 'where we are now' context.\n        Complements previous cycle features with current positioning.\n        \"\"\"\n        # Only compute if we have the required OHLC data\n        required_cols = [\"h\", \"l\", \"c\", \"prev_close\"]\n        if not all(col in df.columns for col in required_cols):\n            if self.verbose:\n                missing = [col for col in required_cols if col not in df.columns]\n                print(f\"Skipping current cycle features - missing columns: {missing}\")\n            return df\n        \n        return self.complex_block._add_current_cycle_progress_features(df)\n\n    def _add_higher_order_momentum(self, df: pd.DataFrame) -> pd.DataFrame:\n        for w in [6, 12, 24]:\n            col = f\"momentum_{w}h\"\n            if col in df.columns:\n                df[f\"momentum_accel_{w}h\"] = df[col] * df[col].diff()\n        if \"momentum_24h\" in df.columns:\n            momentum_24 = df[\"momentum_24h\"]\n            df[\"signed_momentum_power\"] = np.sign(momentum_24) * np.abs(momentum_24) ** 1.5\n            if \"vol_gkyz_24h\" in df.columns:\n                df[\"mom_vol_interaction\"] = momentum_24 * df[\"vol_gkyz_24h\"].rolling(6, min_periods=1).std()\n        return df\n\n    def _add_non_linear_range_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"range_pc\" not in df.columns:\n            df[\"range_pc\"] = (df[\"h\"].shift(1) - df[\"l\"].shift(1)) / df[\"prev_close\"].replace(0, np.nan)\n        if \"vol_gkyz_24h\" not in df.columns:\n            df[\"vol_gkyz_24h\"] = 0.0\n        if \"close_pos_in_bar\" not in df.columns:\n            range_bar = df[\"h\"].shift(1) - df[\"l\"].shift(1)\n            df[\"close_pos_in_bar\"] = np.where(\n                range_bar.abs() > 1e-9,\n                (df[\"c\"].shift(1) - df[\"l\"].shift(1)) / range_bar,\n                0.5,\n            )\n\n        range_pc = df[\"range_pc\"]\n        vol_24 = df[\"vol_gkyz_24h\"]\n        close_pos = df[\"close_pos_in_bar\"].clip(0, 1)\n        range_ma = range_pc.rolling(24, min_periods=1).mean().clip(lower=1e-9)\n        df[\"compressed_range_vol\"] = np.sqrt(range_pc.clip(lower=0)) * vol_24\n        df[\"range_expansion\"] = (range_pc / range_ma) ** 2\n        df[\"nl_pos_in_range\"] = np.sin(np.pi * close_pos) * vol_24\n        return df\n\n    def _add_liquidity_shock_features(self, df: pd.DataFrame, vol_series: pd.Series) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"vlm_ma_24h\"}\n        if not required.issubset(df.columns):\n            return df\n\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        safe_vlm = df[\"vlm_ma_24h\"].clip(lower=1e-6)\n        df[\"volume_surprise\"] = (vol_series - df[\"vlm_ma_24h\"]) / (safe_vlm * safe_vol)\n        df[\"liq_vol\"] = vol_series.rolling(6, min_periods=2).std() / safe_vlm\n        df[\"liq_vol_ratio_change\"] = (safe_vlm / safe_vol).pct_change().rolling(6, min_periods=2).mean()\n        trend_std = safe_vlm.rolling(24, min_periods=5).std().clip(lower=1e-6)\n        df[\"volume_trend_z\"] = (vol_series - safe_vlm) / trend_std\n        return df\n\n    def _add_time_decay_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        if \"returns_1h\" in df.columns:\n            returns = df[\"returns_1h\"]\n            for w in [6, 12, 24]:\n                weights = np.exp(-np.linspace(0, 1, w))\n                weights /= weights.sum()\n                df[f\"exp_decay_ret_{w}h\"] = returns.rolling(w).apply(\n                    lambda x, wts=weights[::-1]: float(np.dot(x, wts)), raw=True\n                )\n        if \"vol_gkyz_24h\" in df.columns and \"time_to_exp1_hr\" in df.columns:\n            df[\"time_adj_vol\"] = df[\"vol_gkyz_24h\"] * (1 + df[\"time_to_exp1_hr\"] / 24)\n        if {\"vol_gkyz_24h\", \"tte_phase_sin\", \"tte_phase_cos\"}.issubset(df.columns):\n            df[\"cyclical_vol_compression\"] = (\n                df[\"tte_phase_sin\"] * df[\"vol_gkyz_24h\"] +\n                df[\"tte_phase_cos\"] * df[\"vol_gkyz_24h\"].diff()\n            )\n        return df\n\n    def _add_tail_specific_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        required = {\"vol_gkyz_24h\", \"returns_kurtosis_24h\", \"returns_skew_24h\"}\n        if not required.issubset(df.columns):\n            return df\n        safe_vol = df[\"vol_gkyz_24h\"].clip(lower=1e-6)\n        df[\"extreme_prob\"] = (\n            df[\"returns_kurtosis_24h\"] * df[\"returns_skew_24h\"] * safe_vol\n        ).rolling(12, min_periods=3).mean()\n        df[\"vol_clustering\"] = (df[\"vol_gkyz_24h\"].diff() > 0).rolling(24, min_periods=6).sum() * safe_vol\n        return df\n\n    def _add_custom_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        def safe_div(a: pd.Series, b: pd.Series, eps: float = 1e-8) -> pd.Series:\n            denom = b.replace(0, np.nan).fillna(eps)\n            return a / denom\n\n        # Original interactions\n        if {\"pWRemMaxP_p90_vs_median_spread\", \"vol_gkyz_24h_x_tte\"}.issubset(df.columns):\n            df[\"pWRem_spread_to_vol\"] = safe_div(\n                df[\"pWRemMaxP_p90_vs_median_spread\"],\n                df[\"vol_gkyz_24h_x_tte\"].abs() + 1e-6,\n            )\n        if {\"cWProgMaxP_vs_p90_upside\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"progmax_vs_vol\"] = safe_div(df[\"cWProgMaxP_vs_p90_upside\"], df[\"vol_gkyz_24h\"].abs() + 1e-6)\n        if {\"returns_1h\", \"vol_gkyz_24h\", \"vlm_ma_24h\"}.issubset(df.columns):\n            df[\"shock_absorption\"] = df[\"returns_1h\"] * safe_div(df[\"vol_gkyz_24h\"], df[\"vlm_ma_24h\"])\n        \n        # Critical new interactions for direct target optimization\n        df = self._add_tte_volatility_interactions(df)\n        df = self._add_weekend_regime_interactions(df)\n        df = self._add_cycle_progress_interactions(df) \n        df = self._add_extreme_event_interactions(df)\n        \n        return df\n    \n    def _add_tte_volatility_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add time-to-expiry  volatility interactions crucial for return prediction\"\"\"\n        \n        if \"time_to_exp1_hr\" not in df.columns:\n            return df\n            \n        tte = df[\"time_to_exp1_hr\"]\n        tte_sqrt = np.sqrt(tte.clip(lower=1e-6))  # Black-Scholes: t\n        tte_normalized = tte / 168  # Normalize by week\n        \n        # Core TTE  volatility combinations\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\", \"vol_gkyz_288h\",\n                       \"vol_raw_24h\", \"vol_raw_288h\"]  # Include raw vol for consistency\n        \n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                # Black-Scholes t scaling (PRIMARY for volatility  expected move)\n                df[f\"{vol_feat}_x_tte_sqrt\"] = df[vol_feat] * tte_sqrt\n                \n                # Linear TTE (for regime/level effects)\n                df[f\"{vol_feat}_x_tte\"] = df[vol_feat] * tte\n                \n                # Squared TTE (for strong time decay near expiry)\n                df[f\"{vol_feat}_x_tte_sq\"] = df[vol_feat] * (tte_normalized ** 2)\n                \n                # Cyclical TTE effects (captures intraday patterns)\n                if \"tte_phase_sin\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_sin\"] = df[vol_feat] * df[\"tte_phase_sin\"]\n                if \"tte_phase_cos\" in df.columns:\n                    df[f\"{vol_feat}_x_tte_cos\"] = df[vol_feat] * df[\"tte_phase_cos\"]\n        \n        # Volatility term structure  TTE (all three scalings)\n        if {\"vol_gkyz_3h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            vol_term_slope = df[\"vol_gkyz_24h\"] - df[\"vol_gkyz_3h\"]\n            df[\"vol_term_x_tte_sqrt\"] = vol_term_slope * tte_sqrt  # Black-Scholes scaling\n            df[\"vol_term_x_tte\"] = vol_term_slope * tte\n            df[\"vol_term_x_tte_sq\"] = vol_term_slope * (tte_normalized ** 2)\n        \n        return df\n    \n    def _add_weekend_regime_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add weekend/weekday regime-specific interactions\"\"\"\n        \n        if \"is_weekend\" not in df.columns:\n            return df\n            \n        # Weekend-specific volatility behavior\n        vol_features = [\"vol_gkyz_3h\", \"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        for vol_feat in vol_features:\n            if vol_feat in df.columns:\n                df[f\"{vol_feat}_weekend\"] = df[vol_feat] * df[\"is_weekend\"]\n                df[f\"{vol_feat}_weekday\"] = df[vol_feat] * (1 - df[\"is_weekend\"])\n        \n        # Weekend  previous cycle progress (leveraging historical weekend patterns)\n        prev_weekend_cycles = ['prev_saturday', 'prev_sunday'] \n        prev_cycle_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        \n        for weekend_cycle in prev_weekend_cycles:\n            for metric in prev_cycle_metrics:\n                prev_feat = f\"{weekend_cycle}_{metric}\"\n                if prev_feat in df.columns:\n                    df[f\"{prev_feat}_weekend\"] = df[prev_feat] * df[\"is_weekend\"]\n        \n        # Weekend  volume effects\n        if \"vlm_ma_24h\" in df.columns:\n            df[\"volume_weekend_effect\"] = df[\"vlm_ma_24h\"] * df[\"is_weekend\"]\n        \n        return df\n        \n    def _add_cycle_progress_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add previous cycle progress  market condition interactions\n        \n        Note: Uses 'prev_' cycle features (weekday/saturday/sunday) which track \n        complete historical cycles, not current incomplete cycle progress.\n        This is superior for prediction as it uses complete cycle information.\n        \"\"\"\n        \n        # Previous cycle progress features (complete historical cycles)\n        prev_cycle_types = ['prev_weekday', 'prev_saturday', 'prev_sunday']\n        prog_metrics = ['ProgActP', 'ProgMaxP', 'ProgMinP', 'ProgVlm']\n        vol_features = [\"vol_gkyz_6h\", \"vol_gkyz_12h\", \"vol_gkyz_24h\"]\n        \n        # Previous cycle progress  volatility interactions\n        for cycle_type in prev_cycle_types:\n            for prog_metric in prog_metrics:\n                prog_feature = f\"{cycle_type}_{prog_metric}\"\n                if prog_feature in df.columns:\n                    for vol_feat in vol_features:\n                        if vol_feat in df.columns:\n                            # Use simpler naming pattern to match existing interactions\n                            interaction_name = f\"{prog_feature}_x_{vol_feat.replace('vol_gkyz_', 'vol')}\"\n                            df[interaction_name] = df[prog_feature] * df[vol_feat]\n        \n        # Previous cycle range  volatility (more stable than current cycle)\n        for cycle_type in prev_cycle_types:\n            max_feat = f\"{cycle_type}_ProgMaxP\"\n            min_feat = f\"{cycle_type}_ProgMinP\"\n            if {max_feat, min_feat, \"vol_gkyz_12h\"}.issubset(df.columns):\n                cycle_range = df[max_feat] - df[min_feat]\n                df[f\"{cycle_type}_range_x_vol\"] = cycle_range * df[\"vol_gkyz_12h\"]\n        \n        # Cross-regime cycle comparisons (weekday vs weekend behavior)\n        if {\"prev_weekday_ProgActP\", \"prev_saturday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_saturday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_saturday_ProgActP\"]\n        \n        if {\"prev_weekday_ProgActP\", \"prev_sunday_ProgActP\"}.issubset(df.columns):\n            df[\"weekday_vs_sunday_prog\"] = df[\"prev_weekday_ProgActP\"] - df[\"prev_sunday_ProgActP\"]\n        \n        # Previous cycle activity  time effects\n        if {\"prev_weekday_ProgActP\", \"hour_of_week_sin\"}.issubset(df.columns):\n            df[\"prev_cycle_progress_x_hour\"] = df[\"prev_weekday_ProgActP\"] * df[\"hour_of_week_sin\"]\n            \n        return df\n    \n    def _add_extreme_event_interactions(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Add interactions specifically designed for extreme event prediction\"\"\"\n        \n        # Compressed range  volatility for tail events\n        if {\"compressed_range_vol\", \"vol_gkyz_3h\"}.issubset(df.columns):\n            df[\"extreme_range_vol\"] = df[\"compressed_range_vol\"] * df[\"vol_gkyz_3h\"]\n        \n        # Skewness  volatility for asymmetric moves\n        if {\"returns_skew_24h\", \"vol_gkyz_6h\"}.issubset(df.columns):\n            df[\"skew_vol_extreme\"] = df[\"returns_skew_24h\"] * df[\"vol_gkyz_6h\"]\n        \n        # Kurtosis  volatility for fat-tail events\n        if {\"returns_kurtosis_24h\", \"vol_gkyz_12h\"}.issubset(df.columns):\n            df[\"kurtosis_vol_extreme\"] = df[\"returns_kurtosis_24h\"] * df[\"vol_gkyz_12h\"]\n        \n        # Distance from highs  volatility for reversal prediction\n        if {\"dist_from_high_144h\", \"vol_gkyz_24h\"}.issubset(df.columns):\n            df[\"distance_vol_extreme\"] = df[\"dist_from_high_144h\"] * df[\"vol_gkyz_24h\"]\n        \n        # Volume surprise  volatility clustering\n        if {\"volume_surprise\", \"vol_clustering\"}.issubset(df.columns):\n            df[\"vol_surprise_clustering\"] = df[\"volume_surprise\"] * df[\"vol_clustering\"]\n            \n        return df\n","epoch":107,"telemetryInfo":{}}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_926b3694-cc27-4bf4-b344-24aa1dcd8cee",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":11,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02a1e5b3-70ac-4902-8191-b72f5c67edd2\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"3397dc2b-fe69-4464-a3d2-ecb572b28bf6\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"56c8a739-82ac-4456-af29-2d11dbac0c22\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3Mi40M3MgW3N0YXRlbGVzczoyMzcuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi4zbXMsIHRlbXBvcmFsOjEzLjRtcywgcm9sbGluZzo2NjYuN21zLCBwcmV2X3dlZWtfY3ljbGU6MTYyMzE4LjhtcywgY3VycmVudF9jeWNsZTo4NzQwLjdtcywgbm9uX2xpbmVhcjoyNTcuMG1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI4LjBtcywgY2xlYW51cDoxNjYuNm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3Mi40M3MKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"606c9041-f707-4bd4-9637-8da12c00163a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"b1fd361d-53f4-4d6b-9d8d-c7df2afa7afa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjE5cyBbc3RhdGVsZXNzOjIzNy40bXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTAuM21zLCByb2xsaW5nOjY2NC44bXMsIHByZXZfd2Vla19jeWNsZTo0Ny40bXMsIGN1cnJlbnRfY3ljbGU6ODc3NC40bXMsIG5vbl9saW5lYXI6MjUzLjRtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC40bXMsIGNsZWFudXA6MTY3LjJtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC4xOXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgyLjYycyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzI1LjU2cyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzMjUuNTZzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzgwNAoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4MzMuMTlzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzgwNAoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4MzMuMTlzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\n# Pass raw history (has OHLC) instead of features (doesn't have OHLC)\\\\nregime_engineer.fit(history_slice)\\\\ntargets = regime_engineer.transform(history_slice)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(history_slice)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":11,\\\"executionId\\\":\\\"969665ac-be03-49f5-a554-376cd96b4b8c\\\",\\\"runStartTime\\\":1764193299780,\\\"runEndTime\\\":1764194132972,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":7},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":2,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"13a236d4-6b63-47f3-8cd5-6167176fcb74\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = True  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ed0210b8-31be-4712-a14f-6043cb73ef4d\\\",\\\"runStartTime\\\":1764190974245,\\\"runEndTime\\\":1764190974694,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":2,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":3,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ac571381-7b71-4778-b895-f58297c206e0\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpWTE0gZmVhdHVyZXM6IDE4IGZlYXR1cmVzLCA1OTcgdG90YWwgTmFOcwogIHZsbV96c2NvcmVfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgdmxtX21hXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fenNjb3JlXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2IE5hTnMgKCAwLjA3JSkKClBSSUNFIGZlYXR1cmVzOiA3IGZlYXR1cmVzLCA1NDkgdG90YWwgTmFOcwogIHByaWNlX3JhbmtfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgcHJpY2VfcmFua18xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBwcmljZV9yYW5rXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIHByaWNlX3JhbmtfMjRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJpY2VfcmFua18xMmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyIE5hTnMgKCAwLjAyJSkKCkRJU1QgZmVhdHVyZXM6IDE0IGZlYXR1cmVzLCA1NDggdG90YWwgTmFOcwogIGRpc3RfZnJvbV9sb3dfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgZGlzdF9mcm9tX2hpZ2hfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21fbG93XzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIGRpc3RfZnJvbV9oaWdoXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2IE5hTnMgKCAwLjA3JSkKClBSRVYgZmVhdHVyZXM6IDQwIGZlYXR1cmVzLCA1NDEgdG90YWwgTmFOcwogIHByZXZfd2Vla2RheV9Qcm9nVmxtX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKClNUT0NIIGZlYXR1cmVzOiA3IGZlYXR1cmVzLCAyNzQgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgc3RvY2hfcG9zXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBzdG9jaF9wb3NfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMiBOYU5zICggMC4wMiUpCiAgc3RvY2hfcG9zXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKCkVYVFJFTUUgZmVhdHVyZXM6IDYgZmVhdHVyZXMsIDE1NCB0b3RhbCBOYU5zCiAgZXh0cmVtZV9wcm9iICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9jdSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX3NxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3FydCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQoKTE9HUkVUIGZlYXR1cmVzOiAxMSBmZWF0dXJlcywgMTQyIHRvdGFsIE5hTnMKICBsb2dyZXRfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzMgTmFOcyAoIDAuMTQlKQogIGxvZ3JldF8yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNSBOYU5zICggMC4wNSUpCiAgbG9ncmV0XzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzIE5hTnMgKCAwLjAyJSkKICBsb2dyZXRfNmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcgTmFOcyAoIDAuMDElKQogIGxvZ3JldF81aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNiBOYU5zICggMC4wMSUpCgpSRUFMSVpFRCBmZWF0dXJlczogMiBmZWF0dXJlcywgMTQyIHRvdGFsIE5hTnMKICByZWFsaXplZF90b19leHBlY3RlZF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzEgTmFOcyAoIDAuMTMlKQogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCgpESVNUQU5DRSBmZWF0dXJlczogMSBmZWF0dXJlcywgNzIgdG90YWwgTmFOcwogIGRpc3RhbmNlX3ZvbF9leHRyZW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ck5hTiBMb2NhdGlvbiBBbmFseXNpcyAoVG9wIDEwIHdvcnN0IGZlYXR1cmVzKToKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKcHJpY2VfcmFua18yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc3FydDoKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoX3hfdHRlOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfY29zOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc2luOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc3E6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aDoKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2bG1fenNjb3JlXzI4OGg6CiAgVG90YWwgTmFOczogMTQ0ICgwLjI3JSkKICBTdGFydCBOYU5zOiAxNDMgKGJlZm9yZSAyMDE5LTEwLTA3IDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMTQ0aDoKICBUb3RhbCBOYU5zOiAxNDQgKDAuMjclKQogIFN0YXJ0IE5hTnM6IDE0MyAoYmVmb3JlIDIwMTktMTAtMDcgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpwcmljZV9yYW5rXzE0NGg6CiAgVG90YWwgTmFOczogMTQ0ICgwLjI3JSkKICBTdGFydCBOYU5zOiAxNDMgKGJlZm9yZSAyMDE5LTEwLTA3IDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpFeHBlY3RlZCBOYU4gU291cmNlcyAocHJldl93ZWVrZW5kLCBlbXBpcmljYWwsIGV0Yy4pOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmV2X3NhdHVyZGF5L3N1bmRheSBmZWF0dXJlcyB3aXRoIE5hTnM6IDI2CiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfc3VuZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWF4UF94X3ZvbDI0aDogMjQgTmFOcwoKZW1wXyAoZW1waXJpY2FsKSBmZWF0dXJlcyB3aXRoIE5hTnM6IDAKCnByZXZfd2Vla2RheSBmZWF0dXJlcyB3aXRoIE5hTnM6IDEzCiAgcHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfcmFuZ2VfeF92b2w6IDEyIE5hTnMKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93LXdpc2UgTmFOIEFuYWx5c2lzOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClJvd3Mgd2l0aCBBTlkgTmFOczogMzExIC8gNTMsOTY0ICgwLjU4JSkKRmlyc3Qgcm93IHdpdGggTmFOczogMjAxOS0xMC0wMSAwMDowMDowMApMYXN0IHJvdyB3aXRoIE5hTnM6IDIwMjAtMDEtMDkgMTY6MDA6MDAKQ29uc2VjdXRpdmUgTmFOIHJvd3MgYXQgc3RhcnQ6IDI4OApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBlbmQ6IDAK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"62fb8cae-bc23-48a6-99ad-ca683c485064\\\",\\\"runStartTime\\\":1764190980116,\\\"runEndTime\\\":1764190980150,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":3,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":12,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1f1412e1-7cd2-46b8-b9c2-33a34447352a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"283c3fea-6768-4bff-bb80-0707f156ca76\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":12,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"435b3c59-da57-49b1-afe9-99105b1a34d1\\\",\\\"runStartTime\\\":1764194138809,\\\"runEndTime\\\":1764194138938,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":12}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"32f6d188-de21-4613-90a5-b9f186ba6ac4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpBbmFseXppbmcgTWlkZGxlIE5hTiBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpGZWF0dXJlcyB3aXRoIG1pZGRsZSBOYU5zOiAzCgpUb3AgMjAgZmVhdHVyZXMgYnkgTmFOIGNvdW50OgogIG1heF9md2Rfel9zY29yZSAgICAgICAgICAgICAgICAgICAgICAgICAgICA5NiBOYU5zICggMC4xOCUpCiAgbWF4X2p1bXBfel9zY29yZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDk2IE5hTnMgKCAwLjE4JSkKICB2b2xfcmF0aW9fMjRoXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgMjMgTmFOcyAoIDAuMDQlKQoKR3JvdXBlZCBieSBmZWF0dXJlIHR5cGU6CiAgbWF4ICAgICAgICAgICAgICAgICAgICAgMTkyIHRvdGFsIE5hTnMKICB2b2wgICAgICAgICAgICAgICAgICAgICAgMjMgdG90YWwgTmFOcwoKU3RvY2hhc3RpYyBmZWF0dXJlcyB3aXRoIE5hTnM6IDAKICDinJMgTm8gc3RvY2hhc3RpYyBOYU5zIC0gZml4IGlzIHdvcmtpbmchCgpEYXRlIHJhbmdlIG9mIG1pZGRsZSBOYU5zOgogIEZpcnN0OiAyMDIwLTAxLTA1IDE2OjAwOjAwCiAgTGFzdDogMjAyMC0wMS0wOSAxNjowMDowMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Analyze which features have the middle NaNs and verify stochastic fix\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 20 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(20).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Check specifically for stochastic features\\\\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\\\\n        print(f\\\\\\\"\\\\\\\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\\\\\\\")\\\\n        if stoch_features_in_nans:\\\\n            print(\\\\\\\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\\\\\\\")\\\\n            for feat in stoch_features_in_nans:\\\\n                print(f\\\\\\\"    {feat}: {features_with_middle_nans[feat]} NaNs\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"   No stochastic NaNs - fix is working!\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"1d546c88-437b-4127-92bd-e53c6137dd61\\\",\\\"runStartTime\\\":1764192842004,\\\"runEndTime\\\":1764192842029,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"975b86cf\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"33be4f3f-4070-428a-a604-91d308292d75\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpJbnZlc3RpZ2F0aW5nIFJlZ2ltZSBMYWJlbCBOYU5zCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClRvdGFsIHJvd3Mgd2l0aCByZWdpbWVfbGFiZWwgTmFOOiA5NgpEYXRlIHJhbmdlOiAyMDIwLTAxLTA1IDE2OjAwOjAwIHRvIDIwMjAtMDEtMDkgMTU6MDA6MDAKCkZpcnN0IDEwIE5hTiB0aW1lc3RhbXBzOgogIDIwMjAtMDEtMDUgMTY6MDA6MDAKICAyMDIwLTAxLTA1IDE3OjAwOjAwCiAgMjAyMC0wMS0wNSAxODowMDowMAogIDIwMjAtMDEtMDUgMTk6MDA6MDAKICAyMDIwLTAxLTA1IDIwOjAwOjAwCiAgMjAyMC0wMS0wNSAyMTowMDowMAogIDIwMjAtMDEtMDUgMjI6MDA6MDAKICAyMDIwLTAxLTA1IDIzOjAwOjAwCiAgMjAyMC0wMS0wNiAwMDowMDowMAogIDIwMjAtMDEtMDYgMDE6MDA6MDAKCkNoZWNraW5nIHJhdyBkYXRhIGFyb3VuZCBOYU4gcGVyaW9kOgogIFJhdyBkYXRhIHJvd3MgaW4gdGhpcyBwZXJpb2Q6IDE0NAogIEV4cGVjdGVkIHJvd3MgKGhvdXJseSk6IDE0MwogIOKckyBObyB0aW1lIGdhcHMgZm91bmQKCkZlYXR1cmUgdmFsdWVzIGR1cmluZyBOYU4gcGVyaW9kIChmaXJzdCBOYU4gcm93KToKICB2b2xfcnNfMjRoOiBOL0EKICB2b2xfcnNfNzJoOiBOL0EKICB0cmVuZF9zdHJlbmd0aF8yNGg6IDAuMAogIGxvZ3JldF8yNGg6IDAuMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Investigate why regime_label has NaNs in Jan 2020\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Investigating Regime Label NaNs\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get the rows with regime NaNs\\\\nregime_nans = combined_df_clean['regime_label'].isna()\\\\nnan_rows = combined_df_clean[regime_nans]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal rows with regime_label NaN: {regime_nans.sum()}\\\\\\\")\\\\nprint(f\\\\\\\"Date range: {nan_rows.index[0]} to {nan_rows.index[-1]}\\\\\\\")\\\\n\\\\n# Check if this is a continuous block\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 10 NaN timestamps:\\\\\\\")\\\\nfor ts in nan_rows.index[:10]:\\\\n    print(f\\\\\\\"  {ts}\\\\\\\")\\\\n\\\\n# Check the raw data around this period\\\\nif 'raw_history' in globals():\\\\n    print(f\\\\\\\"\\\\\\\\nChecking raw data around NaN period:\\\\\\\")\\\\n    check_start = nan_rows.index[0] - pd.Timedelta(hours=24)\\\\n    check_end = nan_rows.index[-1] + pd.Timedelta(hours=24)\\\\n    \\\\n    raw_slice = raw_history.loc[check_start:check_end]\\\\n    print(f\\\\\\\"  Raw data rows in this period: {len(raw_slice)}\\\\\\\")\\\\n    print(f\\\\\\\"  Expected rows (hourly): {int((check_end - check_start).total_seconds() / 3600)}\\\\\\\")\\\\n    \\\\n    # Check for gaps\\\\n    if len(raw_slice) > 0:\\\\n        time_diffs = raw_slice.index.to_series().diff()\\\\n        gaps = time_diffs[time_diffs > pd.Timedelta(hours=1)]\\\\n        if len(gaps) > 0:\\\\n            print(f\\\\\\\"\\\\\\\\n   Found {len(gaps)} time gaps:\\\\\\\")\\\\n            for gap_time, gap_size in gaps.items():\\\\n                print(f\\\\\\\"    {gap_time}: {gap_size}\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"   No time gaps found\\\\\\\")\\\\n\\\\n# Check what features look like during this period\\\\nprint(f\\\\\\\"\\\\\\\\nFeature values during NaN period (first NaN row):\\\\\\\")\\\\nfirst_nan_row = combined_df_clean.loc[nan_rows.index[0]]\\\\nprint(f\\\\\\\"  vol_rs_24h: {first_nan_row.get('vol_rs_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  vol_rs_72h: {first_nan_row.get('vol_rs_72h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  trend_strength_24h: {first_nan_row.get('trend_strength_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  logret_24h: {first_nan_row.get('logret_24h', 'N/A')}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"a5e0731a\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ca74f128-bd54-421a-8294-4612ff6dc990\\\",\\\"runStartTime\\\":1764186766749,\\\"runEndTime\\\":1764186766756,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":11,\\\"id\\\":\\\"d7da7604\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"d4406837-56f1-45e0-875a-35d5b077fee7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpDaGVja2luZyBBdmFpbGFibGUgVm9sYXRpbGl0eSBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpUb3RhbCB2b2xhdGlsaXR5IGZlYXR1cmVzOiAxNDcKCkZpcnN0IDIwIHZvbCBmZWF0dXJlczoKICBhc3ltX3ZvbF92bG1faW1wYWN0CiAgY29tcHJlc3NlZF9yYW5nZV92b2wKICBjeWNsaWNhbF92b2xfY29tcHJlc3Npb24KICBkaXN0YW5jZV92b2xfZXh0cmVtZQogIGV4dHJlbWVfcmFuZ2Vfdm9sCiAga3VydG9zaXNfdm9sX2V4dHJlbWUKICBsaXFfdm9sCiAgbGlxX3ZvbF9yYXRpb19jaGFuZ2UKICBsb2dfdm9sXzEyaAogIGxvZ192b2xfMTQ0aAogIGxvZ192b2xfMjRoCiAgbG9nX3ZvbF8yODhoCiAgbG9nX3ZvbF8zaAogIGxvZ192b2xfNmgKICBsb2dfdm9sXzcyaAogIG1vbV92b2xfaW50ZXJhY3Rpb24KICBwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sMTJoCiAgcHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDI0aAogIHByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfeF92b2w2aAogIHByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2wxMmgKClJvZ2Vycy1TYXRjaGVsbCB2b2wgZmVhdHVyZXM6IDAKICDimqDvuI8gTk8gUm9nZXJzLVNhdGNoZWxsIHZvbGF0aWxpdHkgZmVhdHVyZXMgZm91bmQhCiAgVGhpcyBtZWFucyB0aGUgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIGNhbm5vdCBjb21wdXRlIHZvbGF0aWxpdHkuCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CldoYXQgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIG5lZWRzOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClRoZSByZWdpbWUgZW5naW5lZXIgY29tcHV0ZXMgUm9nZXJzLVNhdGNoZWxsIHZvbCBpbnRlcm5hbGx5IGZyb20gT0hMQwpJdCBkb2VzIE5PVCB1c2UgcHJlLWNvbXB1dGVkIHZvbF9ycyBmZWF0dXJlcyBmcm9tIGZlYXR1cmVFbmdpbmVlciEKCkJ1dCBpdCdzIHBhc3NlZCB0aGUgZmVhdHVyZXMgRGF0YUZyYW1lLCBhbmQgaXQgc2hvdWxkIGhhdmUgT0hMQyBjb2x1bW5zLi4uCgpPSExDIGNvbHVtbnMgaW4gZmVhdHVyZXM6IFtdCiAg4pqg77iPIE1JU1NJTkcgT0hMQyEgUmVnaW1lIGVuZ2luZWVyIG5lZWRzIGFsbCA0IE9ITEMgY29sdW1ucwogIE1pc3Npbmc6IFsnb3BlbicsICdoaWdoJywgJ2xvdycsICdjbG9zZSddCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Check what volatility features actually exist\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Checking Available Volatility Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get all vol features\\\\nvol_features = [col for col in features.columns if 'vol' in col.lower()]\\\\nprint(f\\\\\\\"\\\\\\\\nTotal volatility features: {len(vol_features)}\\\\\\\")\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 20 vol features:\\\\\\\")\\\\nfor feat in sorted(vol_features)[:20]:\\\\n    print(f\\\\\\\"  {feat}\\\\\\\")\\\\n\\\\n# Specifically look for Rogers-Satchell vol\\\\nrs_vol_features = [col for col in features.columns if 'vol_rs' in col]\\\\nprint(f\\\\\\\"\\\\\\\\nRogers-Satchell vol features: {len(rs_vol_features)}\\\\\\\")\\\\nif rs_vol_features:\\\\n    for feat in rs_vol_features:\\\\n        print(f\\\\\\\"  {feat}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"   NO Rogers-Satchell volatility features found!\\\\\\\")\\\\n    print(\\\\\\\"  This means the VolatilityRegimeEngineer cannot compute volatility.\\\\\\\")\\\\n    \\\\n# Check what the regime engineer expects\\\\nprint(f\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"What VolatilityRegimeEngineer needs:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"The regime engineer computes Rogers-Satchell vol internally from OHLC\\\\\\\")\\\\nprint(\\\\\\\"It does NOT use pre-computed vol_rs features from featureEngineer!\\\\\\\")\\\\nprint(\\\\\\\"\\\\\\\\nBut it's passed the features DataFrame, and it should have OHLC columns...\\\\\\\")\\\\n\\\\n# Check if features has OHLC\\\\nohlc_cols = ['open', 'high', 'low', 'close']\\\\nhas_ohlc = [col for col in ohlc_cols if col in features.columns]\\\\nprint(f\\\\\\\"\\\\\\\\nOHLC columns in features: {has_ohlc}\\\\\\\")\\\\nif len(has_ohlc) < 4:\\\\n    print(f\\\\\\\"   MISSING OHLC! Regime engineer needs all 4 OHLC columns\\\\\\\")\\\\n    print(f\\\\\\\"  Missing: {[c for c in ohlc_cols if c not in features.columns]}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"eba3e393\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d4fccd2c-6cfa-49ea-8edc-87ca880eb6c6\\\",\\\"runStartTime\\\":1764186813314,\\\"runEndTime\\\":1764186813315,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":11,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02e8ec0b-3b6f-441d-90a6-675f52319ac7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"U3BsaXQgc2l6ZXM6CiAgVHJhaW46IDQyLDk0MCByb3dzICg4MC4wJSkKICBWYWw6ICAgNSwzNjcgcm93cyAoMTAuMCUpCiAgVGVzdDogIDUsMzY4IHJvd3MgKDEwLjAlKQoKWCBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA0NTApLCB2YWwgKDUzNjcsIDQ1MCksIHRlc3QgKDUzNjgsIDQ1MCkKeSBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA2KSwgdmFsICg1MzY3LCA2KSwgdGVzdCAoNTM2OCwgNikKCuKaoCBOYU5zIGZvdW5kOgogIFRyYWluOiAyMyBOYU5zCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d6a62885-4d1d-40be-b86b-517d649e6240\\\",\\\"runStartTime\\\":1764186701691,\\\"runEndTime\\\":1764186701778,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":8,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":112,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb::request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","content":"[\"{\\\"transientOutputs\\\":false,\\\"transientCellMetadata\\\":{\\\"breakpointMargin\\\":true,\\\"id\\\":false,\\\"metadata\\\":false,\\\"attachments\\\":false},\\\"transientDocumentMetadata\\\":{\\\"cells\\\":true,\\\"indentAmount\\\":true},\\\"cellContentMetadata\\\":{\\\"attachments\\\":true}}\",\"{\\\"cells\\\":[{\\\"cellKind\\\":1,\\\"language\\\":\\\"markdown\\\",\\\"metadata\\\":{\\\"metadata\\\":{},\\\"id\\\":\\\"4d8fd73a\\\"},\\\"outputs\\\":[],\\\"source\\\":\\\"# Feature & Target Pipeline\\\\nQuick tests and evaluation on new targets/features/models\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"b6cc7e85\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":11,\\\"id\\\":\\\"64b95c13\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02a1e5b3-70ac-4902-8191-b72f5c67edd2\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"SW1wb3J0cyBhbmQgY29uZmlndXJhdGlvbiByZWFkeQo9PT0gTG9hZGluZyAuaGlzdF9kYl8xaC5jc3YgPT09CgpJbml0aWFsIHJvd3M6IDUzLDk2MwoKPT09IEZPVU5EIElTU1VFUyAocHJpb3IgdG8gYXV0b21hdGVkIGZpeGVzKSA9PT0KCvCflLQgVEVNUE9SQUw6IE1pc3NpbmcgaG91cnM6IDEgY2FzZXMKICBNaXNzaW5nIHRpbWVzdGFtcHMgc2FtcGxlOgogICAgMjAyNS0xMS0wNCAxMzowMDowMAoK8J+UtCBEQVRBIElOVEVHUklUWTogSWRlbnRpY2FsIGNvbnNlY3V0aXZlIE9ITEMgcm93czogMTc0IGNhc2VzCiAgU2FtcGxlIGNhc2VzOgogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogICAgeydvJzogJzcxMTAuMTAnLCAnaCc6ICc3MTEwLjEwJywgJ2wnOiAnNzExMC4xMCcsICdjJzogJzcxMTAuMTAnLCAndm9sQ2N5JzogJzAuMDAnfQogIEFmZmVjdGVkIGRhdGVzIChzYW1wbGUpOiAyMDIwLTAxLTAyLCAyMDIwLTAxLTAzLCAyMDIwLTAxLTA0LCAyMDIwLTAxLTA1LCAyMDIwLTAxLTA2Cgo9PT0gQVBQTFlJTkcgQVVUT01BVEVEIEZJWEVTID09PQpBQ1RJT046IFJlc2FtcGxlZC9SZWluZGV4ZWQgdG8gNTM5NjQgaG91cmx5IGludGVydmFscyAod2FzIDUzOTYzKS4KQUNUSU9OOiBGb3J3YXJkLWZpbGxlZCBOYU5zIGFmdGVyIHJlc2FtcGxpbmcuICg1IE5hTnMgcG90ZW50aWFsbHkgZmlsbGVkIGJ5IGZmaWxsKS4KCj09PSBGSU5BTCBTVEFUVVMgKGFmdGVyIGF1dG9tYXRlZCBmaXhlcykgPT09CkRhdGFGcmFtZSBzaGFwZSBwb3N0LWZpeGVzOiAoNTM5NjQsIDUpIChPcmlnaW5hbDogKDUzOTYzLCA2KSkKRGF0ZSByYW5nZTogMjAxOS0xMC0wMSAwMDowMDowMCB0byAyMDI1LTExLTI2IDExOjAwOjAwCk5vIG51bGwgdmFsdWVzIHJlbWFpbmluZyBhZnRlciBmaXhlcy4KVG90YWwgbnVsbCB2YWx1ZXMgcmVtYWluaW5nIGFmdGVyIGZpeGVzOiAwCkxvYWRlZCByYXcgZGF0YTogKDUzOTY0LCA1KSBpbiAwLjA3cwpVc2luZyBzbGljZTogKDUzOTY0LCA1KQpIZWF2eSBjYWNoZSByZWFkeTogaGVhdnlfZmVhdHVyZXNfdjEucGtsICh0b3RhbCAxKSBpbiBjYWNoZS9oZWF2eV9mZWF0dXJlcwoK4pqgIEhlYXZ5IGNhY2hlIG5vdCBhdmFpbGFibGU7IHJ1bm5pbmcgZnVsbCBmaXQgKHNsb3dlcikKW0ZlYXR1cmVFbmdpbmVlcl0gZml0IHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"3397dc2b-fe69-4464-a3d2-ecb572b28bf6\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"56c8a739-82ac-4456-af29-2d11dbac0c22\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTE3Mi40M3MgW3N0YXRlbGVzczoyMzcuOW1zLCBtZXJnZV9zdGF0ZWxlc3M6Mi4zbXMsIHRlbXBvcmFsOjEzLjRtcywgcm9sbGluZzo2NjYuN21zLCBwcmV2X3dlZWtfY3ljbGU6MTYyMzE4LjhtcywgY3VycmVudF9jeWNsZTo4NzQwLjdtcywgbm9uX2xpbmVhcjoyNTcuMG1zLCBjdXN0b21faW50ZXJhY3Rpb25zOjI4LjBtcywgY2xlYW51cDoxNjYuNm1zXQpbRmVhdHVyZUVuZ2luZWVyXSBmaXQgY29tcGxldGU7IHJvd3M9NTM5NjQsIGNvbHM9NDUwLCBlbGFwc2VkPTE3Mi40M3MKW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIHN0YXJ0OyByb3dzPTUzOTY0Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"606c9041-f707-4bd4-9637-8da12c00163a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"L3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zaW4iXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2Vfc2luIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9jb3MiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJ0dGVfcGhhc2VfY29zIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1NzQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcXJ0Il0gPSBkZlt2b2xfZmVhdF0gKiB0dGVfc3FydAovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTU3NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3hfdHRlIl0gPSBkZlt2b2xfZmVhdF0gKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV94X3R0ZV9zcSJdID0gZGZbdm9sX2ZlYXRdICogKHR0ZV9ub3JtYWxpemVkICoqIDIpCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg0OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfc2luIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTg2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1feF90dGVfY29zIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsidHRlX3BoYXNlX2NvcyJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNTkxOiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsidm9sX3Rlcm1feF90dGVfc3FydCJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGVfc3FydCAgIyBCbGFjay1TY2hvbGVzIHNjYWxpbmcKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTI6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZSJdID0gdm9sX3Rlcm1fc2xvcGUgKiB0dGUKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE1OTM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ2b2xfdGVybV94X3R0ZV9zcSJdID0gdm9sX3Rlcm1fc2xvcGUgKiAodHRlX25vcm1hbGl6ZWQgKiogMikKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwNzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtlbmQiXSA9IGRmW3ZvbF9mZWF0XSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZGF5Il0gPSBkZlt2b2xfZmVhdF0gKiAoMSAtIGRmWyJpc193ZWVrZW5kIl0pCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA3OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2VuZCJdID0gZGZbdm9sX2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYwODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7dm9sX2ZlYXR9X3dlZWtkYXkiXSA9IGRmW3ZvbF9mZWF0XSAqICgxIC0gZGZbImlzX3dlZWtlbmQiXSkKL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2MDc6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie3ZvbF9mZWF0fV93ZWVrZW5kIl0gPSBkZlt2b2xfZmVhdF0gKiBkZlsiaXNfd2Vla2VuZCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjA4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmInt2b2xfZmVhdH1fd2Vla2RheSJdID0gZGZbdm9sX2ZlYXRdICogKDEgLSBkZlsiaXNfd2Vla2VuZCJdKQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYxODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7cHJldl9mZWF0fV93ZWVrZW5kIl0gPSBkZltwcmV2X2ZlYXRdICogZGZbImlzX3dlZWtlbmQiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTYyMjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbHVtZV93ZWVrZW5kX2VmZmVjdCJdID0gZGZbInZsbV9tYV8yNGgiXSAqIGRmWyJpc193ZWVrZW5kIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NDg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2ludGVyYWN0aW9uX25hbWVdID0gZGZbcHJvZ19mZWF0dXJlXSAqIGRmW3ZvbF9mZWF0XQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY0ODogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbaW50ZXJhY3Rpb25fbmFtZV0gPSBkZltwcm9nX2ZlYXR1cmVdICogZGZbdm9sX2ZlYXRdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjQ4OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltpbnRlcmFjdGlvbl9uYW1lXSA9IGRmW3Byb2dfZmVhdHVyZV0gKiBkZlt2b2xfZmVhdF0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NTY6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmW2Yie2N5Y2xlX3R5cGV9X3JhbmdlX3hfdm9sIl0gPSBjeWNsZV9yYW5nZSAqIGRmWyJ2b2xfZ2t5el8xMmgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY1NjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbZiJ7Y3ljbGVfdHlwZX1fcmFuZ2VfeF92b2wiXSA9IGN5Y2xlX3JhbmdlICogZGZbInZvbF9na3l6XzEyaCJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjU2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZltmIntjeWNsZV90eXBlfV9yYW5nZV94X3ZvbCJdID0gY3ljbGVfcmFuZ2UgKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3NhdHVyZGF5X3Byb2ciXSA9IGRmWyJwcmV2X3dlZWtkYXlfUHJvZ0FjdFAiXSAtIGRmWyJwcmV2X3NhdHVyZGF5X1Byb2dBY3RQIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2NjM6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJ3ZWVrZGF5X3ZzX3N1bmRheV9wcm9nIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gLSBkZlsicHJldl9zdW5kYXlfUHJvZ0FjdFAiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY2NzogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInByZXZfY3ljbGVfcHJvZ3Jlc3NfeF9ob3VyIl0gPSBkZlsicHJldl93ZWVrZGF5X1Byb2dBY3RQIl0gKiBkZlsiaG91cl9vZl93ZWVrX3NpbiJdCi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uL2ZlYXR1cmVFbmdpbmVlci5weToxNjc2OiBQZXJmb3JtYW5jZVdhcm5pbmc6IERhdGFGcmFtZSBpcyBoaWdobHkgZnJhZ21lbnRlZC4gIFRoaXMgaXMgdXN1YWxseSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGZyYW1lLmluc2VydGAgbWFueSB0aW1lcywgd2hpY2ggaGFzIHBvb3IgcGVyZm9ybWFuY2UuICBDb25zaWRlciBqb2luaW5nIGFsbCBjb2x1bW5zIGF0IG9uY2UgdXNpbmcgcGQuY29uY2F0KGF4aXM9MSkgaW5zdGVhZC4gVG8gZ2V0IGEgZGUtZnJhZ21lbnRlZCBmcmFtZSwgdXNlIGBuZXdmcmFtZSA9IGZyYW1lLmNvcHkoKWAKICBkZlsiZXh0cmVtZV9yYW5nZV92b2wiXSA9IGRmWyJjb21wcmVzc2VkX3JhbmdlX3ZvbCJdICogZGZbInZvbF9na3l6XzNoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODA6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJza2V3X3ZvbF9leHRyZW1lIl0gPSBkZlsicmV0dXJuc19za2V3XzI0aCJdICogZGZbInZvbF9na3l6XzZoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODQ6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJrdXJ0b3Npc192b2xfZXh0cmVtZSJdID0gZGZbInJldHVybnNfa3VydG9zaXNfMjRoIl0gKiBkZlsidm9sX2dreXpfMTJoIl0KL3NoYXJlZC9lYXN0U3luYy9weUVhc3QvcHJvX3ZlcnNpb24vZmVhdHVyZUVuZ2luZWVyLnB5OjE2ODg6IFBlcmZvcm1hbmNlV2FybmluZzogRGF0YUZyYW1lIGlzIGhpZ2hseSBmcmFnbWVudGVkLiAgVGhpcyBpcyB1c3VhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZnJhbWUuaW5zZXJ0YCBtYW55IHRpbWVzLCB3aGljaCBoYXMgcG9vciBwZXJmb3JtYW5jZS4gIENvbnNpZGVyIGpvaW5pbmcgYWxsIGNvbHVtbnMgYXQgb25jZSB1c2luZyBwZC5jb25jYXQoYXhpcz0xKSBpbnN0ZWFkLiBUbyBnZXQgYSBkZS1mcmFnbWVudGVkIGZyYW1lLCB1c2UgYG5ld2ZyYW1lID0gZnJhbWUuY29weSgpYAogIGRmWyJkaXN0YW5jZV92b2xfZXh0cmVtZSJdID0gZGZbImRpc3RfZnJvbV9oaWdoXzE0NGgiXSAqIGRmWyJ2b2xfZ2t5el8yNGgiXQovc2hhcmVkL2Vhc3RTeW5jL3B5RWFzdC9wcm9fdmVyc2lvbi9mZWF0dXJlRW5naW5lZXIucHk6MTY5MjogUGVyZm9ybWFuY2VXYXJuaW5nOiBEYXRhRnJhbWUgaXMgaGlnaGx5IGZyYWdtZW50ZWQuICBUaGlzIGlzIHVzdWFsbHkgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBmcmFtZS5pbnNlcnRgIG1hbnkgdGltZXMsIHdoaWNoIGhhcyBwb29yIHBlcmZvcm1hbmNlLiAgQ29uc2lkZXIgam9pbmluZyBhbGwgY29sdW1ucyBhdCBvbmNlIHVzaW5nIHBkLmNvbmNhdChheGlzPTEpIGluc3RlYWQuIFRvIGdldCBhIGRlLWZyYWdtZW50ZWQgZnJhbWUsIHVzZSBgbmV3ZnJhbWUgPSBmcmFtZS5jb3B5KClgCiAgZGZbInZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nIl0gPSBkZlsidm9sdW1lX3N1cnByaXNlIl0gKiBkZlsidm9sX2NsdXN0ZXJpbmciXQo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stderr\\\"}]},{\\\"outputId\\\":\\\"b1fd361d-53f4-4d6b-9d8d-c7df2afa7afa\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"W0ZlYXR1cmVFbmdpbmVlcl0gZmVhdHVyZSBidWlsZCBjb21wbGV0ZTsgcm93cz01Mzk2NCwgY29scz00NTAsIHRvdGFsPTEwLjE5cyBbc3RhdGVsZXNzOjIzNy40bXMsIG1lcmdlX3N0YXRlbGVzczoyLjNtcywgdGVtcG9yYWw6MTAuM21zLCByb2xsaW5nOjY2NC44bXMsIHByZXZfd2Vla19jeWNsZTo0Ny40bXMsIGN1cnJlbnRfY3ljbGU6ODc3NC40bXMsIG5vbl9saW5lYXI6MjUzLjRtcywgY3VzdG9tX2ludGVyYWN0aW9uczoyOC40bXMsIGNsZWFudXA6MTY3LjJtc10KW0ZlYXR1cmVFbmdpbmVlcl0gdHJhbnNmb3JtIGNvbXBsZXRlOyByb3dzPTUzOTY0LCBjb2xzPTQ1MCwgZWxhcHNlZD0xMC4xOXMKICBGdWxsIGZpdCt0cmFuc2Zvcm0gaW4gMTgyLjYycyAtPiBzaGFwZTogKDUzOTY0LCA0NTApCgotLS0gQnVpbGRpbmcgVm9sYXRpbGl0eSBSZWdpbWUgVGFyZ2V0cyAtLS0KUmVnaW1lIHRhcmdldHMgYnVpbHQgaW4gMzI1LjU2cyAtPiBzaGFwZTogKDUzOTY0LCA2KQpSZWdpbWUgdGFyZ2V0cyBidWlsdCBpbiAzMjUuNTZzIC0+IHNoYXBlOiAoNTM5NjQsIDYpCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzgwNAoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4MzMuMTlzCgpSZWdpbWUgZGlzdHJpYnV0aW9uOgpyZWdpbWVfbGFiZWwKMCAgICA0MzgwNAoxICAgICA2MzY0CjIgICAgIDM3OTUKTmFtZTogY291bnQsIGR0eXBlOiBJbnQ2NAoKQ29tYmluZWQgc2hhcGU6ICg1Mzk2NCwgNDU2KQpUb3RhbCBwaXBlbGluZSB0aW1lOiA4MzMuMTlzCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"import pandas as pd\\\\nfrom pathlib import Path\\\\nfrom typing import Optional\\\\nimport time\\\\nfrom data_pipeline import load_data  # This just loads the data and cleans it\\\\nfrom featureEngineer import FeatureEngineer\\\\nfrom targetEngineer import ExpirationTargetEngineer\\\\nfrom ML_setup import CONFIG\\\\nfrom ML_general_tools import *\\\\nfrom pathlib import Path\\\\n\\\\nprint(\\\\\\\"Imports and configuration ready\\\\\\\")\\\\n\\\\n# Build features, targets, and combined dataframe\\\\nt0 = time.time()\\\\nraw_history = load_data(CONFIG[\\\\\\\"data\\\\\\\"][\\\\\\\"path\\\\\\\"])\\\\nprint(f\\\\\\\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\\n# Use slice for faster testing (or use [:] for full data)\\\\nhistory_slice = raw_history[:]  # Last 3000 rows for faster testing\\\\nprint(f\\\\\\\"Using slice: {history_slice.shape}\\\\\\\")\\\\n\\\\nfeature_params = dict(CONFIG[\\\\\\\"features\\\\\\\"][\\\\\\\"params\\\\\\\"])\\\\nheavy_cache_cfg = CONFIG[\\\\\\\"features\\\\\\\"].get(\\\\\\\"heavy_cache\\\\\\\", {})\\\\nheavy_cache_root = Path(heavy_cache_cfg.get(\\\\\\\"directory\\\\\\\", \\\\\\\"cache/heavy_features\\\\\\\"))\\\\n\\\\ncurrent_output_root_str = CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"directory\\\\\\\"]\\\\ncurrent_output_root_path = Path(current_output_root_str)\\\\n\\\\npaths = {\\\\n    \\\\\\\"root\\\\\\\": current_output_root_path,\\\\n    \\\\\\\"feature_selection\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"features\\\\\\\"],\\\\n    \\\\\\\"trained_models\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"models\\\\\\\"],\\\\n    \\\\\\\"hpt_studies\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"hpt\\\\\\\"],\\\\n    \\\\\\\"feature_cache\\\\\\\": current_output_root_path / CONFIG[\\\\\\\"output\\\\\\\"][\\\\\\\"subdirectories\\\\\\\"][\\\\\\\"cache\\\\\\\"]\\\\n}\\\\n\\\\ncache_dir = heavy_cache_root\\\\ncache_dir.mkdir(parents=True, exist_ok=True)\\\\ncache_files = sorted(cache_dir.glob(\\\\\\\"heavy_features_v*.pkl\\\\\\\"))\\\\ncache_ready = bool(cache_files)\\\\nif cache_ready:\\\\n    print(f\\\\\\\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"No heavy cache file found in {cache_dir}; initial fit will populate.\\\\\\\")\\\\n\\\\n## Feature Engineering\\\\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \\\\\\\"verbose\\\\\\\"})\\\\n\\\\n## Cache usage\\\\ncache_ready = bool(cache_files)  # Use actual cache status\\\\ncache_ready = False\\\\nmanual_features = None\\\\nif cache_ready and fe.heavy_cache.load():\\\\n    print(\\\\\\\"\\\\\\\\n Using heavy cache (only prev_cycle features cached)\\\\\\\")\\\\n    print(\\\\\\\"  Note: Rolling/stateless features still computed on-the-fly\\\\\\\")\\\\n    t1 = time.time()\\\\n    fe._heavy_payload = fe.heavy_cache.payload\\\\n    reference = fe._prepare_reference_frame(history_slice)\\\\n    fe._full_reference = reference\\\\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\\\\n    fe.feature_names_out_ = manual_features.columns.tolist()\\\\n    fe._reference_features = manual_features\\\\n    print(f\\\\\\\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"\\\\\\\\n Heavy cache not available; running full fit (slower)\\\\\\\")\\\\n    t1 = time.time()\\\\n    verbose_flag = feature_params.pop(\\\\\\\"verbose\\\\\\\", False)\\\\n    fe = FeatureEngineer(verbose=True, **feature_params)\\\\n    fe.fit(history_slice)\\\\n    manual_features = fe.transform(history_slice)\\\\n    print(f\\\\\\\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\\\\\\\")\\\\n\\\\nfeature_engineer = fe\\\\nfeatures = manual_features.copy()\\\\n\\\\n## 2a. Volatility Regime Target Engineering ---\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\nprint(\\\\\\\"\\\\\\\\n--- Building Volatility Regime Targets ---\\\\\\\")\\\\nt2 = time.time()\\\\n\\\\nregime_engineer = VolatilityRegimeEngineer(\\\\n    lookback_window=24*3,    # 3 days lookback for vol\\\\n    seasonal_window=24*30,   # 30 days to learn patterns\\\\n    forward_window=24,       # 24h classification\\\\n    trend_std=1.2,           # 1.2 daily sigmas\\\\n    jump_std=3.0,            # 3.0 daily sigmas\\\\n    jump_speed_window=6,     # 6h window for jump detection\\\\n)\\\\n\\\\n# Pass raw history (has OHLC) instead of features (doesn't have OHLC)\\\\nregime_engineer.fit(history_slice)\\\\ntargets = regime_engineer.transform(history_slice)\\\\nprint(f\\\\\\\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\\\\\\\")\\\\n\\\\n# Check distribution\\\\ndist = regime_engineer.get_regime_distribution(history_slice)\\\\nprint(\\\\\\\"\\\\\\\\nRegime distribution:\\\\\\\")\\\\nprint(dist)\\\\n\\\\n# Combine\\\\ncombined_df = pd.concat([features, targets], axis=1)\\\\nprint(f\\\\\\\"\\\\\\\\nCombined shape: {combined_df.shape}\\\\\\\")\\\\nprint(f\\\\\\\"Total pipeline time: {time.time()-t0:.2f}s\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"executionOrder\\\":11,\\\"executionId\\\":\\\"969665ac-be03-49f5-a554-376cd96b4b8c\\\",\\\"runStartTime\\\":1764193299780,\\\"runEndTime\\\":1764194132972,\\\"lastRunSuccess\\\":true,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":7},\\\"runStartTimeAdjustment\\\":0,\\\"internalId\\\":\\\"d9559027\\\"}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":2,\\\"id\\\":\\\"030f489c\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"13a236d4-6b63-47f3-8cd5-6167176fcb74\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CkNhY2hlIG5vdCBmb3VuZCBvciBGT1JDRV9SRUJVSUxEPVRydWUgLSB3aWxsIHNhdmUgYWZ0ZXIgZmlyc3QgcnVuClRvIHVzZSBjYWNoZSBuZXh0IHRpbWU6CiAgMS4gUnVuIHRoZSBmaXJzdCBjZWxsIHdpdGggaGlzdG9yeV9zbGljZSA9IHJhd19oaXN0b3J5WzpdCiAgMi4gV2FpdCBmb3IgZmVhdHVyZXMvdGFyZ2V0cyB0byBjb21wdXRlCiAgMy4gVGhpcyBjZWxsIHdpbGwgc2F2ZSB0aGVtCiAgNC4gTmV4dCB0aW1lLCBzZXQgRk9SQ0VfUkVCVUlMRD1GYWxzZSBhbmQgc2tpcCB0aGUgZmlyc3QgY2VsbAo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClNhdmluZyBjdXJyZW50IGZlYXR1cmVzIGFuZCB0YXJnZXRzIHRvIGNhY2hlLi4uCuKckyBTYXZlZCB0byBjYWNoZSBpbiAwLjQ0cwogIExvY2F0aW9uOiByZXNlYXJjaF92b2wK4pyTIFNhdmVkIHRvIGNhY2hlIGluIDAuNDRzCiAgTG9jYXRpb246IHJlc2VhcmNoX3ZvbAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"import pickle\\\\nfrom pathlib import Path\\\\n\\\\n# Define cache paths\\\\ncache_root = paths[\\\\\\\"root\\\\\\\"]\\\\ncache_root.mkdir(parents=True, exist_ok=True)\\\\n\\\\nfeature_cache = cache_root / \\\\\\\"features_cache.pkl\\\\\\\"\\\\ntarget_cache = cache_root / \\\\\\\"targets_cache.pkl\\\\\\\"\\\\ncombined_cache = cache_root / \\\\\\\"combined_cache.pkl\\\\\\\"\\\\n\\\\n# Option 1: Load from cache if exists\\\\nFORCE_REBUILD = True  # Set to True to rebuild from scratch\\\\n\\\\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Loading cached features and targets...\\\\\\\")\\\\n    t_load = time.time()\\\\n    \\\\n    with open(feature_cache, 'rb') as f:\\\\n        features = pickle.load(f)\\\\n    with open(target_cache, 'rb') as f:\\\\n        targets = pickle.load(f)\\\\n    with open(combined_cache, 'rb') as f:\\\\n        combined_df = pickle.load(f)\\\\n    \\\\n    print(f\\\\\\\" Loaded from cache in {time.time()-t_load:.2f}s\\\\\\\")\\\\n    print(f\\\\\\\"  Features: {features.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Targets: {targets.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Combined: {combined_df.shape}\\\\\\\")\\\\n    print(f\\\\\\\"  Date range: {features.index[0]} to {features.index[-1]}\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\nelse:\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    print(\\\\\\\"Cache not found or FORCE_REBUILD=True - will save after first run\\\\\\\")\\\\n    print(\\\\\\\"To use cache next time:\\\\\\\")\\\\n    print(\\\\\\\"  1. Run the first cell with history_slice = raw_history[:]\\\\\\\")\\\\n    print(\\\\\\\"  2. Wait for features/targets to compute\\\\\\\")\\\\n    print(\\\\\\\"  3. This cell will save them\\\\\\\")\\\\n    print(\\\\\\\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 60)\\\\n    \\\\n    # Save the current run to cache\\\\n    if 'features' in globals() and 'targets' in globals():\\\\n        print(\\\\\\\"\\\\\\\\nSaving current features and targets to cache...\\\\\\\")\\\\n        t_save = time.time()\\\\n        \\\\n        with open(feature_cache, 'wb') as f:\\\\n            pickle.dump(features, f)\\\\n        with open(target_cache, 'wb') as f:\\\\n            pickle.dump(targets, f)\\\\n        with open(combined_cache, 'wb') as f:\\\\n            pickle.dump(combined_df, f)\\\\n        \\\\n        print(f\\\\\\\" Saved to cache in {time.time()-t_save:.2f}s\\\\\\\")\\\\n        print(f\\\\\\\"  Location: {cache_root}\\\\\\\")\\\\n    else:\\\\n        print(\\\\\\\" No features/targets to save yet - run the first cell first\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8d03f25f\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ed0210b8-31be-4712-a14f-6043cb73ef4d\\\",\\\"runStartTime\\\":1764190974245,\\\"runEndTime\\\":1764190974694,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":2,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":3,\\\"id\\\":\\\"aea14ab6\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"ac571381-7b71-4778-b895-f58297c206e0\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gQW5hbHlzaXMgaW4gRmVhdHVyZXMKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKVG90YWwgZmVhdHVyZXM6IDQ1MApGZWF0dXJlcyB3aXRoIE5hTnM6IDIwNwpUb3RhbCByb3dzOiA1Mzk2NAoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpOYU4gRmVhdHVyZXMgR3JvdXBlZCBieSBTb3VyY2U6Cj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClZPTCBmZWF0dXJlczogNTMgZmVhdHVyZXMsIDIsNjk3IHRvdGFsIE5hTnMKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NxcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgdm9sX2dreXpfMjg4aF94X3R0ZV9jb3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjg4IE5hTnMgKCAwLjUzJSkKICB2b2xfZ2t5el8yODhoX3hfdHRlX3NpbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyODggTmFOcyAoIDAuNTMlKQogIHZvbF9na3l6XzI4OGhfeF90dGVfc3EgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCgpWTE0gZmVhdHVyZXM6IDE4IGZlYXR1cmVzLCA1OTcgdG90YWwgTmFOcwogIHZsbV96c2NvcmVfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgdmxtX21hXzI4OGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICB2bG1fenNjb3JlXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIHZsbV9tYV8xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgdmxtX3pzY29yZV83MmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2IE5hTnMgKCAwLjA3JSkKClBSSUNFIGZlYXR1cmVzOiA3IGZlYXR1cmVzLCA1NDkgdG90YWwgTmFOcwogIHByaWNlX3JhbmtfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4OCBOYU5zICggMC41MyUpCiAgcHJpY2VfcmFua18xNDRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBwcmljZV9yYW5rXzcyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIHByaWNlX3JhbmtfMjRoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJpY2VfcmFua18xMmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyIE5hTnMgKCAwLjAyJSkKCkRJU1QgZmVhdHVyZXM6IDE0IGZlYXR1cmVzLCA1NDggdG90YWwgTmFOcwogIGRpc3RfZnJvbV9sb3dfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgZGlzdF9mcm9tX2hpZ2hfMjg4aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTQ0IE5hTnMgKCAwLjI3JSkKICBkaXN0X2Zyb21fbG93XzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzIgTmFOcyAoIDAuMTMlKQogIGRpc3RfZnJvbV9oaWdoXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCiAgZGlzdF9mcm9tX2hpZ2hfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2IE5hTnMgKCAwLjA3JSkKClBSRVYgZmVhdHVyZXM6IDQwIGZlYXR1cmVzLCA1NDEgdG90YWwgTmFOcwogIHByZXZfd2Vla2RheV9Qcm9nVmxtX3hfdm9sMjRoICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKICBwcmV2X3N1bmRheV9Qcm9nTWF4UF94X3ZvbDI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgMjQgTmFOcyAoIDAuMDQlKQogIHByZXZfc3VuZGF5X1Byb2dWbG1feF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgICAyNCBOYU5zICggMC4wNCUpCiAgcHJldl9zdW5kYXlfUHJvZ0FjdFBfeF92b2wyNGggICAgICAgICAgICAgICAgICAgICAgICAgIDI0IE5hTnMgKCAwLjA0JSkKClNUT0NIIGZlYXR1cmVzOiA3IGZlYXR1cmVzLCAyNzQgdG90YWwgTmFOcwogIHN0b2NoX3Bvc18yODhoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE0NCBOYU5zICggMC4yNyUpCiAgc3RvY2hfcG9zXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcyIE5hTnMgKCAwLjEzJSkKICBzdG9jaF9wb3NfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzYgTmFOcyAoIDAuMDclKQogIHN0b2NoX3Bvc18yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMiBOYU5zICggMC4wMiUpCiAgc3RvY2hfcG9zXzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2IE5hTnMgKCAwLjAxJSkKCkVYVFJFTUUgZmVhdHVyZXM6IDYgZmVhdHVyZXMsIDE1NCB0b3RhbCBOYU5zCiAgZXh0cmVtZV9wcm9iICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQogIGV4dHJlbWVfcHJvYl94X3R0ZV9jdSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNiBOYU5zICggMC4wNSUpCiAgZXh0cmVtZV9wcm9iX3hfdHRlX3NxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2IE5hTnMgKCAwLjA1JSkKICBleHRyZW1lX3Byb2JfeF90dGVfc3FydCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjYgTmFOcyAoIDAuMDUlKQoKTE9HUkVUIGZlYXR1cmVzOiAxMSBmZWF0dXJlcywgMTQyIHRvdGFsIE5hTnMKICBsb2dyZXRfNzJoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzMgTmFOcyAoIDAuMTQlKQogIGxvZ3JldF8yNGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyNSBOYU5zICggMC4wNSUpCiAgbG9ncmV0XzEyaCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzIE5hTnMgKCAwLjAyJSkKICBsb2dyZXRfNmggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDcgTmFOcyAoIDAuMDElKQogIGxvZ3JldF81aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNiBOYU5zICggMC4wMSUpCgpSRUFMSVpFRCBmZWF0dXJlczogMiBmZWF0dXJlcywgMTQyIHRvdGFsIE5hTnMKICByZWFsaXplZF90b19leHBlY3RlZF90dGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNzEgTmFOcyAoIDAuMTMlKQogIHJlYWxpemVkX3RvX2V4cGVjdGVkXzI0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MSBOYU5zICggMC4xMyUpCgpESVNUQU5DRSBmZWF0dXJlczogMSBmZWF0dXJlcywgNzIgdG90YWwgTmFOcwogIGRpc3RhbmNlX3ZvbF9leHRyZW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3MiBOYU5zICggMC4xMyUpCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ck5hTiBMb2NhdGlvbiBBbmFseXNpcyAoVG9wIDEwIHdvcnN0IGZlYXR1cmVzKToKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKcHJpY2VfcmFua18yODhoOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc3FydDoKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2b2xfZ2t5el8yODhoX3hfdHRlOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfY29zOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc2luOgogIFRvdGFsIE5hTnM6IDI4OCAoMC41MyUpCiAgU3RhcnQgTmFOczogMjg3IChiZWZvcmUgMjAxOS0xMC0xMyAwMDowMDowMCkKICBNaWRkbGUgTmFOczogMgogIEVuZCBOYU5zOiAtMSAoYWZ0ZXIgMjAyNS0xMS0yNiAxMTowMDowMCkKCnZvbF9na3l6XzI4OGhfeF90dGVfc3E6CiAgVG90YWwgTmFOczogMjg4ICgwLjUzJSkKICBTdGFydCBOYU5zOiAyODcgKGJlZm9yZSAyMDE5LTEwLTEzIDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMjg4aDoKICBUb3RhbCBOYU5zOiAyODggKDAuNTMlKQogIFN0YXJ0IE5hTnM6IDI4NyAoYmVmb3JlIDIwMTktMTAtMTMgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgp2bG1fenNjb3JlXzI4OGg6CiAgVG90YWwgTmFOczogMTQ0ICgwLjI3JSkKICBTdGFydCBOYU5zOiAxNDMgKGJlZm9yZSAyMDE5LTEwLTA3IDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKdm9sX2dreXpfMTQ0aDoKICBUb3RhbCBOYU5zOiAxNDQgKDAuMjclKQogIFN0YXJ0IE5hTnM6IDE0MyAoYmVmb3JlIDIwMTktMTAtMDcgMDA6MDA6MDApCiAgTWlkZGxlIE5hTnM6IDIKICBFbmQgTmFOczogLTEgKGFmdGVyIDIwMjUtMTEtMjYgMTE6MDA6MDApCgpwcmljZV9yYW5rXzE0NGg6CiAgVG90YWwgTmFOczogMTQ0ICgwLjI3JSkKICBTdGFydCBOYU5zOiAxNDMgKGJlZm9yZSAyMDE5LTEwLTA3IDAwOjAwOjAwKQogIE1pZGRsZSBOYU5zOiAyCiAgRW5kIE5hTnM6IC0xIChhZnRlciAyMDI1LTExLTI2IDExOjAwOjAwKQoKPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpFeHBlY3RlZCBOYU4gU291cmNlcyAocHJldl93ZWVrZW5kLCBlbXBpcmljYWwsIGV0Yy4pOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpwcmV2X3NhdHVyZGF5L3N1bmRheSBmZWF0dXJlcyB3aXRoIE5hTnM6IDI2CiAgcHJldl9zYXR1cmRheV9Qcm9nTWluUF94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfc3VuZGF5X1Byb2dNYXhQX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zdW5kYXlfUHJvZ1ZsbV94X3ZvbDI0aDogMjQgTmFOcwogIHByZXZfc3VuZGF5X1Byb2dBY3RQX3hfdm9sMjRoOiAyNCBOYU5zCiAgcHJldl9zYXR1cmRheV9Qcm9nTWF4UF94X3ZvbDI0aDogMjQgTmFOcwoKZW1wXyAoZW1waXJpY2FsKSBmZWF0dXJlcyB3aXRoIE5hTnM6IDAKCnByZXZfd2Vla2RheSBmZWF0dXJlcyB3aXRoIE5hTnM6IDEzCiAgcHJldl93ZWVrZGF5X1Byb2dWbG1feF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01pblBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ01heFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfUHJvZ0FjdFBfeF92b2wyNGg6IDI0IE5hTnMKICBwcmV2X3dlZWtkYXlfcmFuZ2VfeF92b2w6IDEyIE5hTnMKCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KUm93LXdpc2UgTmFOIEFuYWx5c2lzOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClJvd3Mgd2l0aCBBTlkgTmFOczogMzExIC8gNTMsOTY0ICgwLjU4JSkKRmlyc3Qgcm93IHdpdGggTmFOczogMjAxOS0xMC0wMSAwMDowMDowMApMYXN0IHJvdyB3aXRoIE5hTnM6IDIwMjAtMDEtMDkgMTY6MDA6MDAKQ29uc2VjdXRpdmUgTmFOIHJvd3MgYXQgc3RhcnQ6IDI4OApDb25zZWN1dGl2ZSBOYU4gcm93cyBhdCBlbmQ6IDAK\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Comprehensive NaN analysis in features\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Analysis in Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# 1. Overall NaN statistics\\\\nnan_counts = features.isna().sum()\\\\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal features: {len(features.columns)}\\\\\\\")\\\\nprint(f\\\\\\\"Features with NaNs: {len(nan_features)}\\\\\\\")\\\\nprint(f\\\\\\\"Total rows: {len(features)}\\\\\\\")\\\\n\\\\n# 2. Group NaN features by prefix to identify source\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Features Grouped by Source:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfeature_groups = {}\\\\nfor feat in nan_features.index:\\\\n    # Extract prefix (everything before first underscore or digit)\\\\n    if '_' in feat:\\\\n        prefix = feat.split('_')[0]\\\\n    else:\\\\n        prefix = 'other'\\\\n    \\\\n    if prefix not in feature_groups:\\\\n        feature_groups[prefix] = []\\\\n    feature_groups[prefix].append((feat, nan_counts[feat]))\\\\n\\\\n# Sort groups by total NaN count\\\\nsorted_groups = sorted(feature_groups.items(), \\\\n                       key=lambda x: sum(count for _, count in x[1]), \\\\n                       reverse=True)\\\\n\\\\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\\\\n    total_nans = sum(count for _, count in features_list)\\\\n    print(f\\\\\\\"\\\\\\\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\\\\\\\")\\\\n    # Show top 5 within each group\\\\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\\\\n        pct = (count / len(features)) * 100\\\\n        print(f\\\\\\\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n\\\\n# 3. Analyze NaN patterns (start/middle/end)\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"NaN Location Analysis (Top 10 worst features):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nfor feat in nan_features.head(10).index:\\\\n    series = features[feat]\\\\n    nan_mask = series.isna()\\\\n    \\\\n    # Find first and last valid index\\\\n    valid_indices = series[~nan_mask].index\\\\n    if len(valid_indices) == 0:\\\\n        print(f\\\\\\\"\\\\\\\\n{feat}: ALL NaNs!\\\\\\\")\\\\n        continue\\\\n    \\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count NaNs at start, middle, end\\\\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\\\\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\\\\n    middle_nans = nan_mask.sum() - start_nans - end_nans\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\n{feat}:\\\\\\\")\\\\n    print(f\\\\\\\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs: {start_nans:,} (before {first_valid})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle NaNs: {middle_nans:,}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs: {end_nans:,} (after {last_valid})\\\\\\\")\\\\n\\\\n# 4. Check specific feature types that are expected\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Expected NaN Sources (prev_weekend, empirical, etc.):\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\\\\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\\\\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\\\\\\\")\\\\nif prev_weekend_features:\\\\n    for feat in prev_weekend_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\\\\\\\")\\\\nif empirical_features:\\\\n    for feat in empirical_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\\\\\\\")\\\\nif prev_weekday_features:\\\\n    for feat in prev_weekday_features[:5]:\\\\n        print(f\\\\\\\"  {feat}: {nan_counts[feat]:,} NaNs\\\\\\\")\\\\n\\\\n# 5. Check which rows have NaNs\\\\nprint(\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Row-wise NaN Analysis:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\nrows_with_nans = features.isna().any(axis=1)\\\\nprint(f\\\\\\\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\\\\\\\")\\\\n\\\\n# Show first and last rows with NaNs\\\\nnan_row_indices = features[rows_with_nans].index\\\\nif len(nan_row_indices) > 0:\\\\n    print(f\\\\\\\"First row with NaNs: {nan_row_indices[0]}\\\\\\\")\\\\n    print(f\\\\\\\"Last row with NaNs: {nan_row_indices[-1]}\\\\\\\")\\\\n    \\\\n    # Count consecutive NaNs at start and end\\\\n    consecutive_start = 0\\\\n    for i in range(len(rows_with_nans)):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_start += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    consecutive_end = 0\\\\n    for i in range(len(rows_with_nans)-1, -1, -1):\\\\n        if rows_with_nans.iloc[i]:\\\\n            consecutive_end += 1\\\\n        else:\\\\n            break\\\\n    \\\\n    print(f\\\\\\\"Consecutive NaN rows at start: {consecutive_start}\\\\\\\")\\\\n    print(f\\\\\\\"Consecutive NaN rows at end: {consecutive_end}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8809a7a5\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"62fb8cae-bc23-48a6-99ad-ca683c485064\\\",\\\"runStartTime\\\":1764190980116,\\\"runEndTime\\\":1764190980150,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":3,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":12,\\\"id\\\":\\\"cd8f63c2\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"1f1412e1-7cd2-46b8-b9c2-33a34447352a\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"TmFOIFN1bW1hcnk6CiAgRmlyc3QgdmFsaWQgcm93OiAyMDE5LTEwLTEzIDAwOjAwOjAwCiAgTGFzdCB2YWxpZCByb3c6IDIwMjUtMTEtMjYgMTA6MDA6MDAKICBTdGFydCBOYU5zIHRvIGRyb3A6IDI4NwogIEVuZCBOYU5zIHRvIGRyb3A6IDAKCkFmdGVyIHRyaW1taW5nIHN0YXJ0L2VuZDoKICBSb3dzOiA1MzY3NSAoZnJvbSAyMDE5LTEwLTEzIDAwOjAwOjAwIHRvIDIwMjUtMTEtMjYgMTA6MDA6MDApCiAgTWlkZGxlIHJvd3Mgd2l0aCBOYU5zOiA5NwogIOKaoO+4jyBXQVJOSU5HOiA5NyByb3dzIHdpdGggTmFOcyBpbiBtaWRkbGUgLSBwcmVzZXJ2ZWQgZm9yIGRlYnVnZ2luZwo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"283c3fea-6768-4bff-bb80-0707f156ca76\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"execute_result\\\",\\\"executionCount\\\":12,\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PGRpdj4KPHN0eWxlIHNjb3BlZD4KICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGg6b25seS1vZi10eXBlIHsKICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOwogICAgfQoKICAgIC5kYXRhZnJhbWUgdGJvZHkgdHIgdGggewogICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7CiAgICB9CgogICAgLmRhdGFmcmFtZSB0aGVhZCB0aCB7CiAgICAgICAgdGV4dC1hbGlnbjogcmlnaHQ7CiAgICB9Cjwvc3R5bGU+Cjx0YWJsZSBib3JkZXI9IjEiIGNsYXNzPSJkYXRhZnJhbWUiPgogIDx0aGVhZD4KICAgIDx0ciBzdHlsZT0idGV4dC1hbGlnbjogcmlnaHQ7Ij4KICAgICAgPHRoPjwvdGg+CiAgICAgIDx0aD5vPC90aD4KICAgICAgPHRoPmg8L3RoPgogICAgICA8dGg+bDwvdGg+CiAgICAgIDx0aD5jPC90aD4KICAgICAgPHRoPnZvbENjeTwvdGg+CiAgICAgIDx0aD50aW1lX3RvX2V4cDFfaHI8L3RoPgogICAgICA8dGg+dGltZV9lbGFwc2VkPC90aD4KICAgICAgPHRoPmhvdXI8L3RoPgogICAgICA8dGg+ZGF5X29mX3dlZWs8L3RoPgogICAgICA8dGg+aXNfd2Vla2VuZDwvdGg+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGg+c2tld192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5rdXJ0b3Npc192b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD5kaXN0YW5jZV92b2xfZXh0cmVtZTwvdGg+CiAgICAgIDx0aD52b2xfc3VycHJpc2VfY2x1c3RlcmluZzwvdGg+CiAgICAgIDx0aD5yZWdpbWVfbGFiZWw8L3RoPgogICAgICA8dGg+bWF4X2Z3ZF96X3Njb3JlPC90aD4KICAgICAgPHRoPm1heF9qdW1wX3pfc2NvcmU8L3RoPgogICAgICA8dGg+Ym94X3N0ZF9kZXNlYXNvbmFsaXplZDwvdGg+CiAgICAgIDx0aD5ib3hfc3RkX3JhdzwvdGg+CiAgICAgIDx0aD5zZWFzb25hbF92b2w8L3RoPgogICAgPC90cj4KICA8L3RoZWFkPgogIDx0Ym9keT4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODMwOC41PC90ZD4KICAgICAgPHRkPjgzNDEuMzwvdGQ+CiAgICAgIDx0ZD44Mjg5Ljk8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjcxOC4wPC90ZD4KICAgICAgPHRkPjcuMDwvdGQ+CiAgICAgIDx0ZD4xNy4wPC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjE4MzE8L3RkPgogICAgICA8dGQ+LTAuMTQxMjQyPC90ZD4KICAgICAgPHRkPjAuMDE2ODE2PC90ZD4KICAgICAgPHRkPi0yLjgxNDgwMzwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNjg3MDY3PC90ZD4KICAgICAgPHRkPjEuMzc0MTM0PC90ZD4KICAgICAgPHRkPjAuMDA2NzI5PC90ZD4KICAgICAgPHRkPjAuMDA1MTM1PC90ZD4KICAgICAgPHRkPjAuMDAzNDM3PC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDE5LTEwLTEzIDAxOjAwOjAwPC90aD4KICAgICAgPHRkPjgzMzYuNzwvdGQ+CiAgICAgIDx0ZD44MzY4LjU8L3RkPgogICAgICA8dGQ+ODMzNi43PC90ZD4KICAgICAgPHRkPjgzNDkuOTwvdGQ+CiAgICAgIDx0ZD43OTYuMDwvdGQ+CiAgICAgIDx0ZD42LjA8L3RkPgogICAgICA8dGQ+MTguMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjY8L3RkPgogICAgICA8dGQ+MTwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+LTAuMzI1MTIxPC90ZD4KICAgICAgPHRkPi0wLjIxMjA3MTwvdGQ+CiAgICAgIDx0ZD4wLjAxNTUyNDwvdGQ+CiAgICAgIDx0ZD4tMC4yMTUwMzU8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjkwMTUxNTwvdGQ+CiAgICAgIDx0ZD4xLjgwMzAzMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTE0NzwvdGQ+CiAgICAgIDx0ZD4wLjAwNDIyNTwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMjowMDowMDwvdGg+CiAgICAgIDx0ZD44MzUwLjA8L3RkPgogICAgICA8dGQ+ODM1OC42PC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+NDIxLjA8L3RkPgogICAgICA8dGQ+NS4wPC90ZD4KICAgICAgPHRkPjE5LjA8L3RkPgogICAgICA8dGQ+MzwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMyOTk2OTwvdGQ+CiAgICAgIDx0ZD4tMC4yMDUxMzE8L3RkPgogICAgICA8dGQ+MC4wMTQ5NjU8L3RkPgogICAgICA8dGQ+MC4xNjkyMTA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjcyMDk3MjwvdGQ+CiAgICAgIDx0ZD4xLjQ0MTk0NTwvdGQ+CiAgICAgIDx0ZD4wLjAwNjc1OTwvdGQ+CiAgICAgIDx0ZD4wLjAwNTEzMjwvdGQ+CiAgICAgIDx0ZD4wLjAwMzQyMDwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAxOS0xMC0xMyAwMzowMDowMDwvdGg+CiAgICAgIDx0ZD44MzQ2Ljk8L3RkPgogICAgICA8dGQ+ODM0OC4wPC90ZD4KICAgICAgPHRkPjgzNDAuMDwvdGQ+CiAgICAgIDx0ZD44MzQ1LjA8L3RkPgogICAgICA8dGQ+MTU0LjA8L3RkPgogICAgICA8dGQ+NC4wPC90ZD4KICAgICAgPHRkPjIwLjA8L3RkPgogICAgICA8dGQ+NDwvdGQ+CiAgICAgIDx0ZD42PC90ZD4KICAgICAgPHRkPjE8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjMzMDAxNjwvdGQ+CiAgICAgIDx0ZD4tMC4yMjUzMTg8L3RkPgogICAgICA8dGQ+MC4wMTUwNDA8L3RkPgogICAgICA8dGQ+LTEuMzIyODAyPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC42MzgzMDA8L3RkPgogICAgICA8dGQ+MS4yNzY2MDA8L3RkPgogICAgICA8dGQ+MC4wMDc1NjE8L3RkPgogICAgICA8dGQ+MC4wMDUxMTA8L3RkPgogICAgICA8dGQ+MC4wMDMwNDQ8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMTktMTAtMTMgMDQ6MDA6MDA8L3RoPgogICAgICA8dGQ+ODM0NS4wPC90ZD4KICAgICAgPHRkPjgzNjMuNDwvdGQ+CiAgICAgIDx0ZD44MzQxLjE8L3RkPgogICAgICA8dGQ+ODM0MS43PC90ZD4KICAgICAgPHRkPjU3Ni4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjU8L3RkPgogICAgICA8dGQ+NjwvdGQ+CiAgICAgIDx0ZD4xPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4tMC4zNjQ4MDE8L3RkPgogICAgICA8dGQ+LTAuMjMyMjAyPC90ZD4KICAgICAgPHRkPjAuMDE1MTg4PC90ZD4KICAgICAgPHRkPi0zLjE3NTgyODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuNzg4NDYyPC90ZD4KICAgICAgPHRkPjEuNTc2OTIzPC90ZD4KICAgICAgPHRkPjAuMDA2MDE5PC90ZD4KICAgICAgPHRkPjAuMDA1MTA3PC90ZD4KICAgICAgPHRkPjAuMDAzODIyPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4uLi48L3RoPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDY6MDA6MDA8L3RoPgogICAgICA8dGQ+ODc0NTIuNTwvdGQ+CiAgICAgIDx0ZD44NzgyNy4zPC90ZD4KICAgICAgPHRkPjg3MzgzLjQ8L3RkPgogICAgICA8dGQ+ODc3MzMuOTwvdGQ+CiAgICAgIDx0ZD4zMzguMDwvdGQ+CiAgICAgIDx0ZD4xLjA8L3RkPgogICAgICA8dGQ+MjMuMDwvdGQ+CiAgICAgIDx0ZD43PC90ZD4KICAgICAgPHRkPjI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4uLi48L3RkPgogICAgICA8dGQ+MC4wMDUzOTI8L3RkPgogICAgICA8dGQ+LTEuMzI5MTkyPC90ZD4KICAgICAgPHRkPjAuMDMyMDkwPC90ZD4KICAgICAgPHRkPi05LjMxNDU2ODwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPjAuMzkxMTY1PC90ZD4KICAgICAgPHRkPjAuMDAwMDAwPC90ZD4KICAgICAgPHRkPjAuMDA2ODE0PC90ZD4KICAgICAgPHRkPjAuMDA1NTExPC90ZD4KICAgICAgPHRkPjAuMDAzNjQzPC90ZD4KICAgIDwvdHI+CiAgICA8dHI+CiAgICAgIDx0aD4yMDI1LTExLTI2IDA3OjAwOjAwPC90aD4KICAgICAgPHRkPjg3NzI1LjI8L3RkPgogICAgICA8dGQ+ODc5MDAuMDwvdGQ+CiAgICAgIDx0ZD44NzYzNy43PC90ZD4KICAgICAgPHRkPjg3ODcyLjY8L3RkPgogICAgICA8dGQ+MTk1LjA8L3RkPgogICAgICA8dGQ+MjQuMDwvdGQ+CiAgICAgIDx0ZD4wLjA8L3RkPgogICAgICA8dGQ+ODwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPjAuMDEzOTAzPC90ZD4KICAgICAgPHRkPi0xLjE0OTM5NTwvdGQ+CiAgICAgIDx0ZD4wLjAyODA2ODwvdGQ+CiAgICAgIDx0ZD4tMS45NzIwNDA8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjQ2NzM3MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwNjM5MzwvdGQ+CiAgICAgIDx0ZD4wLjAwNTQ4MzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzg2MzwvdGQ+CiAgICA8L3RyPgogICAgPHRyPgogICAgICA8dGg+MjAyNS0xMS0yNiAwODowMDowMDwvdGg+CiAgICAgIDx0ZD44Nzg3Mi43PC90ZD4KICAgICAgPHRkPjg3ODgxLjg8L3RkPgogICAgICA8dGQ+ODczNDIuOTwvdGQ+CiAgICAgIDx0ZD44NzM2MS43PC90ZD4KICAgICAgPHRkPjIzMi4wPC90ZD4KICAgICAgPHRkPjIzLjA8L3RkPgogICAgICA8dGQ+MS4wPC90ZD4KICAgICAgPHRkPjk8L3RkPgogICAgICA8dGQ+MjwvdGQ+CiAgICAgIDx0ZD4wPC90ZD4KICAgICAgPHRkPi4uLjwvdGQ+CiAgICAgIDx0ZD4wLjAxNDU3MjwvdGQ+CiAgICAgIDx0ZD4tMS4xMTUyNDI8L3RkPgogICAgICA8dGQ+MC4wMjY5NzI8L3RkPgogICAgICA8dGQ+LTYuMzE4NjkxPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4yNDk1MDE8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDcyMDQ8L3RkPgogICAgICA8dGQ+MC4wMDU0ODE8L3RkPgogICAgICA8dGQ+MC4wMDM0Mjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMDk6MDA6MDA8L3RoPgogICAgICA8dGQ+ODczNTMuNTwvdGQ+CiAgICAgIDx0ZD44NzM5Ni43PC90ZD4KICAgICAgPHRkPjg2NjI3Ljk8L3RkPgogICAgICA8dGQ+ODY3NzYuMjwvdGQ+CiAgICAgIDx0ZD41NjcuMDwvdGQ+CiAgICAgIDx0ZD4yMi4wPC90ZD4KICAgICAgPHRkPjIuMDwvdGQ+CiAgICAgIDx0ZD4xMDwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjA1NDc5NzwvdGQ+CiAgICAgIDx0ZD4tMS4xMzk1NDQ8L3RkPgogICAgICA8dGQ+MC4wMzAxMjY8L3RkPgogICAgICA8dGQ+LTQuOTg5Mzc2PC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+MC4wOTI3MjA8L3RkPgogICAgICA8dGQ+MC4wMDAwMDA8L3RkPgogICAgICA8dGQ+MC4wMDU2Njg8L3RkPgogICAgICA8dGQ+MC4wMDU0OTU8L3RkPgogICAgICA8dGQ+MC4wMDQzNjc8L3RkPgogICAgPC90cj4KICAgIDx0cj4KICAgICAgPHRoPjIwMjUtMTEtMjYgMTA6MDA6MDA8L3RoPgogICAgICA8dGQ+ODY3NzIuMjwvdGQ+CiAgICAgIDx0ZD44Njk5OS45PC90ZD4KICAgICAgPHRkPjg2NTk1Ljg8L3RkPgogICAgICA8dGQ+ODY4NzkuNzwvdGQ+CiAgICAgIDx0ZD4xOTUuMDwvdGQ+CiAgICAgIDx0ZD4yMS4wPC90ZD4KICAgICAgPHRkPjMuMDwvdGQ+CiAgICAgIDx0ZD4xMTwvdGQ+CiAgICAgIDx0ZD4yPC90ZD4KICAgICAgPHRkPjA8L3RkPgogICAgICA8dGQ+Li4uPC90ZD4KICAgICAgPHRkPi0wLjEwODAzMzwvdGQ+CiAgICAgIDx0ZD4tMC45ODU5MjM8L3RkPgogICAgICA8dGQ+MC4wMzM2NDM8L3RkPgogICAgICA8dGQ+Ny4xMzAyNzI8L3RkPgogICAgICA8dGQ+MDwvdGQ+CiAgICAgIDx0ZD4wLjAxNzQ2MTwvdGQ+CiAgICAgIDx0ZD4wLjAwMDAwMDwvdGQ+CiAgICAgIDx0ZD4wLjAwODE5ODwvdGQ+CiAgICAgIDx0ZD4wLjAwNTUwMzwvdGQ+CiAgICAgIDx0ZD4wLjAwMzAyMzwvdGQ+CiAgICA8L3RyPgogIDwvdGJvZHk+CjwvdGFibGU+CjxwPjUzNjc1IHJvd3Mgw5cgNDU2IGNvbHVtbnM8L3A+CjwvZGl2Pg==\\\"},\\\"mime\\\":\\\"text/html\\\"},{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ICAgICAgICAgICAgICAgICAgICAgICAgICAgbyAgICAgICAgaCAgICAgICAgbCAgICAgICAgYyAgdm9sQ2N5ICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICA4MzA4LjUgICA4MzQxLjMgICA4Mjg5LjkgICA4MzM2LjcgICA3MTguMCAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgODMzNi43ICAgODM2OC41ICAgODMzNi43ICAgODM0OS45ICAgNzk2LjAgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgIDgzNTAuMCAgIDgzNTguNiAgIDgzNDAuMCAgIDgzNDYuOSAgIDQyMS4wICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICA4MzQ2LjkgICA4MzQ4LjAgICA4MzQwLjAgICA4MzQ1LjAgICAxNTQuMCAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgODM0NS4wICAgODM2My40ICAgODM0MS4xICAgODM0MS43ICAgNTc2LjAgICAKLi4uICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgIC4uLiAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgIDg3NDUyLjUgIDg3ODI3LjMgIDg3MzgzLjQgIDg3NzMzLjkgICAzMzguMCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICA4NzcyNS4yICA4NzkwMC4wICA4NzYzNy43ICA4Nzg3Mi42ICAgMTk1LjAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgODc4NzIuNyAgODc4ODEuOCAgODczNDIuOSAgODczNjEuNyAgIDIzMi4wICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgIDg3MzUzLjUgIDg3Mzk2LjcgIDg2NjI3LjkgIDg2Nzc2LjIgICA1NjcuMCAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICA4Njc3Mi4yICA4Njk5OS45ICA4NjU5NS44ICA4Njg3OS43ICAgMTk1LjAgICAKCiAgICAgICAgICAgICAgICAgICAgIHRpbWVfdG9fZXhwMV9ociAgdGltZV9lbGFwc2VkICBob3VyICBkYXlfb2Zfd2VlayAgXAoyMDE5LTEwLTEzIDAwOjAwOjAwICAgICAgICAgICAgICA3LjAgICAgICAgICAgMTcuMCAgICAgMSAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgICAgNi4wICAgICAgICAgIDE4LjAgICAgIDIgICAgICAgICAgICA2ICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgIDUuMCAgICAgICAgICAxOS4wICAgICAzICAgICAgICAgICAgNiAgIAoyMDE5LTEwLTEzIDAzOjAwOjAwICAgICAgICAgICAgICA0LjAgICAgICAgICAgMjAuMCAgICAgNCAgICAgICAgICAgIDYgICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgICAgMy4wICAgICAgICAgIDIxLjAgICAgIDUgICAgICAgICAgICA2ICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAgLi4uICAgICAgICAgIC4uLiAgIAoyMDI1LTExLTI2IDA2OjAwOjAwICAgICAgICAgICAgICAxLjAgICAgICAgICAgMjMuMCAgICAgNyAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgICAyNC4wICAgICAgICAgICAwLjAgICAgIDggICAgICAgICAgICAyICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMjMuMCAgICAgICAgICAgMS4wICAgICA5ICAgICAgICAgICAgMiAgIAoyMDI1LTExLTI2IDA5OjAwOjAwICAgICAgICAgICAgIDIyLjAgICAgICAgICAgIDIuMCAgICAxMCAgICAgICAgICAgIDIgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgICAyMS4wICAgICAgICAgICAzLjAgICAgMTEgICAgICAgICAgICAyICAgCgogICAgICAgICAgICAgICAgICAgICBpc193ZWVrZW5kICAuLi4gIHNrZXdfdm9sX2V4dHJlbWUgIGt1cnRvc2lzX3ZvbF9leHRyZW1lICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjM2MTgzMSAgICAgICAgICAgICAtMC4xNDEyNDIgICAKMjAxOS0xMC0xMyAwMTowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzI1MTIxICAgICAgICAgICAgIC0wLjIxMjA3MSAgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAxICAuLi4gICAgICAgICAtMC4zMjk5NjkgICAgICAgICAgICAgLTAuMjA1MTMxICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgIDEgIC4uLiAgICAgICAgIC0wLjMzMDAxNiAgICAgICAgICAgICAtMC4yMjUzMTggICAKMjAxOS0xMC0xMyAwNDowMDowMCAgICAgICAgICAgMSAgLi4uICAgICAgICAgLTAuMzY0ODAxICAgICAgICAgICAgIC0wLjIzMjIwMiAgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAuLi4gICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgICAwLjAwNTM5MiAgICAgICAgICAgICAtMS4zMjkxOTIgICAKMjAyNS0xMS0yNiAwNzowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgIDAuMDEzOTAzICAgICAgICAgICAgIC0xLjE0OTM5NSAgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAwICAuLi4gICAgICAgICAgMC4wMTQ1NzIgICAgICAgICAgICAgLTEuMTE1MjQyICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgIDAgIC4uLiAgICAgICAgIC0wLjA1NDc5NyAgICAgICAgICAgICAtMS4xMzk1NDQgICAKMjAyNS0xMS0yNiAxMDowMDowMCAgICAgICAgICAgMCAgLi4uICAgICAgICAgLTAuMTA4MDMzICAgICAgICAgICAgIC0wLjk4NTkyMyAgIAoKICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2Vfdm9sX2V4dHJlbWUgIHZvbF9zdXJwcmlzZV9jbHVzdGVyaW5nICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgIDAuMDE2ODE2ICAgICAgICAgICAgICAgIC0yLjgxNDgwMyAgIAoyMDE5LTEwLTEzIDAxOjAwOjAwICAgICAgICAgICAgICAwLjAxNTUyNCAgICAgICAgICAgICAgICAtMC4yMTUwMzUgICAKMjAxOS0xMC0xMyAwMjowMDowMCAgICAgICAgICAgICAgMC4wMTQ5NjUgICAgICAgICAgICAgICAgIDAuMTY5MjEwICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgIDAuMDE1MDQwICAgICAgICAgICAgICAgIC0xLjMyMjgwMiAgIAoyMDE5LTEwLTEzIDA0OjAwOjAwICAgICAgICAgICAgICAwLjAxNTE4OCAgICAgICAgICAgICAgICAtMy4xNzU4MjggICAKLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgIDAuMDMyMDkwICAgICAgICAgICAgICAgIC05LjMxNDU2OCAgIAoyMDI1LTExLTI2IDA3OjAwOjAwICAgICAgICAgICAgICAwLjAyODA2OCAgICAgICAgICAgICAgICAtMS45NzIwNDAgICAKMjAyNS0xMS0yNiAwODowMDowMCAgICAgICAgICAgICAgMC4wMjY5NzIgICAgICAgICAgICAgICAgLTYuMzE4NjkxICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgIDAuMDMwMTI2ICAgICAgICAgICAgICAgIC00Ljk4OTM3NiAgIAoyMDI1LTExLTI2IDEwOjAwOjAwICAgICAgICAgICAgICAwLjAzMzY0MyAgICAgICAgICAgICAgICAgNy4xMzAyNzIgICAKCiAgICAgICAgICAgICAgICAgICAgIHJlZ2ltZV9sYWJlbCAgbWF4X2Z3ZF96X3Njb3JlICBtYXhfanVtcF96X3Njb3JlICBcCjIwMTktMTAtMTMgMDA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjg3MDY3ICAgICAgICAgIDEuMzc0MTM0ICAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuOTAxNTE1ICAgICAgICAgIDEuODAzMDMwICAgCjIwMTktMTAtMTMgMDI6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzIwOTcyICAgICAgICAgIDEuNDQxOTQ1ICAgCjIwMTktMTAtMTMgMDM6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNjM4MzAwICAgICAgICAgIDEuMjc2NjAwICAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNzg4NDYyICAgICAgICAgIDEuNTc2OTIzICAgCi4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLiAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgLi4uICAgCjIwMjUtMTEtMjYgMDY6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMzkxMTY1ICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuNDY3MzczICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDg6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMjQ5NTAxICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMDk6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDkyNzIwICAgICAgICAgIDAuMDAwMDAwICAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgMCAgICAgICAgIDAuMDE3NDYxICAgICAgICAgIDAuMDAwMDAwICAgCgogICAgICAgICAgICAgICAgICAgICBib3hfc3RkX2Rlc2Vhc29uYWxpemVkICBib3hfc3RkX3JhdyAgc2Vhc29uYWxfdm9sICAKMjAxOS0xMC0xMyAwMDowMDowMCAgICAgICAgICAgICAgICAwLjAwNjcyOSAgICAgMC4wMDUxMzUgICAgICAwLjAwMzQzNyAgCjIwMTktMTAtMTMgMDE6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDU0ODcgICAgIDAuMDA1MTQ3ICAgICAgMC4wMDQyMjUgIAoyMDE5LTEwLTEzIDAyOjAwOjAwICAgICAgICAgICAgICAgIDAuMDA2NzU5ICAgICAwLjAwNTEzMiAgICAgIDAuMDAzNDIwICAKMjAxOS0xMC0xMyAwMzowMDowMCAgICAgICAgICAgICAgICAwLjAwNzU2MSAgICAgMC4wMDUxMTAgICAgICAwLjAwMzA0NCAgCjIwMTktMTAtMTMgMDQ6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYwMTkgICAgIDAuMDA1MTA3ICAgICAgMC4wMDM4MjIgIAouLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uICAgICAgICAgIC4uLiAgICAgICAgICAgLi4uICAKMjAyNS0xMS0yNiAwNjowMDowMCAgICAgICAgICAgICAgICAwLjAwNjgxNCAgICAgMC4wMDU1MTEgICAgICAwLjAwMzY0MyAgCjIwMjUtMTEtMjYgMDc6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDYzOTMgICAgIDAuMDA1NDgzICAgICAgMC4wMDM4NjMgIAoyMDI1LTExLTI2IDA4OjAwOjAwICAgICAgICAgICAgICAgIDAuMDA3MjA0ICAgICAwLjAwNTQ4MSAgICAgIDAuMDAzNDI3ICAKMjAyNS0xMS0yNiAwOTowMDowMCAgICAgICAgICAgICAgICAwLjAwNTY2OCAgICAgMC4wMDU0OTUgICAgICAwLjAwNDM2NyAgCjIwMjUtMTEtMjYgMTA6MDA6MDAgICAgICAgICAgICAgICAgMC4wMDgxOTggICAgIDAuMDA1NTAzICAgICAgMC4wMDMwMjMgIAoKWzUzNjc1IHJvd3MgeCA0NTYgY29sdW1uc10=\\\"},\\\"mime\\\":\\\"text/plain\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\\\\n# From analysis: 288 consecutive NaN rows at start, 0 at end\\\\n\\\\nrows_with_nans = combined_df.isna().any(axis=1)\\\\n\\\\n# Find first and last valid rows\\\\nvalid_rows = ~rows_with_nans\\\\nvalid_indices = combined_df[valid_rows].index\\\\n\\\\nif len(valid_indices) > 0:\\\\n    first_valid = valid_indices[0]\\\\n    last_valid = valid_indices[-1]\\\\n    \\\\n    # Count start and end NaNs\\\\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\\\\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\\\\n    \\\\n    print(f\\\\\\\"NaN Summary:\\\\\\\")\\\\n    print(f\\\\\\\"  First valid row: {first_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Last valid row: {last_valid}\\\\\\\")\\\\n    print(f\\\\\\\"  Start NaNs to drop: {start_nans}\\\\\\\")\\\\n    print(f\\\\\\\"  End NaNs to drop: {max(0, end_nans)}\\\\\\\")\\\\n    \\\\n    # Slice from first valid to last valid (inclusive)\\\\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\\\\n    \\\\n    # Check for middle NaNs (these are preserved for inspection)\\\\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nAfter trimming start/end:\\\\\\\")\\\\n    print(f\\\\\\\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\\\\\\\")\\\\n    print(f\\\\\\\"  Middle rows with NaNs: {middle_nans}\\\\\\\")\\\\n    \\\\n    if middle_nans > 0:\\\\n        print(f\\\\\\\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No valid rows found!\\\\\\\")\\\\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\\\\n\\\\ncombined_df_clean\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"e05fb42e\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"435b3c59-da57-49b1-afe9-99105b1a34d1\\\",\\\"runStartTime\\\":1764194138809,\\\"runEndTime\\\":1764194138938,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":12,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":1}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"18260009\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"32f6d188-de21-4613-90a5-b9f186ba6ac4\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpBbmFseXppbmcgTWlkZGxlIE5hTiBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpGZWF0dXJlcyB3aXRoIG1pZGRsZSBOYU5zOiAzCgpUb3AgMjAgZmVhdHVyZXMgYnkgTmFOIGNvdW50OgogIG1heF9md2Rfel9zY29yZSAgICAgICAgICAgICAgICAgICAgICAgICAgICA5NiBOYU5zICggMC4xOCUpCiAgbWF4X2p1bXBfel9zY29yZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDk2IE5hTnMgKCAwLjE4JSkKICB2b2xfcmF0aW9fMjRoXzE0NGggICAgICAgICAgICAgICAgICAgICAgICAgMjMgTmFOcyAoIDAuMDQlKQoKR3JvdXBlZCBieSBmZWF0dXJlIHR5cGU6CiAgbWF4ICAgICAgICAgICAgICAgICAgICAgMTkyIHRvdGFsIE5hTnMKICB2b2wgICAgICAgICAgICAgICAgICAgICAgMjMgdG90YWwgTmFOcwoKU3RvY2hhc3RpYyBmZWF0dXJlcyB3aXRoIE5hTnM6IDAKICDinJMgTm8gc3RvY2hhc3RpYyBOYU5zIC0gZml4IGlzIHdvcmtpbmchCgpEYXRlIHJhbmdlIG9mIG1pZGRsZSBOYU5zOgogIEZpcnN0OiAyMDIwLTAxLTA1IDE2OjAwOjAwCiAgTGFzdDogMjAyMC0wMS0wOSAxNjowMDowMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Analyze which features have the middle NaNs and verify stochastic fix\\\\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    print(\\\\\\\"Analyzing Middle NaN Features\\\\\\\")\\\\n    print(\\\\\\\"=\\\\\\\" * 70)\\\\n    \\\\n    # Get rows with NaNs\\\\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\\\\n    \\\\n    if rows_with_middle_nans.sum() > 0:\\\\n        # Count NaNs per feature\\\\n        middle_nan_counts = combined_df_clean.isna().sum()\\\\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\\\\n        \\\\n        print(f\\\\\\\"\\\\\\\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\\\\\\\")\\\\n        print(f\\\\\\\"\\\\\\\\nTop 20 features by NaN count:\\\\\\\")\\\\n        for feat, count in features_with_middle_nans.head(20).items():\\\\n            pct = (count / len(combined_df_clean)) * 100\\\\n            print(f\\\\\\\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\\\\\\\")\\\\n        \\\\n        # Group by prefix\\\\n        print(f\\\\\\\"\\\\\\\\nGrouped by feature type:\\\\\\\")\\\\n        feature_groups = {}\\\\n        for feat in features_with_middle_nans.index:\\\\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\\\\n            if prefix not in feature_groups:\\\\n                feature_groups[prefix] = 0\\\\n            feature_groups[prefix] += features_with_middle_nans[feat]\\\\n        \\\\n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\\\\n            print(f\\\\\\\"  {prefix:20s} {total_nans:6,} total NaNs\\\\\\\")\\\\n        \\\\n        # Check specifically for stochastic features\\\\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\\\\n        print(f\\\\\\\"\\\\\\\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\\\\\\\")\\\\n        if stoch_features_in_nans:\\\\n            print(\\\\\\\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\\\\\\\")\\\\n            for feat in stoch_features_in_nans:\\\\n                print(f\\\\\\\"    {feat}: {features_with_middle_nans[feat]} NaNs\\\\\\\")\\\\n        else:\\\\n            print(\\\\\\\"   No stochastic NaNs - fix is working!\\\\\\\")\\\\n        \\\\n        # Show date range of NaN occurrences\\\\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\\\\n        print(f\\\\\\\"\\\\\\\\nDate range of middle NaNs:\\\\\\\")\\\\n        print(f\\\\\\\"  First: {nan_dates[0]}\\\\\\\")\\\\n        print(f\\\\\\\"  Last: {nan_dates[-1]}\\\\\\\")\\\\n        \\\\n    else:\\\\n        print(\\\\\\\"\\\\\\\\n No middle NaNs found!\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"No data to analyze\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"fceab976\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"1d546c88-437b-4127-92bd-e53c6137dd61\\\",\\\"runStartTime\\\":1764192842004,\\\"runEndTime\\\":1764192842029,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":13,\\\"id\\\":\\\"69cb7d33\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"5ec664fd-d044-462a-94dc-15cf2a54bc70\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"Um93cyB3aXRoIE5hTnM6IDk3CgpGaXJzdCAxMCByb3dzIHdpdGggTmFOcyBhbmQgdGhlaXIgTmFOIGNvbHVtbnM6CiAgMjAyMC0wMS0wNSAxNjowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAxNzowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAxODowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAxOTowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAyMDowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAyMTowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAyMjowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNSAyMzowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNiAwMDowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCiAgMjAyMC0wMS0wNiAwMTowMDowMDogWydtYXhfZndkX3pfc2NvcmUnLCAnbWF4X2p1bXBfel9zY29yZSddCgpEZXRhaWxlZCB2aWV3IG9mIGZpcnN0IE5hTiByb3cgKDIwMjAtMDEtMDUgMTY6MDA6MDApOgogIHZvbF9yYXRpb18yNGhfMTQ0aCAgICAgICAgICAgICA9IDAuMAogIHZvbF9yYXRpb18yNGhfMjg4aCAgICAgICAgICAgICA9IDAuMAogIGxpcV92b2xfcmF0aW9fY2hhbmdlICAgICAgICAgICA9IDAuMAogIHJlZ2ltZV9sYWJlbCAgICAgICAgICAgICAgICAgICA9IDAuMAogIG1heF9md2Rfel9zY29yZSAgICAgICAgICAgICAgICA9IDxOQT4KICBtYXhfanVtcF96X3Njb3JlICAgICAgICAgICAgICAgPSA8TkE+Cg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Deep dive into exact NaN locations\\\\nnan_rows = combined_df_clean[combined_df_clean.isna().any(axis=1)]\\\\nprint(f\\\\\\\"Rows with NaNs: {len(nan_rows)}\\\\\\\")\\\\n\\\\n# For each row, show which columns have NaNs\\\\nprint(\\\\\\\"\\\\\\\\nFirst 10 rows with NaNs and their NaN columns:\\\\\\\")\\\\nfor idx in nan_rows.index[:10]:\\\\n    nan_cols = nan_rows.loc[idx][nan_rows.loc[idx].isna()].index.tolist()\\\\n    print(f\\\\\\\"  {idx}: {nan_cols}\\\\\\\")\\\\n\\\\n# Check a specific row more deeply\\\\nif len(nan_rows) > 0:\\\\n    first_nan_idx = nan_rows.index[0]\\\\n    print(f\\\\\\\"\\\\\\\\nDetailed view of first NaN row ({first_nan_idx}):\\\\\\\")\\\\n    row = combined_df_clean.loc[first_nan_idx]\\\\n    \\\\n    # Show all z_score and regime columns\\\\n    relevant_cols = [c for c in row.index if 'regime' in c or 'z_score' in c or 'vol_ratio' in c]\\\\n    for col in relevant_cols:\\\\n        val = row[col]\\\\n        print(f\\\\\\\"  {col:30s} = {val}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"554773bb\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"04ef578f-8ecb-44e9-8e8f-e2c0c3e90a11\\\",\\\"runStartTime\\\":1764194151776,\\\"runEndTime\\\":1764194151798,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":13,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":14,\\\"id\\\":\\\"2a5ea2cf\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"d8fd152f-875c-439b-9f7a-60ca555ef647\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"VGVzdCBkYXRhIHNoYXBlOiAoMTIxLCA1KQoKT0hMQyB2YWx1ZXMgZHVyaW5nIGZsYXQgcGVyaW9kOgo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]},{\\\"outputId\\\":\\\"fa16c35d-6f5a-4bdd-b0d4-1e472d990e19\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"error\\\",\\\"originalError\\\":{\\\"output_type\\\":\\\"error\\\",\\\"ename\\\":\\\"KeyError\\\",\\\"evalue\\\":\\\"\\\\\\\"None of [Index(['open', 'high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"traceback\\\":[\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\",\\\"\\\\u001b[31mKeyError\\\\u001b[39m                                  Traceback (most recent call last)\\\",\\\"\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[14]\\\\u001b[39m\\\\u001b[32m, line 12\\\\u001b[39m\\\\n\\\\u001b[32m     10\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mTest data shape: \\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mtest_data.shape\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m     11\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;130;01m\\\\\\\\n\\\\u001b[39;00m\\\\u001b[33mOHLC values during flat period:\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m---> \\\\u001b[39m\\\\u001b[32m12\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[43mtest_data\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mopen\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mhigh\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mlow\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mclose\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m]\\\\u001b[49m\\\\u001b[43m]\\\\u001b[49m.head(\\\\u001b[32m20\\\\u001b[39m))\\\\n\\\\u001b[32m     14\\\\u001b[39m \\\\u001b[38;5;66;03m# Check if OHLC are all equal\\\\u001b[39;00m\\\\n\\\\u001b[32m     15\\\\u001b[39m ohlc_equal = (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mopen\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m]) & \\\\\\\\\\\\n\\\\u001b[32m     16\\\\u001b[39m              (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m]) & \\\\\\\\\\\\n\\\\u001b[32m     17\\\\u001b[39m              (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mclose\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m])\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/frame.py:4119\\\\u001b[39m, in \\\\u001b[36mDataFrame.__getitem__\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m   4117\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m is_iterator(key):\\\\n\\\\u001b[32m   4118\\\\u001b[39m         key = \\\\u001b[38;5;28mlist\\\\u001b[39m(key)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m4119\\\\u001b[39m     indexer = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mcolumns\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_indexer_strict\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m\\\\\\\"\\\\u001b[39;49m\\\\u001b[33;43mcolumns\\\\u001b[39;49m\\\\u001b[33;43m\\\\\\\"\\\\u001b[39;49m\\\\u001b[43m)\\\\u001b[49m[\\\\u001b[32m1\\\\u001b[39m]\\\\n\\\\u001b[32m   4121\\\\u001b[39m \\\\u001b[38;5;66;03m# take() does not accept boolean indexers\\\\u001b[39;00m\\\\n\\\\u001b[32m   4122\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mgetattr\\\\u001b[39m(indexer, \\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mdtype\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m, \\\\u001b[38;5;28;01mNone\\\\u001b[39;00m) == \\\\u001b[38;5;28mbool\\\\u001b[39m:\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6212\\\\u001b[39m, in \\\\u001b[36mIndex._get_indexer_strict\\\\u001b[39m\\\\u001b[34m(self, key, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6209\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   6210\\\\u001b[39m     keyarr, indexer, new_indexer = \\\\u001b[38;5;28mself\\\\u001b[39m._reindex_non_unique(keyarr)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6212\\\\u001b[39m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_raise_if_missing\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkeyarr\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   6214\\\\u001b[39m keyarr = \\\\u001b[38;5;28mself\\\\u001b[39m.take(indexer)\\\\n\\\\u001b[32m   6215\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, Index):\\\\n\\\\u001b[32m   6216\\\\u001b[39m     \\\\u001b[38;5;66;03m# GH 42790 - Preserve name from an Index\\\\u001b[39;00m\\\\n\\\",\\\"\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6261\\\\u001b[39m, in \\\\u001b[36mIndex._raise_if_missing\\\\u001b[39m\\\\u001b[34m(self, key, indexer, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6259\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing:\\\\n\\\\u001b[32m   6260\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing == \\\\u001b[38;5;28mlen\\\\u001b[39m(indexer):\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6261\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mNone of [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mkey\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m] are in the [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00maxis_name\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m]\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m   6263\\\\u001b[39m     not_found = \\\\u001b[38;5;28mlist\\\\u001b[39m(ensure_index(key)[missing_mask.nonzero()[\\\\u001b[32m0\\\\u001b[39m]].unique())\\\\n\\\\u001b[32m   6264\\\\u001b[39m     \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mnot_found\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m not in index\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\",\\\"\\\\u001b[31mKeyError\\\\u001b[39m: \\\\\\\"None of [Index(['open', 'high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\"]}},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"ewoJIm5hbWUiOiAiS2V5RXJyb3IiLAoJIm1lc3NhZ2UiOiAiXCJOb25lIG9mIFtJbmRleChbJ29wZW4nLCAnaGlnaCcsICdsb3cnLCAnY2xvc2UnXSwgZHR5cGU9J29iamVjdCcpXSBhcmUgaW4gdGhlIFtjb2x1bW5zXVwiIiwKCSJzdGFjayI6ICJcdTAwMWJbMzFtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHUwMDFiWzM5bVxuXHUwMDFiWzMxbUtleUVycm9yXHUwMDFiWzM5bSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFjZWJhY2sgKG1vc3QgcmVjZW50IGNhbGwgbGFzdClcblx1MDAxYlszNm1DZWxsXHUwMDFiWzM5bVx1MDAxYlszNm0gXHUwMDFiWzM5bVx1MDAxYlszMm1JblsxNF1cdTAwMWJbMzltXHUwMDFiWzMybSwgbGluZSAxMlx1MDAxYlszOW1cblx1MDAxYlszMm0gICAgIDEwXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyOG1wcmludFx1MDAxYlszOW0oXHUwMDFiWzMzbWZcdTAwMWJbMzltXHUwMDFiWzMzbVwiXHUwMDFiWzM5bVx1MDAxYlszM21UZXN0IGRhdGEgc2hhcGU6IFx1MDAxYlszOW1cdTAwMWJbMzg7NTsxMzI7MDFte1x1MDAxYlszOTswMG10ZXN0X2RhdGEuc2hhcGVcdTAwMWJbMzg7NTsxMzI7MDFtfVx1MDAxYlszOTswMG1cdTAwMWJbMzNtXCJcdTAwMWJbMzltKVxuXHUwMDFiWzMybSAgICAgMTFcdTAwMWJbMzltIFx1MDAxYlszODs1OzI4bXByaW50XHUwMDFiWzM5bShcdTAwMWJbMzNtZlx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltXHUwMDFiWzM4OzU7MTMwOzAxbVxcblx1MDAxYlszOTswMG1cdTAwMWJbMzNtT0hMQyB2YWx1ZXMgZHVyaW5nIGZsYXQgcGVyaW9kOlx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltKVxuXHUwMDFiWzMybS0tLT4gXHUwMDFiWzM5bVx1MDAxYlszMm0xMlx1MDAxYlszOW0gXHUwMDFiWzM4OzU7MjhtcHJpbnRcdTAwMWJbMzltKFx1MDAxYls0M210ZXN0X2RhdGFcdTAwMWJbNDltXHUwMDFiWzQzbVtcdTAwMWJbNDltXHUwMDFiWzQzbVtcdTAwMWJbNDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbW9wZW5cdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbWhpZ2hcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSxcdTAwMWJbNDltXHUwMDFiWzQzbSBcdTAwMWJbNDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbWxvd1x1MDAxYlszOTs0OW1cdTAwMWJbMzM7NDNtJ1x1MDAxYlszOTs0OW1cdTAwMWJbNDNtLFx1MDAxYls0OW1cdTAwMWJbNDNtIFx1MDAxYls0OW1cdTAwMWJbMzM7NDNtJ1x1MDAxYlszOTs0OW1cdTAwMWJbMzM7NDNtY2xvc2VcdTAwMWJbMzk7NDltXHUwMDFiWzMzOzQzbSdcdTAwMWJbMzk7NDltXHUwMDFiWzQzbV1cdTAwMWJbNDltXHUwMDFiWzQzbV1cdTAwMWJbNDltLmhlYWQoXHUwMDFiWzMybTIwXHUwMDFiWzM5bSkpXG5cdTAwMWJbMzJtICAgICAxNFx1MDAxYlszOW0gXHUwMDFiWzM4OzU7NjY7MDNtIyBDaGVjayBpZiBPSExDIGFyZSBhbGwgZXF1YWxcdTAwMWJbMzk7MDBtXG5cdTAwMWJbMzJtICAgICAxNVx1MDAxYlszOW0gb2hsY19lcXVhbCA9ICh0ZXN0X2RhdGFbXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbW9wZW5cdTAwMWJbMzltXHUwMDFiWzMzbSdcdTAwMWJbMzltXSA9PSB0ZXN0X2RhdGFbXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbWhpZ2hcdTAwMWJbMzltXHUwMDFiWzMzbSdcdTAwMWJbMzltXSkgJiBcXFxuXHUwMDFiWzMybSAgICAgMTZcdTAwMWJbMzltICAgICAgICAgICAgICAodGVzdF9kYXRhW1x1MDAxYlszM20nXHUwMDFiWzM5bVx1MDAxYlszM21oaWdoXHUwMDFiWzM5bVx1MDAxYlszM20nXHUwMDFiWzM5bV0gPT0gdGVzdF9kYXRhW1x1MDAxYlszM20nXHUwMDFiWzM5bVx1MDAxYlszM21sb3dcdTAwMWJbMzltXHUwMDFiWzMzbSdcdTAwMWJbMzltXSkgJiBcXFxuXHUwMDFiWzMybSAgICAgMTdcdTAwMWJbMzltICAgICAgICAgICAgICAodGVzdF9kYXRhW1x1MDAxYlszM20nXHUwMDFiWzM5bVx1MDAxYlszM21sb3dcdTAwMWJbMzltXHUwMDFiWzMzbSdcdTAwMWJbMzltXSA9PSB0ZXN0X2RhdGFbXHUwMDFiWzMzbSdcdTAwMWJbMzltXHUwMDFiWzMzbWNsb3NlXHUwMDFiWzM5bVx1MDAxYlszM20nXHUwMDFiWzM5bV0pXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvZnJhbWUucHk6NDExOVx1MDAxYlszOW0sIGluIFx1MDAxYlszNm1EYXRhRnJhbWUuX19nZXRpdGVtX19cdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXkpXHUwMDFiWzM5bVxuXHUwMDFiWzMybSAgIDQxMTdcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1pZlx1MDAxYlszOTswMG0gaXNfaXRlcmF0b3Ioa2V5KTpcblx1MDAxYlszMm0gICA0MTE4XHUwMDFiWzM5bSAgICAgICAgIGtleSA9IFx1MDAxYlszODs1OzI4bWxpc3RcdTAwMWJbMzltKGtleSlcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTQxMTlcdTAwMWJbMzltICAgICBpbmRleGVyID0gXHUwMDFiWzM4OzU7Mjg7NDNtc2VsZlx1MDAxYlszOTs0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtY29sdW1uc1x1MDAxYls0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtX2dldF9pbmRleGVyX3N0cmljdFx1MDAxYls0OW1cdTAwMWJbNDNtKFx1MDAxYls0OW1cdTAwMWJbNDNta2V5XHUwMDFiWzQ5bVx1MDAxYls0M20sXHUwMDFiWzQ5bVx1MDAxYls0M20gXHUwMDFiWzQ5bVx1MDAxYlszMzs0M21cIlx1MDAxYlszOTs0OW1cdTAwMWJbMzM7NDNtY29sdW1uc1x1MDAxYlszOTs0OW1cdTAwMWJbMzM7NDNtXCJcdTAwMWJbMzk7NDltXHUwMDFiWzQzbSlcdTAwMWJbNDltW1x1MDAxYlszMm0xXHUwMDFiWzM5bV1cblx1MDAxYlszMm0gICA0MTIxXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTs2NjswM20jIHRha2UoKSBkb2VzIG5vdCBhY2NlcHQgYm9vbGVhbiBpbmRleGVyc1x1MDAxYlszOTswMG1cblx1MDAxYlszMm0gICA0MTIyXHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1pZlx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7MjhtZ2V0YXR0clx1MDAxYlszOW0oaW5kZXhlciwgXHUwMDFiWzMzbVwiXHUwMDFiWzM5bVx1MDAxYlszM21kdHlwZVx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltLCBcdTAwMWJbMzg7NTsyODswMW1Ob25lXHUwMDFiWzM5OzAwbSkgPT0gXHUwMDFiWzM4OzU7MjhtYm9vbFx1MDAxYlszOW06XG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhlcy9iYXNlLnB5OjYyMTJcdTAwMWJbMzltLCBpbiBcdTAwMWJbMzZtSW5kZXguX2dldF9pbmRleGVyX3N0cmljdFx1MDAxYlszOW1cdTAwMWJbMzRtKHNlbGYsIGtleSwgYXhpc19uYW1lKVx1MDAxYlszOW1cblx1MDAxYlszMm0gICA2MjA5XHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1lbHNlXHUwMDFiWzM5OzAwbTpcblx1MDAxYlszMm0gICA2MjEwXHUwMDFiWzM5bSAgICAga2V5YXJyLCBpbmRleGVyLCBuZXdfaW5kZXhlciA9IFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLl9yZWluZGV4X25vbl91bmlxdWUoa2V5YXJyKVxuXHUwMDFiWzMybS0+IFx1MDAxYlszOW1cdTAwMWJbMzJtNjIxMlx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7NDNtc2VsZlx1MDAxYlszOTs0OW1cdTAwMWJbNDNtLlx1MDAxYls0OW1cdTAwMWJbNDNtX3JhaXNlX2lmX21pc3NpbmdcdTAwMWJbNDltXHUwMDFiWzQzbShcdTAwMWJbNDltXHUwMDFiWzQzbWtleWFyclx1MDAxYls0OW1cdTAwMWJbNDNtLFx1MDAxYls0OW1cdTAwMWJbNDNtIFx1MDAxYls0OW1cdTAwMWJbNDNtaW5kZXhlclx1MDAxYls0OW1cdTAwMWJbNDNtLFx1MDAxYls0OW1cdTAwMWJbNDNtIFx1MDAxYls0OW1cdTAwMWJbNDNtYXhpc19uYW1lXHUwMDFiWzQ5bVx1MDAxYls0M20pXHUwMDFiWzQ5bVxuXHUwMDFiWzMybSAgIDYyMTRcdTAwMWJbMzltIGtleWFyciA9IFx1MDAxYlszODs1OzI4bXNlbGZcdTAwMWJbMzltLnRha2UoaW5kZXhlcilcblx1MDAxYlszMm0gICA2MjE1XHUwMDFiWzM5bSBcdTAwMWJbMzg7NTsyODswMW1pZlx1MDAxYlszOTswMG0gXHUwMDFiWzM4OzU7MjhtaXNpbnN0YW5jZVx1MDAxYlszOW0oa2V5LCBJbmRleCk6XG5cdTAwMWJbMzJtICAgNjIxNlx1MDAxYlszOW0gICAgIFx1MDAxYlszODs1OzY2OzAzbSMgR0ggNDI3OTAgLSBQcmVzZXJ2ZSBuYW1lIGZyb20gYW4gSW5kZXhcdTAwMWJbMzk7MDBtXG5cblx1MDAxYlszNm1GaWxlIFx1MDAxYlszOW1cdTAwMWJbMzJtfi9zaGFyZWQvZWFzdFN5bmMvcHlFYXN0L3Byb192ZXJzaW9uLy52ZW52L2xpYi9weXRob24zLjEzL3NpdGUtcGFja2FnZXMvcGFuZGFzL2NvcmUvaW5kZXhlcy9iYXNlLnB5OjYyNjFcdTAwMWJbMzltLCBpbiBcdTAwMWJbMzZtSW5kZXguX3JhaXNlX2lmX21pc3NpbmdcdTAwMWJbMzltXHUwMDFiWzM0bShzZWxmLCBrZXksIGluZGV4ZXIsIGF4aXNfbmFtZSlcdTAwMWJbMzltXG5cdTAwMWJbMzJtICAgNjI1OVx1MDAxYlszOW0gXHUwMDFiWzM4OzU7Mjg7MDFtaWZcdTAwMWJbMzk7MDBtIG5taXNzaW5nOlxuXHUwMDFiWzMybSAgIDYyNjBcdTAwMWJbMzltICAgICBcdTAwMWJbMzg7NTsyODswMW1pZlx1MDAxYlszOTswMG0gbm1pc3NpbmcgPT0gXHUwMDFiWzM4OzU7MjhtbGVuXHUwMDFiWzM5bShpbmRleGVyKTpcblx1MDAxYlszMm0tPiBcdTAwMWJbMzltXHUwMDFiWzMybTYyNjFcdTAwMWJbMzltICAgICAgICAgXHUwMDFiWzM4OzU7Mjg7MDFtcmFpc2VcdTAwMWJbMzk7MDBtIFx1MDAxYlszODs1OzE2NzswMW1LZXlFcnJvclx1MDAxYlszOTswMG0oXHUwMDFiWzMzbWZcdTAwMWJbMzltXHUwMDFiWzMzbVwiXHUwMDFiWzM5bVx1MDAxYlszM21Ob25lIG9mIFtcdTAwMWJbMzltXHUwMDFiWzM4OzU7MTMyOzAxbXtcdTAwMWJbMzk7MDBta2V5XHUwMDFiWzM4OzU7MTMyOzAxbX1cdTAwMWJbMzk7MDBtXHUwMDFiWzMzbV0gYXJlIGluIHRoZSBbXHUwMDFiWzM5bVx1MDAxYlszODs1OzEzMjswMW17XHUwMDFiWzM5OzAwbWF4aXNfbmFtZVx1MDAxYlszODs1OzEzMjswMW19XHUwMDFiWzM5OzAwbVx1MDAxYlszM21dXHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW0pXG5cdTAwMWJbMzJtICAgNjI2M1x1MDAxYlszOW0gICAgIG5vdF9mb3VuZCA9IFx1MDAxYlszODs1OzI4bWxpc3RcdTAwMWJbMzltKGVuc3VyZV9pbmRleChrZXkpW21pc3NpbmdfbWFzay5ub256ZXJvKClbXHUwMDFiWzMybTBcdTAwMWJbMzltXV0udW5pcXVlKCkpXG5cdTAwMWJbMzJtICAgNjI2NFx1MDAxYlszOW0gICAgIFx1MDAxYlszODs1OzI4OzAxbXJhaXNlXHUwMDFiWzM5OzAwbSBcdTAwMWJbMzg7NTsxNjc7MDFtS2V5RXJyb3JcdTAwMWJbMzk7MDBtKFx1MDAxYlszM21mXHUwMDFiWzM5bVx1MDAxYlszM21cIlx1MDAxYlszOW1cdTAwMWJbMzg7NTsxMzI7MDFte1x1MDAxYlszOTswMG1ub3RfZm91bmRcdTAwMWJbMzg7NTsxMzI7MDFtfVx1MDAxYlszOTswMG1cdTAwMWJbMzNtIG5vdCBpbiBpbmRleFx1MDAxYlszOW1cdTAwMWJbMzNtXCJcdTAwMWJbMzltKVxuXG5cdTAwMWJbMzFtS2V5RXJyb3JcdTAwMWJbMzltOiBcIk5vbmUgb2YgW0luZGV4KFsnb3BlbicsICdoaWdoJywgJ2xvdycsICdjbG9zZSddLCBkdHlwZT0nb2JqZWN0JyldIGFyZSBpbiB0aGUgW2NvbHVtbnNdXCIiCn0=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.error\\\"}]}],\\\"source\\\":\\\"# Check what's happening with these rows - simulate the regime engineer logic\\\\nfrom targetEngineer import VolatilityRegimeEngineer\\\\n\\\\n# Get the raw history data for this period\\\\ntest_period_start = pd.Timestamp('2020-01-05 00:00:00')\\\\ntest_period_end = pd.Timestamp('2020-01-10 00:00:00')\\\\n\\\\nif 'history_slice' in globals():\\\\n    test_data = history_slice.loc[test_period_start:test_period_end]\\\\n    print(f\\\\\\\"Test data shape: {test_data.shape}\\\\\\\")\\\\n    print(f\\\\\\\"\\\\\\\\nOHLC values during flat period:\\\\\\\")\\\\n    print(test_data[['open', 'high', 'low', 'close']].head(20))\\\\n    \\\\n    # Check if OHLC are all equal\\\\n    ohlc_equal = (test_data['open'] == test_data['high']) & \\\\\\\\\\\\n                 (test_data['high'] == test_data['low']) & \\\\\\\\\\\\n                 (test_data['low'] == test_data['close'])\\\\n    print(f\\\\\\\"\\\\\\\\nRows where OHLC all equal: {ohlc_equal.sum()} / {len(test_data)}\\\\\\\")\\\\n    \\\\n    # Manually compute box_std for first NaN row\\\\n    first_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\\\\n    lookback_window = 24*3  # 3 days\\\\n    \\\\n    # Get lookback window\\\\n    idx_pos = history_slice.index.get_loc(first_nan_ts)\\\\n    lookback_start_pos = max(0, idx_pos - lookback_window)\\\\n    lookback_indices = history_slice.index[lookback_start_pos:idx_pos]\\\\n    \\\\n    print(f\\\\\\\"\\\\\\\\nLookback window for {first_nan_ts}:\\\\\\\")\\\\n    print(f\\\\\\\"  Indices: {len(lookback_indices)} (from {lookback_indices[0]} to {lookback_indices[-1]})\\\\\\\")\\\\n    \\\\n    # Compute Rogers-Satchell for this window\\\\n    lb_data = history_slice.loc[lookback_indices]\\\\n    term1 = np.log(lb_data['high'] / lb_data['close']) * np.log(lb_data['high'] / lb_data['open'])\\\\n    term2 = np.log(lb_data['low'] / lb_data['close']) * np.log(lb_data['low'] / lb_data['open'])\\\\n    sum_term = term1 + term2\\\\n    \\\\n    print(f\\\\\\\"  term1+term2 has NaNs: {sum_term.isna().sum()}\\\\\\\")\\\\n    print(f\\\\\\\"  term1+term2 min: {sum_term.min()}\\\\\\\")\\\\n    print(f\\\\\\\"  term1+term2 max: {sum_term.max()}\\\\\\\")\\\\n    \\\\n    raw_vol = np.sqrt(sum_term.mean())\\\\n    print(f\\\\\\\"  raw_vol: {raw_vol}\\\\\\\")\\\\n    print(f\\\\\\\"  raw_vol is NaN: {pd.isna(raw_vol)}\\\\\\\")\\\\n\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"8db25f03\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"179d4029-bd4f-4ab5-be38-dde646bf6957\\\",\\\"runStartTime\\\":1764194171779,\\\"runEndTime\\\":1764194172327,\\\"lastRunSuccess\\\":false,\\\"executionOrder\\\":14,\\\"error\\\":{\\\"name\\\":\\\"KeyError\\\",\\\"message\\\":\\\"\\\\\\\"None of [Index(['open', 'high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"stack\\\":\\\"\\\\u001b[31m---------------------------------------------------------------------------\\\\u001b[39m\\\\n\\\\u001b[31mKeyError\\\\u001b[39m                                  Traceback (most recent call last)\\\\n\\\\u001b[36mCell\\\\u001b[39m\\\\u001b[36m \\\\u001b[39m\\\\u001b[32mIn[14]\\\\u001b[39m\\\\u001b[32m, line 12\\\\u001b[39m\\\\n\\\\u001b[32m     10\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mTest data shape: \\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mtest_data.shape\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m     11\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;130;01m\\\\\\\\n\\\\u001b[39;00m\\\\u001b[33mOHLC values during flat period:\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m---> \\\\u001b[39m\\\\u001b[32m12\\\\u001b[39m \\\\u001b[38;5;28mprint\\\\u001b[39m(\\\\u001b[43mtest_data\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[43m[\\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mopen\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mhigh\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mlow\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[33;43mclose\\\\u001b[39;49m\\\\u001b[33;43m'\\\\u001b[39;49m\\\\u001b[43m]\\\\u001b[49m\\\\u001b[43m]\\\\u001b[49m.head(\\\\u001b[32m20\\\\u001b[39m))\\\\n\\\\u001b[32m     14\\\\u001b[39m \\\\u001b[38;5;66;03m# Check if OHLC are all equal\\\\u001b[39;00m\\\\n\\\\u001b[32m     15\\\\u001b[39m ohlc_equal = (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mopen\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m]) & \\\\\\\\\\\\n\\\\u001b[32m     16\\\\u001b[39m              (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mhigh\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m]) & \\\\\\\\\\\\n\\\\u001b[32m     17\\\\u001b[39m              (test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mlow\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m] == test_data[\\\\u001b[33m'\\\\u001b[39m\\\\u001b[33mclose\\\\u001b[39m\\\\u001b[33m'\\\\u001b[39m])\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/frame.py:4119\\\\u001b[39m, in \\\\u001b[36mDataFrame.__getitem__\\\\u001b[39m\\\\u001b[34m(self, key)\\\\u001b[39m\\\\n\\\\u001b[32m   4117\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m is_iterator(key):\\\\n\\\\u001b[32m   4118\\\\u001b[39m         key = \\\\u001b[38;5;28mlist\\\\u001b[39m(key)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m4119\\\\u001b[39m     indexer = \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43mcolumns\\\\u001b[49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_get_indexer_strict\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkey\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[33;43m\\\\\\\"\\\\u001b[39;49m\\\\u001b[33;43mcolumns\\\\u001b[39;49m\\\\u001b[33;43m\\\\\\\"\\\\u001b[39;49m\\\\u001b[43m)\\\\u001b[49m[\\\\u001b[32m1\\\\u001b[39m]\\\\n\\\\u001b[32m   4121\\\\u001b[39m \\\\u001b[38;5;66;03m# take() does not accept boolean indexers\\\\u001b[39;00m\\\\n\\\\u001b[32m   4122\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28mgetattr\\\\u001b[39m(indexer, \\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mdtype\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m, \\\\u001b[38;5;28;01mNone\\\\u001b[39;00m) == \\\\u001b[38;5;28mbool\\\\u001b[39m:\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6212\\\\u001b[39m, in \\\\u001b[36mIndex._get_indexer_strict\\\\u001b[39m\\\\u001b[34m(self, key, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6209\\\\u001b[39m \\\\u001b[38;5;28;01melse\\\\u001b[39;00m:\\\\n\\\\u001b[32m   6210\\\\u001b[39m     keyarr, indexer, new_indexer = \\\\u001b[38;5;28mself\\\\u001b[39m._reindex_non_unique(keyarr)\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6212\\\\u001b[39m \\\\u001b[38;5;28;43mself\\\\u001b[39;49m\\\\u001b[43m.\\\\u001b[49m\\\\u001b[43m_raise_if_missing\\\\u001b[49m\\\\u001b[43m(\\\\u001b[49m\\\\u001b[43mkeyarr\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43mindexer\\\\u001b[49m\\\\u001b[43m,\\\\u001b[49m\\\\u001b[43m \\\\u001b[49m\\\\u001b[43maxis_name\\\\u001b[49m\\\\u001b[43m)\\\\u001b[49m\\\\n\\\\u001b[32m   6214\\\\u001b[39m keyarr = \\\\u001b[38;5;28mself\\\\u001b[39m.take(indexer)\\\\n\\\\u001b[32m   6215\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m \\\\u001b[38;5;28misinstance\\\\u001b[39m(key, Index):\\\\n\\\\u001b[32m   6216\\\\u001b[39m     \\\\u001b[38;5;66;03m# GH 42790 - Preserve name from an Index\\\\u001b[39;00m\\\\n\\\\n\\\\u001b[36mFile \\\\u001b[39m\\\\u001b[32m~/shared/eastSync/pyEast/pro_version/.venv/lib/python3.13/site-packages/pandas/core/indexes/base.py:6261\\\\u001b[39m, in \\\\u001b[36mIndex._raise_if_missing\\\\u001b[39m\\\\u001b[34m(self, key, indexer, axis_name)\\\\u001b[39m\\\\n\\\\u001b[32m   6259\\\\u001b[39m \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing:\\\\n\\\\u001b[32m   6260\\\\u001b[39m     \\\\u001b[38;5;28;01mif\\\\u001b[39;00m nmissing == \\\\u001b[38;5;28mlen\\\\u001b[39m(indexer):\\\\n\\\\u001b[32m-> \\\\u001b[39m\\\\u001b[32m6261\\\\u001b[39m         \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[33mNone of [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mkey\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m] are in the [\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00maxis_name\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m]\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\u001b[32m   6263\\\\u001b[39m     not_found = \\\\u001b[38;5;28mlist\\\\u001b[39m(ensure_index(key)[missing_mask.nonzero()[\\\\u001b[32m0\\\\u001b[39m]].unique())\\\\n\\\\u001b[32m   6264\\\\u001b[39m     \\\\u001b[38;5;28;01mraise\\\\u001b[39;00m \\\\u001b[38;5;167;01mKeyError\\\\u001b[39;00m(\\\\u001b[33mf\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m\\\\u001b[38;5;132;01m{\\\\u001b[39;00mnot_found\\\\u001b[38;5;132;01m}\\\\u001b[39;00m\\\\u001b[33m not in index\\\\u001b[39m\\\\u001b[33m\\\\\\\"\\\\u001b[39m)\\\\n\\\\n\\\\u001b[31mKeyError\\\\u001b[39m: \\\\\\\"None of [Index(['open', 'high', 'low', 'close'], dtype='object')] are in the [columns]\\\\\\\"\\\",\\\"location\\\":{\\\"startLineNumber\\\":11,\\\"startColumn\\\":4,\\\"endLineNumber\\\":11,\\\"endColumn\\\":63},\\\"uri\\\":{\\\"$mid\\\":1,\\\"fsPath\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"external\\\":\\\"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X25sZmlsZQ%3D%3D\\\",\\\"path\\\":\\\"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb\\\",\\\"scheme\\\":\\\"vscode-notebook-cell\\\",\\\"fragment\\\":\\\"X25sZmlsZQ==\\\"}}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":10,\\\"id\\\":\\\"975b86cf\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"33be4f3f-4070-428a-a604-91d308292d75\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpJbnZlc3RpZ2F0aW5nIFJlZ2ltZSBMYWJlbCBOYU5zCj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KClRvdGFsIHJvd3Mgd2l0aCByZWdpbWVfbGFiZWwgTmFOOiA5NgpEYXRlIHJhbmdlOiAyMDIwLTAxLTA1IDE2OjAwOjAwIHRvIDIwMjAtMDEtMDkgMTU6MDA6MDAKCkZpcnN0IDEwIE5hTiB0aW1lc3RhbXBzOgogIDIwMjAtMDEtMDUgMTY6MDA6MDAKICAyMDIwLTAxLTA1IDE3OjAwOjAwCiAgMjAyMC0wMS0wNSAxODowMDowMAogIDIwMjAtMDEtMDUgMTk6MDA6MDAKICAyMDIwLTAxLTA1IDIwOjAwOjAwCiAgMjAyMC0wMS0wNSAyMTowMDowMAogIDIwMjAtMDEtMDUgMjI6MDA6MDAKICAyMDIwLTAxLTA1IDIzOjAwOjAwCiAgMjAyMC0wMS0wNiAwMDowMDowMAogIDIwMjAtMDEtMDYgMDE6MDA6MDAKCkNoZWNraW5nIHJhdyBkYXRhIGFyb3VuZCBOYU4gcGVyaW9kOgogIFJhdyBkYXRhIHJvd3MgaW4gdGhpcyBwZXJpb2Q6IDE0NAogIEV4cGVjdGVkIHJvd3MgKGhvdXJseSk6IDE0MwogIOKckyBObyB0aW1lIGdhcHMgZm91bmQKCkZlYXR1cmUgdmFsdWVzIGR1cmluZyBOYU4gcGVyaW9kIChmaXJzdCBOYU4gcm93KToKICB2b2xfcnNfMjRoOiBOL0EKICB2b2xfcnNfNzJoOiBOL0EKICB0cmVuZF9zdHJlbmd0aF8yNGg6IDAuMAogIGxvZ3JldF8yNGg6IDAuMAo=\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Investigate why regime_label has NaNs in Jan 2020\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Investigating Regime Label NaNs\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get the rows with regime NaNs\\\\nregime_nans = combined_df_clean['regime_label'].isna()\\\\nnan_rows = combined_df_clean[regime_nans]\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nTotal rows with regime_label NaN: {regime_nans.sum()}\\\\\\\")\\\\nprint(f\\\\\\\"Date range: {nan_rows.index[0]} to {nan_rows.index[-1]}\\\\\\\")\\\\n\\\\n# Check if this is a continuous block\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 10 NaN timestamps:\\\\\\\")\\\\nfor ts in nan_rows.index[:10]:\\\\n    print(f\\\\\\\"  {ts}\\\\\\\")\\\\n\\\\n# Check the raw data around this period\\\\nif 'raw_history' in globals():\\\\n    print(f\\\\\\\"\\\\\\\\nChecking raw data around NaN period:\\\\\\\")\\\\n    check_start = nan_rows.index[0] - pd.Timedelta(hours=24)\\\\n    check_end = nan_rows.index[-1] + pd.Timedelta(hours=24)\\\\n    \\\\n    raw_slice = raw_history.loc[check_start:check_end]\\\\n    print(f\\\\\\\"  Raw data rows in this period: {len(raw_slice)}\\\\\\\")\\\\n    print(f\\\\\\\"  Expected rows (hourly): {int((check_end - check_start).total_seconds() / 3600)}\\\\\\\")\\\\n    \\\\n    # Check for gaps\\\\n    if len(raw_slice) > 0:\\\\n        time_diffs = raw_slice.index.to_series().diff()\\\\n        gaps = time_diffs[time_diffs > pd.Timedelta(hours=1)]\\\\n        if len(gaps) > 0:\\\\n            print(f\\\\\\\"\\\\\\\\n   Found {len(gaps)} time gaps:\\\\\\\")\\\\n            for gap_time, gap_size in gaps.items():\\\\n                print(f\\\\\\\"    {gap_time}: {gap_size}\\\\\\\")\\\\n        else:\\\\n            print(f\\\\\\\"   No time gaps found\\\\\\\")\\\\n\\\\n# Check what features look like during this period\\\\nprint(f\\\\\\\"\\\\\\\\nFeature values during NaN period (first NaN row):\\\\\\\")\\\\nfirst_nan_row = combined_df_clean.loc[nan_rows.index[0]]\\\\nprint(f\\\\\\\"  vol_rs_24h: {first_nan_row.get('vol_rs_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  vol_rs_72h: {first_nan_row.get('vol_rs_72h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  trend_strength_24h: {first_nan_row.get('trend_strength_24h', 'N/A')}\\\\\\\")\\\\nprint(f\\\\\\\"  logret_24h: {first_nan_row.get('logret_24h', 'N/A')}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"a5e0731a\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"ca74f128-bd54-421a-8294-4612ff6dc990\\\",\\\"runStartTime\\\":1764186766749,\\\"runEndTime\\\":1764186766756,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":10,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":11,\\\"id\\\":\\\"d7da7604\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"d4406837-56f1-45e0-875a-35d5b077fee7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\",\\\"scrollable\\\":true},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQpDaGVja2luZyBBdmFpbGFibGUgVm9sYXRpbGl0eSBGZWF0dXJlcwo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgpUb3RhbCB2b2xhdGlsaXR5IGZlYXR1cmVzOiAxNDcKCkZpcnN0IDIwIHZvbCBmZWF0dXJlczoKICBhc3ltX3ZvbF92bG1faW1wYWN0CiAgY29tcHJlc3NlZF9yYW5nZV92b2wKICBjeWNsaWNhbF92b2xfY29tcHJlc3Npb24KICBkaXN0YW5jZV92b2xfZXh0cmVtZQogIGV4dHJlbWVfcmFuZ2Vfdm9sCiAga3VydG9zaXNfdm9sX2V4dHJlbWUKICBsaXFfdm9sCiAgbGlxX3ZvbF9yYXRpb19jaGFuZ2UKICBsb2dfdm9sXzEyaAogIGxvZ192b2xfMTQ0aAogIGxvZ192b2xfMjRoCiAgbG9nX3ZvbF8yODhoCiAgbG9nX3ZvbF8zaAogIGxvZ192b2xfNmgKICBsb2dfdm9sXzcyaAogIG1vbV92b2xfaW50ZXJhY3Rpb24KICBwcmV2X3NhdHVyZGF5X1Byb2dBY3RQX3hfdm9sMTJoCiAgcHJldl9zYXR1cmRheV9Qcm9nQWN0UF94X3ZvbDI0aAogIHByZXZfc2F0dXJkYXlfUHJvZ0FjdFBfeF92b2w2aAogIHByZXZfc2F0dXJkYXlfUHJvZ01heFBfeF92b2wxMmgKClJvZ2Vycy1TYXRjaGVsbCB2b2wgZmVhdHVyZXM6IDAKICDimqDvuI8gTk8gUm9nZXJzLVNhdGNoZWxsIHZvbGF0aWxpdHkgZmVhdHVyZXMgZm91bmQhCiAgVGhpcyBtZWFucyB0aGUgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIGNhbm5vdCBjb21wdXRlIHZvbGF0aWxpdHkuCgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CldoYXQgVm9sYXRpbGl0eVJlZ2ltZUVuZ2luZWVyIG5lZWRzOgo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ClRoZSByZWdpbWUgZW5naW5lZXIgY29tcHV0ZXMgUm9nZXJzLVNhdGNoZWxsIHZvbCBpbnRlcm5hbGx5IGZyb20gT0hMQwpJdCBkb2VzIE5PVCB1c2UgcHJlLWNvbXB1dGVkIHZvbF9ycyBmZWF0dXJlcyBmcm9tIGZlYXR1cmVFbmdpbmVlciEKCkJ1dCBpdCdzIHBhc3NlZCB0aGUgZmVhdHVyZXMgRGF0YUZyYW1lLCBhbmQgaXQgc2hvdWxkIGhhdmUgT0hMQyBjb2x1bW5zLi4uCgpPSExDIGNvbHVtbnMgaW4gZmVhdHVyZXM6IFtdCiAg4pqg77iPIE1JU1NJTkcgT0hMQyEgUmVnaW1lIGVuZ2luZWVyIG5lZWRzIGFsbCA0IE9ITEMgY29sdW1ucwogIE1pc3Npbmc6IFsnb3BlbicsICdoaWdoJywgJ2xvdycsICdjbG9zZSddCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"source\\\":\\\"# Check what volatility features actually exist\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"Checking Available Volatility Features\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\n\\\\n# Get all vol features\\\\nvol_features = [col for col in features.columns if 'vol' in col.lower()]\\\\nprint(f\\\\\\\"\\\\\\\\nTotal volatility features: {len(vol_features)}\\\\\\\")\\\\nprint(f\\\\\\\"\\\\\\\\nFirst 20 vol features:\\\\\\\")\\\\nfor feat in sorted(vol_features)[:20]:\\\\n    print(f\\\\\\\"  {feat}\\\\\\\")\\\\n\\\\n# Specifically look for Rogers-Satchell vol\\\\nrs_vol_features = [col for col in features.columns if 'vol_rs' in col]\\\\nprint(f\\\\\\\"\\\\\\\\nRogers-Satchell vol features: {len(rs_vol_features)}\\\\\\\")\\\\nif rs_vol_features:\\\\n    for feat in rs_vol_features:\\\\n        print(f\\\\\\\"  {feat}\\\\\\\")\\\\nelse:\\\\n    print(\\\\\\\"   NO Rogers-Satchell volatility features found!\\\\\\\")\\\\n    print(\\\\\\\"  This means the VolatilityRegimeEngineer cannot compute volatility.\\\\\\\")\\\\n    \\\\n# Check what the regime engineer expects\\\\nprint(f\\\\\\\"\\\\\\\\n\\\\\\\" + \\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"What VolatilityRegimeEngineer needs:\\\\\\\")\\\\nprint(\\\\\\\"=\\\\\\\" * 70)\\\\nprint(\\\\\\\"The regime engineer computes Rogers-Satchell vol internally from OHLC\\\\\\\")\\\\nprint(\\\\\\\"It does NOT use pre-computed vol_rs features from featureEngineer!\\\\\\\")\\\\nprint(\\\\\\\"\\\\\\\\nBut it's passed the features DataFrame, and it should have OHLC columns...\\\\\\\")\\\\n\\\\n# Check if features has OHLC\\\\nohlc_cols = ['open', 'high', 'low', 'close']\\\\nhas_ohlc = [col for col in ohlc_cols if col in features.columns]\\\\nprint(f\\\\\\\"\\\\\\\\nOHLC columns in features: {has_ohlc}\\\\\\\")\\\\nif len(has_ohlc) < 4:\\\\n    print(f\\\\\\\"   MISSING OHLC! Regime engineer needs all 4 OHLC columns\\\\\\\")\\\\n    print(f\\\\\\\"  Missing: {[c for c in ohlc_cols if c not in features.columns]}\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"eba3e393\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d4fccd2c-6cfa-49ea-8edc-87ca880eb6c6\\\",\\\"runStartTime\\\":1764186813314,\\\"runEndTime\\\":1764186813315,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":11,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":2}}},{\\\"cellKind\\\":2,\\\"language\\\":\\\"python\\\",\\\"metadata\\\":{\\\"execution_count\\\":8,\\\"id\\\":\\\"8948a1bd\\\",\\\"metadata\\\":{}},\\\"outputs\\\":[{\\\"outputId\\\":\\\"02e8ec0b-3b6f-441d-90a6-675f52319ac7\\\",\\\"metadata\\\":{\\\"outputType\\\":\\\"stream\\\"},\\\"outputs\\\":[{\\\"data\\\":{\\\"type\\\":\\\"ArrayBuffer-4f56482b-5a03-49ba-8356-210d3b0c1c3d\\\",\\\"data\\\":\\\"U3BsaXQgc2l6ZXM6CiAgVHJhaW46IDQyLDk0MCByb3dzICg4MC4wJSkKICBWYWw6ICAgNSwzNjcgcm93cyAoMTAuMCUpCiAgVGVzdDogIDUsMzY4IHJvd3MgKDEwLjAlKQoKWCBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA0NTApLCB2YWwgKDUzNjcsIDQ1MCksIHRlc3QgKDUzNjgsIDQ1MCkKeSBzaGFwZXMgLT4gdHJhaW4gKDQyOTQwLCA2KSwgdmFsICg1MzY3LCA2KSwgdGVzdCAoNTM2OCwgNikKCuKaoCBOYU5zIGZvdW5kOgogIFRyYWluOiAyMyBOYU5zCg==\\\"},\\\"mime\\\":\\\"application/vnd.code.notebook.stdout\\\"}]}],\\\"mime\\\":\\\"text/plain\\\",\\\"source\\\":\\\"# Split into train/val/test (80/10/10)\\\\nn_samples = len(combined_df_clean)\\\\ntrain_end = int(n_samples * 0.8)\\\\nval_end = train_end + int(n_samples * 0.1)\\\\n\\\\n# Get feature and target columns\\\\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\\\\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\\\\n\\\\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\\\\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\\\\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\\\\n\\\\ny_train = combined_df_clean[target_cols].iloc[:train_end]\\\\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\\\\ny_test = combined_df_clean[target_cols].iloc[val_end:]\\\\n\\\\nprint(f\\\\\\\"Split sizes:\\\\\\\")\\\\nprint(f\\\\\\\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\\\\\\\")\\\\nprint(f\\\\\\\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\\\\\\\")\\\\n\\\\nprint(f\\\\\\\"\\\\\\\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\\\\\\\")\\\\nprint(f\\\\\\\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\\\\\\\")\\\\n\\\\n# Final NaN check on all splits\\\\ntrain_nans = X_train.isna().sum().sum()\\\\nval_nans = X_val.isna().sum().sum()\\\\ntest_nans = X_test.isna().sum().sum()\\\\n\\\\nif train_nans + val_nans + test_nans == 0:\\\\n    print(\\\\\\\"\\\\\\\\n No NaNs in any split - ready for training!\\\\\\\")\\\\nelse:\\\\n    print(f\\\\\\\"\\\\\\\\n NaNs found:\\\\\\\")\\\\n    if train_nans > 0:\\\\n        print(f\\\\\\\"  Train: {train_nans} NaNs\\\\\\\")\\\\n    if val_nans > 0:\\\\n        print(f\\\\\\\"  Val: {val_nans} NaNs\\\\\\\")\\\\n    if test_nans > 0:\\\\n        print(f\\\\\\\"  Test: {test_nans} NaNs\\\\\\\")\\\",\\\"internalMetadata\\\":{\\\"internalId\\\":\\\"6017794d\\\",\\\"runStartTimeAdjustment\\\":0,\\\"executionId\\\":\\\"d6a62885-4d1d-40be-b86b-517d649e6240\\\",\\\"runStartTime\\\":1764186701691,\\\"runEndTime\\\":1764186701778,\\\"lastRunSuccess\\\":true,\\\"executionOrder\\\":8,\\\"renderDuration\\\":{\\\"vscode.builtin-renderer\\\":0}}}],\\\"metadata\\\":{\\\"metadata\\\":{\\\"kernelspec\\\":{\\\"display_name\\\":\\\".venv\\\",\\\"language\\\":\\\"python\\\",\\\"name\\\":\\\"python3\\\"},\\\"language_info\\\":{\\\"codemirror_mode\\\":{\\\"name\\\":\\\"ipython\\\",\\\"version\\\":3},\\\"file_extension\\\":\\\".py\\\",\\\"mimetype\\\":\\\"text/x-python\\\",\\\"name\\\":\\\"python\\\",\\\"nbconvert_exporter\\\":\\\"python\\\",\\\"pygments_lexer\\\":\\\"ipython3\\\",\\\"version\\\":\\\"3.13.7\\\"}},\\\"nbformat\\\":4,\\\"nbformat_minor\\\":5}}\"]","epoch":116,"telemetryInfo":{},"notebookViewType":"jupyter-notebook"}],["file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py::request_411ab292-5756-487f-8aa8-328dd69ca5e8",{"uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_411ab292-5756-487f-8aa8-328dd69ca5e8","content":"# targetEngineer.py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.base import BaseEstimator, TransformerMixin\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.exceptions import NotFittedError\n\nclass ExpirationTargetEngineer(BaseEstimator, TransformerMixin):\n    def __init__(self, expiration_hour: int = 8, targets_to_process=None):\n        self.targets_to_process = targets_to_process\n        self.expiration_hour = expiration_hour\n        self._feature_names_out = None\n        self._input_features = None\n\n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l', 'prev_close',]\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        self._input_features = X.columns\n        return self\n\n    def _get_expiration_timestamps(self, current_ts: pd.Timestamp) -> tuple[pd.Timestamp, pd.Timestamp]:\n        if current_ts.hour < self.expiration_hour:\n            exp1 = current_ts.normalize().replace(hour=self.expiration_hour)\n        else:\n            exp1 = (current_ts + pd.Timedelta(days=1)).normalize().replace(hour=self.expiration_hour)\n        exp2 = exp1 + pd.Timedelta(days=1)\n        return exp1, exp2\n\n    def _calculate_price_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        one_hour = pd.Timedelta(hours=1)\n        exp_map = {ts: self._get_expiration_timestamps(ts + one_hour) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        targets_df = pd.DataFrame(index=timestamps, dtype=float)\n        \n        for current_ts, row in X.iterrows():\n            try:\n                reference_price = row['prev_close']\n                if isinstance(reference_price, pd.Series):\n                    reference_price = reference_price.iloc[0]\n                if pd.isna(reference_price) or reference_price <= 1e-9: continue\n            except KeyError: continue\n    \n            exp1_ts = exp1_times.get(current_ts)\n            results = {}\n            if exp1_ts:\n                current_bar_end = current_ts + one_hour\n                if current_bar_end >= exp1_ts: continue\n                mask1 = (timestamps >= current_bar_end) & (timestamps < exp1_ts)\n                prices1_h = prices_h[mask1]\n                prices1_l = prices_l[mask1]\n                if not prices1_h.empty:\n                    results['max_p1'] = prices1_h.max()\n                    results['min_p1'] = prices1_l.min()\n                    results['exp1_max_ret'] = (prices1_h.max() / reference_price) - 1.0\n                    results['exp1_min_ret'] = (prices1_l.min() / reference_price) - 1.0\n                    \n                    max_idx = prices1_h.idxmax()\n                    min_idx = prices1_l.idxmin()\n                    window_length = (exp1_ts - current_bar_end).total_seconds() / 3600.0\n                    if window_length > 0:\n                        results['exp1_peak_frac'] = (max_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                        results['exp1_trough_frac'] = (min_idx - current_bar_end).total_seconds() / 3600.0 / window_length\n                    \n                    results['exp1_peak_hours_to_expiry'] = (exp1_ts - max_idx).total_seconds() / 3600.0\n                    results['exp1_trough_hours_to_expiry'] = (exp1_ts - min_idx).total_seconds() / 3600.0\n\n                    try:\n                        close_idx_arr = prices_c.index.get_indexer([exp1_ts], method='ffill')\n                        if close_idx_arr[0] != -1:\n                            close_idx = close_idx_arr[0]\n                            found_ts = prices_c.index[close_idx]\n                            if found_ts <= exp1_ts and found_ts >= current_ts:\n                                results['exp1_close_ret'] = (prices_c.iloc[close_idx] / reference_price) - 1.0\n                    except KeyError: pass\n                    for k, v in results.items(): targets_df.at[current_ts, k] = v\n        return targets_df\n\n    def _calculate_absolute_expiry_targets(self, X):\n        timestamps = X.index\n        prices_c = X['c']\n        prices_h = X['h']\n        prices_l = X['l']\n        exp_map = {ts: self._get_expiration_timestamps(ts) for ts in timestamps}\n        exp1_times = pd.Series({ts: exp[0] for ts, exp in exp_map.items()})\n        exp1_starts = exp1_times.shift(1, fill_value=exp1_times.iloc[0] - pd.Timedelta(days=1))\n        exp1_ends = exp1_times\n        abs_targets = pd.DataFrame(index=timestamps, dtype=float)\n\n        for exp_start, exp_end in sorted(set(zip(exp1_starts, exp1_ends))):\n            mask = (timestamps >= exp_start) & (timestamps < exp_end)\n            window_idx = timestamps[mask]\n            if len(window_idx) == 0: continue\n            \n            window_h = prices_h[mask]\n            window_l = prices_l[mask]\n            window_c = prices_c[mask]\n            \n            prev_idx = X.index.get_indexer([exp_start], method='ffill')[0] - 1\n            if prev_idx < 0: continue\n            window_prev_close = X.iloc[prev_idx]['c']\n            if pd.isna(window_prev_close) or window_prev_close <= 1e-9 or window_h.empty: continue\n\n            abs_max = window_h.max()\n            abs_min = window_l.min()\n            \n            # Exp1 Targets\n            abs_targets.loc[window_idx, 'abs_max_p1'] = abs_max\n            abs_targets.loc[window_idx, 'abs_min_p1'] = abs_min\n            abs_targets.loc[window_idx, 'abs_exp1_max_ret'] = (abs_max / window_prev_close) - 1.0\n            abs_targets.loc[window_idx, 'abs_exp1_min_ret'] = (abs_min / window_prev_close) - 1.0\n            \n            # Exp2 Targets\n            exp2_start = exp_end\n            exp2_end = exp2_start + pd.Timedelta(days=1)\n            mask2 = (timestamps >= exp2_start) & (timestamps < exp2_end)\n            window2_h = prices_h[mask2]\n            window2_l = prices_l[mask2]\n            \n            if not window2_h.empty:\n                abs_max_p2 = window2_h.max()\n                abs_min_p2 = window2_l.min()\n                abs_targets.loc[window_idx, 'abs_max_p2'] = abs_max_p2\n                abs_targets.loc[window_idx, 'abs_min_p2'] = abs_min_p2\n                abs_targets.loc[window_idx, 'abs_exp2_max_ret'] = (abs_max_p2 / window_prev_close) - 1.0\n                abs_targets.loc[window_idx, 'abs_exp2_min_ret'] = (abs_min_p2 / window_prev_close) - 1.0\n\n        return abs_targets\n\n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_input_features')\n        df = X.copy()\n        \n        # Engineered logrets\n        for i in [1, 3, 6, 12, 24]:\n            df[f'logret_up_{i}h'] = np.log(df['h'].shift(-i).rolling(window=i, min_periods=i).max() / df['c'])\n            df[f'logret_down_{i}h'] = np.log(df['l'].shift(-i).rolling(window=i, min_periods=i).min() / df['c'])\n        \n        safe_close = df['c'].replace(0, np.nan)\n        future_log_returns = np.log(safe_close.shift(-1) / safe_close)\n        df['next_24h_vol'] = future_log_returns.shift(-1).rolling(window=24, min_periods=18).std() * np.sqrt(24 * 365)\n\n        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n        \n        # Select engineered columns\n        eng_cols = [c for c in df.columns if 'logret_' in c or c == 'next_24h_vol']\n        df_targets = pd.concat([price_targets, abs_targets, df[eng_cols]], axis=1)\n    \n        self._feature_names_out = list(df_targets.columns)\n        if self.targets_to_process is not None:\n            df_targets = df_targets[[col for col in df_targets.columns if col in self.targets_to_process]]\n        return df_targets       \n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Classifies market regimes using deseasonalized volatility and path efficiency.\n    \"\"\"\n    def __init__(self, \n                 lookback_window: int = 24,\n                 seasonal_window: int = 720,\n                 forward_window: int = 24,\n                 trend_std: float = 1.2,\n                 jump_std: float = 1.6,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5,\n                 trend_min_efficiency: float = 0.25, # NEW\n                 trend_min_r2: float = 0.6           # NEW\n                 ):\n        self.lookback_window = lookback_window\n        self.seasonal_window = seasonal_window\n        self.forward_window = forward_window\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self.trend_min_efficiency = trend_min_efficiency\n        self.trend_min_r2 = trend_min_r2\n        \n        self._feature_names_out = None\n        self._seasonal_vol_lookup = None\n        self.global_vol_median = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            raise ValueError(f\"Missing cols: {required_cols}\")\n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Index must be DatetimeIndex\")\n            \n        self._seasonal_vol_lookup = self._build_seasonal_vol_lookup(X)\n        self.global_vol_median = self._seasonal_vol_lookup.median()\n        return self\n    \n    def _build_seasonal_vol_lookup(self, X: pd.DataFrame) -> pd.DataFrame:\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        rs_vol = np.sqrt((term1 + term2).clip(lower=0))\n        \n        vol_df = pd.DataFrame({'vol': rs_vol, 'h': X.index.hour, 'd': X.index.dayofweek}, index=X.index)\n        \n        seasonal_vol = vol_df.groupby(['h', 'd'])['vol'].rolling(\n            window=max(4, self.seasonal_window // 168), min_periods=4\n        ).median().reset_index(level=[0, 1], drop=True)\n        \n        lookup = vol_df.copy()\n        lookup['seasonal_vol'] = seasonal_vol\n        return lookup.groupby(['h', 'd'])['seasonal_vol'].last()\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n        df = pd.DataFrame(index=X.index)\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        raw_vol = np.sqrt(((term1 + term2).clip(lower=0)).rolling(\n            window=self.lookback_window, min_periods=int(self.lookback_window/2)).mean())\n        \n        time_keys = pd.Series(list(zip(X.index.hour, X.index.dayofweek)), index=X.index)\n        seasonal_vol_series = time_keys.map(self._seasonal_vol_lookup).fillna(self.global_vol_median)\n\n        deseasonalized_ratio = raw_vol / seasonal_vol_series.replace(0, np.nan)\n        adjusted_vol = deseasonalized_ratio * self.global_vol_median\n        \n        df['box_std'] = adjusted_vol\n        df['raw_vol'] = raw_vol\n        df['seasonal_vol'] = seasonal_vol_series\n        df['reference_price'] = safe_close\n        return df\n\n    def _assign_regime_labels(self, X: pd.DataFrame, box_df: pd.DataFrame) -> pd.DataFrame:\n        results = pd.DataFrame(index=X.index)\n        results['regime_label'] = pd.Series(dtype='Int64')\n        results['max_fwd_z_score'] = np.nan \n        results['max_jump_z_score'] = np.nan \n        \n        # Scale Jump threshold to be consistent with Daily units\n        time_scaling_factor = np.sqrt(self.forward_window / self.jump_speed_window)\n        REAL_JUMP_THRESHOLD = self.jump_std * time_scaling_factor\n        \n        safe_close = X['c'].replace(0, np.nan)\n        high = X['h']\n        low = X['l']\n        sqrt_fwd = np.sqrt(self.forward_window)\n        sqrt_jump = np.sqrt(self.jump_speed_window)\n        \n        # Pre-calc 1-period moves for Efficiency\n        abs_diffs = np.abs(np.log(safe_close / safe_close.shift(1)))\n        \n        for idx in X.index:\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            # If box_std is NaN or too small (flat period), assign chop (0) and continue\n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue\n            \n            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            if fwd_end_pos <= idx_pos + 1:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            if fwd_highs.empty:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue\n\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            final_close = X.iloc[fwd_end_pos-1]['c']\n            \n            ret_max = np.log(max_high / ref_price)\n            ret_min = np.log(min_low / ref_price)\n            max_abs_ret = max(abs(ret_max), abs(ret_min))\n            \n            fwd_z_score = max_abs_ret / (box_std * sqrt_fwd)\n            results.at[idx, 'max_fwd_z_score'] = fwd_z_score\n            \n            # Check JUMP\n            max_jump_z = 0.0\n            for i in range(len(fwd_indices) - self.jump_speed_window + 1):\n                sub_indices = fwd_indices[i : i + self.jump_speed_window]\n                s_high = high.loc[sub_indices].max()\n                s_low = low.loc[sub_indices].min()\n                s_ret = max(abs(np.log(s_high/ref_price)), abs(np.log(s_low/ref_price)))\n                current_z = s_ret / (box_std * sqrt_jump)\n                if current_z > max_jump_z: max_jump_z = current_z\n            results.at[idx, 'max_jump_z_score'] = max_jump_z\n\n            if max_jump_z > REAL_JUMP_THRESHOLD:\n                results.at[idx, 'regime_label'] = 2\n                continue\n            \n            # Check TREND with Hardening\n            if fwd_z_score > self.trend_std:\n                # 1. Efficiency\n                total_path = abs_diffs.loc[fwd_indices].sum()\n                net_move = abs(np.log(final_close / ref_price))\n                efficiency = net_move / total_path if total_path > 1e-9 else 0.0\n                \n                # 2. Linearity (R2)\n                fwd_prices = safe_close.loc[fwd_indices].values\n                if len(fwd_prices) > 2:\n                    corr = np.corrcoef(fwd_prices, np.arange(len(fwd_prices)))[0, 1]\n                    r2 = corr**2\n                else: r2 = 0.0\n                \n                if efficiency >= self.trend_min_efficiency and r2 >= self.trend_min_r2:\n                    # Retracement (Persistence)\n                    if ret_max > abs(ret_min): # Up\n                        if np.log(max_high / final_close) / ret_max <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                    else: # Down\n                        if np.log(final_close / min_low) / abs(ret_min) <= (1 - self.retracement_threshold):\n                            results.at[idx, 'regime_label'] = 1\n                \n                if not pd.isna(results.at[idx, 'regime_label']): continue\n            \n            results.at[idx, 'regime_label'] = 0\n            \n        return results\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        check_is_fitted(self, '_seasonal_vol_lookup')\n        box_df = self._calculate_lookback_box(X)\n        results = self._assign_regime_labels(X, box_df)\n        \n        output = results.copy()\n        output['box_std_deseasonalized'] = box_df['box_std']\n        output['box_std_raw'] = box_df['raw_vol']\n        output['seasonal_vol'] = box_df['seasonal_vol']\n        \n        self._feature_names_out = list(output.columns)\n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None: raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        transformed = self.transform(X)\n        regime_counts = transformed['regime_label'].value_counts().sort_index()\n        return regime_counts","epoch":133,"telemetryInfo":{}}]],"operations":[{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_be3612f3-7d33-4e8e-bf97-d400707bbafa","epoch":4,"edits":[{"text":"    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n\n\nclass VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Creates volatility regime labels for classification:\n    0 = Normal/Mean Reverting\n    1 = Trending\n    2 = Jump Risk\n    \n    Parameters\n    ----------\n    lookback_window : int, default=24\n        Hours to look back for regime calculation\n    \n    forward_window : int, default=12\n        Hours to look forward for regime labeling\n        \n    vol_percentile : float, default=75\n        Percentile threshold for high volatility (jump risk)\n        \n    trend_threshold : float, default=0.6\n        Threshold for directional consistency to identify trends\n        \n    jump_threshold_std : float, default=2.5\n        Standard deviation threshold for identifying jumps\n    \"\"\"\n    \n    def __init__(self, \n                 lookback_window: int = 24,\n                 forward_window: int = 12,\n                 vol_percentile: float = 75,\n                 trend_threshold: float = 0.6,\n                 jump_threshold_std: float = 2.5):\n        self.lookback_window = lookback_window\n        self.forward_window = forward_window\n        self.vol_percentile = vol_percentile\n        self.trend_threshold = trend_threshold\n        self.jump_threshold_std = jump_threshold_std\n        self._feature_names_out = None\n        self._vol_threshold = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Calculates volatility thresholds from training data.\"\"\"\n        required_cols = ['c', 'h', 'l', 'o']\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        \n        # Calculate realized volatility to set threshold\n        safe_close = X['c'].replace(0, np.nan)\n        log_returns = np.log(safe_close / safe_close.shift(1))\n        realized_vol = log_returns.rolling(window=self.lookback_window, min_periods=int(self.lookback_window*0.75)).std()\n        realized_vol_annualized = realized_vol * np.sqrt(24 * 365)\n        \n        # Store the percentile threshold for jump detection\n        self._vol_threshold = np.nanpercentile(realized_vol_annualized.dropna(), self.vol_percentile)\n        \n        return self\n    \n    def _calculate_regime_features(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Calculate features used for regime classification.\"\"\"\n        df = X.copy()\n        safe_close = df['c'].replace(0, np.nan)\n        \n        # 1. Realized volatility (annualized)\n        log_returns = np.log(safe_close / safe_close.shift(1))\n        realized_vol = log_returns.rolling(window=self.lookback_window, \n                                          min_periods=int(self.lookback_window*0.75)).std()\n        df['realized_vol'] = realized_vol * np.sqrt(24 * 365)\n        \n        # 2. High-Low range as % of close (volatility proxy)\n        df['hl_range_pct'] = ((df['h'] - df['l']) / df['c']) * 100\n        \n        # 3. Directional consistency (trend indicator)\n        # Positive if upward trend, negative if downward\n        returns = log_returns.rolling(window=self.lookback_window, \n                                      min_periods=int(self.lookback_window*0.75)).apply(\n            lambda x: (x > 0).sum() / len(x) if len(x) > 0 else np.nan\n        )\n        df['directional_consistency'] = returns\n        \n        # 4. Gap detection (for jump risk)\n        # Gap between close and next open\n        df['gap_size'] = np.abs(np.log(df['o'] / safe_close.shift(1)))\n        \n        # 5. Intrabar range expansion (jump indicator)\n        # Compare current bar range to recent average\n        avg_range = df['hl_range_pct'].rolling(window=self.lookback_window, \n                                               min_periods=int(self.lookback_window*0.75)).mean()\n        df['range_expansion'] = df['hl_range_pct'] / avg_range\n        \n        # 6. Mean reversion indicator\n        # Distance from moving average as % of std dev\n        ma = safe_close.rolling(window=self.lookback_window, \n                               min_periods=int(self.lookback_window*0.75)).mean()\n        std = safe_close.rolling(window=self.lookback_window, \n                                min_periods=int(self.lookback_window*0.75)).std()\n        df['zscore'] = (safe_close - ma) / std\n        \n        # 7. Return to mean measure (for forward window)\n        # How much price reverts after reaching extremes\n        df['max_deviation_fwd'] = df['h'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.75)).max()\n        df['min_deviation_fwd'] = df['l'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.75)).min()\n        \n        return df\n    \n    def _assign_regime_labels(self, df: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Assign regime labels based on forward-looking characteristics.\n        \n        Returns\n        -------\n        pd.Series with regime labels: 0=Normal/Mean Reverting, 1=Trending, 2=Jump Risk\n        \"\"\"\n        labels = pd.Series(index=df.index, dtype='Int64')\n        \n        # Calculate forward-looking metrics for labeling\n        safe_close = df['c'].replace(0, np.nan)\n        \n        # Forward returns and volatility\n        fwd_returns = np.log(safe_close.shift(-self.forward_window) / safe_close)\n        fwd_high = df['h'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).max()\n        fwd_low = df['l'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).min()\n        \n        # Forward realized volatility\n        fwd_vol = np.log(safe_close.shift(-1) / safe_close).shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).std() * np.sqrt(24 * 365)\n        \n        # Forward range expansion\n        fwd_range_pct = ((fwd_high - fwd_low) / safe_close) * 100\n        \n        # Forward directional consistency\n        fwd_direction = np.log(safe_close.shift(-1) / safe_close).shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=int(self.forward_window*0.5)).apply(\n            lambda x: np.abs((x > 0).sum() / len(x) - 0.5) if len(x) > 0 else np.nan\n        )\n        \n        # Mean reversion measure: does price return to starting level?\n        fwd_close = safe_close.shift(-self.forward_window)\n        price_reversion = np.abs(np.log(fwd_close / safe_close))\n        \n        # Check for large jumps in forward window\n        fwd_gaps = df['gap_size'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=1).max()\n        fwd_range_expansion = df['range_expansion'].shift(-self.forward_window).rolling(\n            window=self.forward_window, min_periods=1).max()\n        \n        # REGIME CLASSIFICATION LOGIC\n        for idx in df.index:\n            if pd.isna(fwd_vol.loc[idx]) or pd.isna(fwd_direction.loc[idx]):\n                labels.loc[idx] = pd.NA\n                continue\n            \n            # JUMP RISK (Priority 1): High volatility or large gaps/range expansion\n            if (fwd_vol.loc[idx] > self._vol_threshold or \n                fwd_gaps.loc[idx] > self.jump_threshold_std * df['gap_size'].std() or\n                fwd_range_expansion.loc[idx] > self.jump_threshold_std):\n                labels.loc[idx] = 2\n                \n            # TRENDING (Priority 2): Strong directional consistency\n            elif fwd_direction.loc[idx] > self.trend_threshold:\n                labels.loc[idx] = 1\n                \n            # NORMAL/MEAN REVERTING (Default): Lower volatility with reversion\n            else:\n                labels.loc[idx] = 0\n        \n        return labels\n    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Generate regime labels and supporting features.\n        \n        Returns\n        -------\n        pd.DataFrame with regime label and intermediate features\n        \"\"\"\n        check_is_fitted(self, '_vol_threshold')\n        \n        # Calculate regime features\n        df_features = self._calculate_regime_features(X)\n        \n        # Assign regime labels\n        regime_labels = self._assign_regime_labels(df_features)\n        \n        # Create output dataframe\n        output = pd.DataFrame(index=X.index)\n        output['regime_label'] = regime_labels\n        \n        # Add useful features for model training\n        output['regime_realized_vol'] = df_features['realized_vol']\n        output['regime_hl_range_pct'] = df_features['hl_range_pct']\n        output['regime_directional_consistency'] = df_features['directional_consistency']\n        output['regime_gap_size'] = df_features['gap_size']\n        output['regime_range_expansion'] = df_features['range_expansion']\n        output['regime_zscore'] = df_features['zscore']\n        \n        self._feature_names_out = list(output.columns)\n        \n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Get the distribution of regimes in the dataset.\n        \n        Returns\n        -------\n        pd.Series with counts for each regime\n        \"\"\"\n        transformed = self.transform(X)\n        return transformed['regime_label'].value_counts().sort_index()","range":{"startLineNumber":286,"startColumn":1,"endLineNumber":289,"endColumn":49}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","epoch":9,"edits":[{"text":"class VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Creates volatility regime labels for classification based on \"Box\" framework:\n    \n    Class 0: Mean Reversion/Chop (The \"Pin\")\n        - Price stays within 1 box during forward window\n        \n    Class 1: Trending (The \"Drift\") \n        - Price breaks 1.5 barrier AND stays near extremes (minimal retracement)\n        \n    Class 2: Jump/Event (The \"Shock\")\n        - Price exceeds 3 threshold within a short sub-window (fast move)\n    \n    Parameters\n    ----------\n    lookback_window : int, default=24\n        Hours to look back for calculating the \"Box\" (standard deviation/ATR)\n    \n    forward_window : int, default=12\n        Hours to look forward for regime classification\n        \n    chop_std : float, default=1.0\n        Standard deviation threshold for mean reversion box (Class 0)\n        \n    trend_std : float, default=1.5\n        Standard deviation threshold for trend breakout (Class 1)\n        \n    jump_std : float, default=3.0\n        Standard deviation threshold for jump detection (Class 2)\n        \n    jump_speed_window : int, default=3\n        Sub-window (hours) to detect fast moves for jump classification\n        \n    retracement_threshold : float, default=0.5\n        Max retracement from extreme to still be considered trending\n        (0.5 = must stay at least 50% of the way to the barrier)\n    \"\"\"\n    \n    def __init__(self, \n                 lookback_window: int = 24,\n                 forward_window: int = 12,\n                 chop_std: float = 1.0,\n                 trend_std: float = 1.5,\n                 jump_std: float = 3.0,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5):\n        self.lookback_window = lookback_window\n        self.forward_window = forward_window\n        self.chop_std = chop_std\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self._feature_names_out = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Validates input.\"\"\"\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        \n        return self\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Calculate the \"Box\" based on lookback window.\n        Returns DataFrame with box_std (standard deviation) for each timestamp.\n        \"\"\"\n        df = pd.DataFrame(index=X.index)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        # Method 1: Use close-to-close log return standard deviation\n        log_returns = np.log(safe_close / safe_close.shift(1))\n        box_std = log_returns.rolling(\n            window=self.lookback_window, \n            min_periods=int(self.lookback_window*0.75)\n        ).std()\n        \n        # Method 2: Alternative - Use ATR (Average True Range) \n        # Uncomment if you prefer ATR-based box\n        # high = X['h']\n        # low = X['l']\n        # prev_close = safe_close.shift(1)\n        # tr1 = high - low\n        # tr2 = np.abs(high - prev_close)\n        # tr3 = np.abs(low - prev_close)\n        # true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)\n        # atr = true_range.rolling(window=self.lookback_window, min_periods=int(self.lookback_window*0.75)).mean()\n        # box_std = atr / safe_close  # Normalize ATR by price to get percentage\n        \n        df['box_std'] = box_std\n        df['reference_price'] = safe_close\n        \n        return df\n    \n    def _assign_regime_labels(self, X: pd.DataFrame, box_df: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Assign regime labels based on forward price action relative to the box.\n        \n        Returns\n        -------\n        pd.Series with regime labels: 0=Chop/Mean Reversion, 1=Trending, 2=Jump\n        \"\"\"\n        labels = pd.Series(index=X.index, dtype='Int64')\n        \n        safe_close = X['c'].replace(0, np.nan)\n        high = X['h']\n        low = X['l']\n        \n        for idx in X.index:\n            # Get current box parameters\n            if pd.isna(box_df.loc[idx, 'box_std']) or pd.isna(box_df.loc[idx, 'reference_price']):\n                labels.loc[idx] = pd.NA\n                continue\n                \n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            if box_std <= 0 or ref_price <= 0:\n                labels.loc[idx] = pd.NA\n                continue\n            \n            # Get forward window data\n            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            \n            if fwd_end_pos <= idx_pos + 1:\n                labels.loc[idx] = pd.NA\n                continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            fwd_closes = safe_close.loc[fwd_indices]\n            \n            if fwd_highs.empty or fwd_closes.empty:\n                labels.loc[idx] = pd.NA\n                continue\n            \n            # Calculate max/min returns in forward window\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            final_close = fwd_closes.iloc[-1]\n            \n            max_return = np.log(max_high / ref_price)\n            min_return = np.log(min_low / ref_price)\n            max_excursion = max(abs(max_return), abs(min_return))\n            \n            # === CLASS 2: JUMP (Priority 1) ===\n            # Check if price exceeded jump_std threshold within jump_speed_window\n            jump_detected = False\n            for i in range(len(fwd_indices) - self.jump_speed_window + 1):\n                sub_window_indices = fwd_indices[i:i+self.jump_speed_window]\n                sub_high = high.loc[sub_window_indices].max()\n                sub_low = low.loc[sub_window_indices].min()\n                \n                sub_max_return = np.log(sub_high / ref_price)\n                sub_min_return = np.log(sub_low / ref_price)\n                sub_max_excursion = max(abs(sub_max_return), abs(sub_min_return))\n                \n                if sub_max_excursion > self.jump_std * box_std:\n                    jump_detected = True\n                    break\n            \n            if jump_detected:\n                labels.loc[idx] = 2\n                continue\n            \n            # === CLASS 1: TRENDING (Priority 2) ===\n            # Price must break trend_std barrier AND stay near extremes\n            upper_barrier = self.trend_std * box_std\n            lower_barrier = -self.trend_std * box_std\n            \n            broke_upper = max_return > upper_barrier\n            broke_lower = min_return < lower_barrier\n            \n            if broke_upper or broke_lower:\n                # Check retracement: final close should be near the extreme\n                if broke_upper:\n                    # For uptrend: final close should be at least retracement_threshold of the way to max_high\n                    distance_to_max = np.log(max_high / final_close)\n                    max_move = max_return\n                    retracement_pct = distance_to_max / max_move if max_move > 0 else 1.0\n                    \n                    if retracement_pct <= (1 - self.retracement_threshold):\n                        labels.loc[idx] = 1\n                        continue\n                \n                if broke_lower:\n                    # For downtrend: final close should be at least retracement_threshold of the way to min_low\n                    distance_to_min = np.log(final_close / min_low)\n                    max_move = abs(min_return)\n                    retracement_pct = distance_to_min / max_move if max_move > 0 else 1.0\n                    \n                    if retracement_pct <= (1 - self.retracement_threshold):\n                        labels.loc[idx] = 1\n                        continue\n            \n            # === CLASS 0: MEAN REVERSION / CHOP (Default) ===\n            # Price stayed within chop_std box OR broke out but retraced\n            labels.loc[idx] = 0\n        \n        return labels","range":{"startLineNumber":292,"startColumn":1,"endLineNumber":464,"endColumn":22}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_0bab9381-e2c7-4c3a-b7ba-60edc61a49b7","epoch":11,"edits":[{"text":"    \n    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Generate regime labels.\n        \n        Returns\n        -------\n        pd.DataFrame with regime label and box parameters\n        \"\"\"\n        check_is_fitted(self, '_feature_names_out')\n        \n        # Calculate the lookback box (standard deviation)\n        box_df = self._calculate_lookback_box(X)\n        \n        # Assign regime labels based on forward price action\n        regime_labels = self._assign_regime_labels(X, box_df)\n        \n        # Create output dataframe\n        output = pd.DataFrame(index=X.index)\n        output['regime_label'] = regime_labels\n        output['box_std'] = box_df['box_std']\n        output['box_std_annualized'] = box_df['box_std'] * np.sqrt(24 * 365)\n        \n        self._feature_names_out = list(output.columns)\n        \n        return output\n    \n    def get_feature_names_out(self, input_features=None):\n        if self._feature_names_out is None:\n            raise NotFittedError(\"Call 'transform' first.\")\n        return np.array(self._feature_names_out)\n    \n    def get_regime_distribution(self, X: pd.DataFrame) -> pd.Series:\n        \"\"\"\n        Get the distribution of regimes in the dataset.\n        \n        Returns\n        -------\n        pd.Series with counts for each regime\n        \"\"\"\n        transformed = self.transform(X)\n        regime_counts = transformed['regime_label'].value_counts().sort_index()\n        \n        # Add labels for clarity\n        regime_names = {\n            0: 'Class 0: Chop/Mean Reversion',\n            1: 'Class 1: Trending',\n            2: 'Class 2: Jump/Event'\n        }\n        regime_counts.index = regime_counts.index.map(lambda x: regime_names.get(x, f'Class {x}'))\n        \n        return regime_counts","range":{"startLineNumber":499,"startColumn":1,"endLineNumber":546,"endColumn":71}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","epoch":15,"edits":[{"text":"            if \"parkinson\" in self.vol_types_to_calc:\n                # Parkinson volatility: range-based estimator using only H/L\n                # Formula:  = [(1/(4*ln(2))) * mean((ln(H/L)))] * (trading_periods)\n                # More efficient than close-to-close, captures intraday volatility\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                safe_low = low_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    hl_ratio = high_shifted / safe_low\n                    log_hl = np.log(hl_ratio.replace([0, np.inf, -np.inf], np.nan))\n                    log_hl_sq = log_hl ** 2\n                \n                min_p = max(3, w // 4)\n                # Parkinson coefficient: 1/(4*ln(2))  0.3607\n                parkinson_coef = 1.0 / (4.0 * np.log(2.0))\n                mean_log_hl_sq = log_hl_sq.rolling(w, min_periods=min_p).mean()\n                vol_parkinson = np.sqrt(parkinson_coef * mean_log_hl_sq) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_parkinson_{w}h\"] = vol_parkinson.fillna(0)\n            if \"rogers_satchell\" in self.vol_types_to_calc:\n                # Rogers-Satchell volatility: drift-independent OHLC estimator\n                # Formula:  = [mean(ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O))] * (trading_periods)\n                # Superior to Parkinson as it incorporates open/close (drift info)\n                high_shifted = df[\"h\"].shift(1)\n                low_shifted = df[\"l\"].shift(1)\n                close_shifted = df[\"c\"].shift(1)\n                open_shifted = df[\"o\"].shift(1) if \"o\" in df.columns else close_shifted\n                \n                safe_close = close_shifted.replace(0, np.nan).clip(lower=1e-9)\n                safe_open = open_shifted.replace(0, np.nan).clip(lower=1e-9)\n                \n                with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                    log_hc = np.log(high_shifted / safe_close)\n                    log_ho = np.log(high_shifted / safe_open)\n                    log_lc = np.log(low_shifted / safe_close)\n                    log_lo = np.log(low_shifted / safe_open)\n                    \n                    # Rogers-Satchell formula\n                    rs_component = (log_hc * log_ho) + (log_lc * log_lo)\n                    rs_component = rs_component.replace([np.inf, -np.inf], np.nan)\n                \n                min_p = max(3, w // 4)\n                mean_rs = rs_component.rolling(w, min_periods=min_p).mean()\n                # Ensure non-negative before sqrt (numerical stability)\n                vol_rs = np.sqrt(mean_rs.clip(lower=0)) * np.sqrt(self.vol_trading_periods)\n                vol_df[f\"vol_rs_{w}h\"] = vol_rs.fillna(0)","range":{"startLineNumber":388,"startColumn":1,"endLineNumber":406,"endColumn":72}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","epoch":17,"edits":[{"text":"    def _trend_features(self, df: pd.DataFrame) -> pd.DataFrame:\n        trend_df = pd.DataFrame(index=df.index)\n        closes = df[\"c\"].shift(1)\n        \n        # Calculate trend strength features (backward z-scores)\n        # How big was the move over the last N hours relative to volatility?\n        safe_close = closes.replace(0, np.nan)\n        \n        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n\n            close_w_ago = df[\"c\"].shift(w + 1).replace(0, np.nan)\n            \n            # Standard momentum (returns)\n            momentum = ((closes / close_w_ago) - 1).fillna(0)\n            trend_df[f\"momentum_{w}h\"] = momentum\n            trend_df[f\"momentum_signed_sqrt_{w}h\"] = np.sign(momentum) * np.sqrt(np.abs(momentum))\n            \n            # Trend strength: backward return / volatility (z-score of move)\n            # This normalizes the move by historical volatility\n            backward_return = np.log(safe_close / close_w_ago)\n            \n            # Use realized volatility as the denominator\n            # Get log returns for volatility calculation\n            prev_close_lag = safe_close.shift(1).replace(0, np.nan)\n            with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n                log_ret = np.log(safe_close / prev_close_lag)\n            log_ret = log_ret.replace([np.inf, -np.inf], np.nan).fillna(0)\n            \n            # Rolling std (annualized volatility)\n            box_std = log_ret.rolling(w, min_periods=min_p).std()\n            \n            # Per-period std for the window length (de-annualize for the period)\n            box_std_period = box_std * np.sqrt(w)  # Adjust for window length\n            \n            # Trend strength = realized move / expected move\n            # This gives you \"how many sigmas was this move?\"\n            trend_strength = backward_return / box_std_period.replace(0, np.nan)\n            trend_df[f\"trend_strength_{w}h\"] = trend_strength.fillna(0)\n\n        try:\n            macd = ta.trend.MACD(df[\"c\"].shift(1), window_slow=26, window_fast=12, window_sign=9, fillna=True)\n            trend_df[\"macd\"] = macd.macd()\n            trend_df[\"macd_signal\"] = macd.macd_signal()\n            trend_df[\"macd_hist\"] = macd.macd_diff()\n\n            adx = ta.trend.ADXIndicator(df[\"h\"].shift(1), df[\"l\"].shift(1), df[\"c\"].shift(1), window=14, fillna=True)\n            trend_df[\"adx\"] = adx.adx()\n            trend_df[\"adx_pos\"] = adx.adx_pos()\n            trend_df[\"adx_neg\"] = adx.adx_neg()\n        except Exception:\n            for col in [\"macd\", \"macd_signal\", \"macd_hist\", \"adx\", \"adx_pos\", \"adx_neg\"]:\n                trend_df[col] = np.nan\n\n        return trend_df","range":{"startLineNumber":337,"startColumn":1,"endLineNumber":365,"endColumn":24}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_d7699234-21c0-49d5-8d4d-c7776a74afdc","epoch":19,"edits":[{"text":"    def __init__(self,\n                 expiration_hour: int = 8,\n                 vol_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vlm_window_sizes: Iterable[int] = (3, 6, 12, 24, 48, 72, 24 * 3, 24 * 7, 24 * 14, 24 * 30, 24 * 90),\n                 vol_types_to_calc: Iterable[str] = (\"raw\", \"gkyz\", \"parkinson\", \"rogers_satchell\", \"skew\", \"kurtosis\", \"vol_zscore\", \"log_vol\"),  ## remember to manage based on rocket or catboost\n                 vol_trading_periods: int = 24 * 365,","range":{"startLineNumber":990,"startColumn":1,"endLineNumber":995,"endColumn":54}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","epoch":24,"edits":[{"text":"class VolatilityRegimeEngineer(BaseEstimator, TransformerMixin):\n    \"\"\"\n    Classifies market regimes using deseasonalized volatility normalization.\n    \n    Deseasonalization: Instead of using raw rolling volatility, we calculate \n    the \"typical\" volatility for each (hour, day_of_week) combination and normalize \n    by that. This accounts for weekend vs weekday structural differences.\n    \n    Z-Score Formula: \n        Z = LogReturn / (Deseasonalized_Vol * Sqrt(Time_Window_Hours))\n        \n    Parameters\n    ----------\n    lookback_window : int, default=168\n        Hours to look back for calculating seasonal volatility patterns (default 1 week)\n    \n    seasonal_window : int, default=720\n        Hours of history to use for learning seasonal volatility patterns (default 30 days)\n    \n    forward_window : int, default=12\n        Hours to look forward for regime classification\n        \n    trend_std : float, default=1.5\n        Z-Score threshold for Trend breakout\n        \n    jump_std : float, default=3.5\n        Z-Score threshold for Jump detection\n        \n    jump_speed_window : int, default=3\n        Sub-window (hours) to detect fast shock moves\n        \n    retracement_threshold : float, default=0.5\n        Max retracement from extreme to still qualify as trending\n    \"\"\"\n    \n    def __init__(self, \n                 lookback_window: int = 168,\n                 seasonal_window: int = 720,\n                 forward_window: int = 12,\n                 trend_std: float = 1.5,\n                 jump_std: float = 3.5,\n                 jump_speed_window: int = 3,\n                 retracement_threshold: float = 0.5):\n        self.lookback_window = lookback_window\n        self.seasonal_window = seasonal_window\n        self.forward_window = forward_window\n        self.trend_std = trend_std\n        self.jump_std = jump_std\n        self.jump_speed_window = jump_speed_window\n        self.retracement_threshold = retracement_threshold\n        self._feature_names_out = None\n        self._seasonal_vol_lookup = None\n        \n    def fit(self, X: pd.DataFrame, y=None):\n        \"\"\"Fit method. Learns seasonal volatility patterns.\"\"\"\n        required_cols = ['c', 'h', 'l']\n        if not all(col in X.columns for col in required_cols):\n            missing = [col for col in required_cols if col not in X.columns]\n            raise ValueError(f\"Missing required columns: {missing}\")\n            \n        if not isinstance(X.index, pd.DatetimeIndex):\n            raise TypeError(\"Input DataFrame must have a DatetimeIndex.\")\n        \n        # Learn seasonal volatility patterns\n        self._seasonal_vol_lookup = self._build_seasonal_vol_lookup(X)\n        \n        return self\n    \n    def _build_seasonal_vol_lookup(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Build lookup table of typical volatility for each (hour, day_of_week).\n        Uses Rogers-Satchell volatility estimator.\n        \"\"\"\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        # Rogers-Satchell per-bar variance\n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        rs_variance = (term1 + term2).clip(lower=0)\n        rs_vol = np.sqrt(rs_variance)\n        \n        # Create DataFrame with time features\n        vol_df = pd.DataFrame({\n            'vol': rs_vol,\n            'hour': X.index.hour,\n            'day_of_week': X.index.dayofweek\n        }, index=X.index)\n        \n        # Calculate rolling median volatility for each (hour, day_of_week) group\n        # Use median for robustness to outliers\n        seasonal_vol = vol_df.groupby(['hour', 'day_of_week'])['vol'].rolling(\n            window=self.seasonal_window // 168,  # Number of weeks\n            min_periods=max(4, self.seasonal_window // 336)  # At least 4 observations\n        ).median().reset_index(level=[0, 1], drop=True)\n        \n        # Create lookup table: for each (hour, day_of_week), store typical vol\n        lookup = vol_df.copy()\n        lookup['seasonal_vol'] = seasonal_vol\n        \n        # Group by (hour, day_of_week) and take the last observed seasonal_vol\n        # This gives us the most recent estimate for each time bucket\n        seasonal_lookup = lookup.groupby(['hour', 'day_of_week'])['seasonal_vol'].last()\n        \n        return seasonal_lookup\n    \n    def _calculate_lookback_box(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Calculate deseasonalized volatility box.\n        \n        Returns both:\n        - box_std: The deseasonalized volatility (normalized by seasonal pattern)\n        - raw_vol: The raw Rogers-Satchell volatility\n        \"\"\"\n        df = pd.DataFrame(index=X.index)\n        \n        # Calculate raw Rogers-Satchell volatility\n        safe_open = X['o'].replace(0, np.nan) if 'o' in X.columns else X['c'].replace(0, np.nan)\n        safe_high = X['h'].replace(0, np.nan)\n        safe_low = X['l'].replace(0, np.nan)\n        safe_close = X['c'].replace(0, np.nan)\n        \n        term1 = np.log(safe_high / safe_close) * np.log(safe_high / safe_open)\n        term2 = np.log(safe_low / safe_close) * np.log(safe_low / safe_open)\n        rs_variance = (term1 + term2).clip(lower=0)\n        \n        # Rolling variance\n        rolling_variance = rs_variance.rolling(\n            window=self.lookback_window,\n            min_periods=int(self.lookback_window * 0.5)\n        ).mean()\n        \n        raw_vol = np.sqrt(rolling_variance)\n        \n        # Get seasonal adjustment factor for each timestamp\n        hour = X.index.hour\n        day_of_week = X.index.dayofweek\n        \n        seasonal_vol = pd.Series(index=X.index, dtype=float)\n        for idx in X.index:\n            key = (idx.hour, idx.dayofweek)\n            if key in self._seasonal_vol_lookup.index:\n                seasonal_vol.loc[idx] = self._seasonal_vol_lookup.loc[key]\n            else:\n                # Fallback: use overall median if this hour/day combo wasn't seen\n                seasonal_vol.loc[idx] = self._seasonal_vol_lookup.median()\n        \n        # Deseasonalize: divide raw vol by seasonal pattern\n        # This normalizes volatility relative to \"what's normal for this time\"\n        seasonal_vol_safe = seasonal_vol.replace(0, np.nan).fillna(seasonal_vol.median())\n        deseasonalized_vol = raw_vol / seasonal_vol_safe\n        \n        df['box_std'] = deseasonalized_vol\n        df['raw_vol'] = raw_vol\n        df['seasonal_vol'] = seasonal_vol\n        df['reference_price'] = safe_close\n        \n        return df","range":{"startLineNumber":298,"startColumn":1,"endLineNumber":394,"endColumn":22}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_b1fbccd8-2d8c-462c-9dc7-0ac387c10e5d","epoch":26,"edits":[{"text":"    def transform(self, X: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"Generate regime labels using deseasonalized volatility.\"\"\"\n        check_is_fitted(self, '_seasonal_vol_lookup')\n        \n        box_df = self._calculate_lookback_box(X)\n        results = self._assign_regime_labels(X, box_df)\n        \n        # Merge results with volatility metrics\n        output = results.copy()\n        output['box_std_deseasonalized'] = box_df['box_std']\n        output['box_std_raw'] = box_df['raw_vol']\n        output['seasonal_vol'] = box_df['seasonal_vol']\n        \n        self._feature_names_out = list(output.columns)\n        return output","range":{"startLineNumber":572,"startColumn":1,"endLineNumber":583,"endColumn":22}}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb#W5sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","scheme":"vscode-notebook-cell","fragment":"W5sZmlsZQ=="},"requestId":"request_bddfb2ab-dc09-4ed4-8c50-3bba87d11d28","epoch":29,"edits":[{"text":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# Pick a random 1-month period (720 hours)\ntotal_rows = len(targets)\nif total_rows > 720:\n    start_idx = np.random.randint(0, total_rows - 720)\n    end_idx = start_idx + 720\nelse:\n    start_idx = 0\n    end_idx = total_rows\n\n# Slice data for the period\nperiod_data = features.iloc[start_idx:end_idx].copy()\nperiod_targets = targets.iloc[start_idx:end_idx].copy()\n\n# Get price and regime\nprice = period_data['c'] if 'c' in period_data.columns else period_data.index.to_series()\nregime = period_targets['regime_label']\n\n# Create figure with 2 subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)\n\n# Plot 1: Price with regime background colors\nax1.plot(price.index, price.values, color='black', linewidth=1.5, label='Close Price')\nax1.set_ylabel('Price', fontsize=12)\nax1.set_title(f'Price and Volatility Regimes\\n{price.index[0]} to {price.index[-1]}', fontsize=14)\nax1.grid(True, alpha=0.3)\nax1.legend(loc='upper left')\n\n# Add colored background for regimes\nregime_colors = {0: 'lightgreen', 1: 'lightyellow', 2: 'lightcoral'}\nregime_labels = {0: 'Chop/Mean Reversion', 1: 'Trending', 2: 'Jump/Event'}\n\ny_min, y_max = ax1.get_ylim()\ncurrent_regime = None\nstart_x = None\n\nfor i, (idx, reg) in enumerate(regime.items()):\n    if pd.notna(reg):\n        reg = int(reg)\n        if reg != current_regime:\n            # End previous regime block\n            if current_regime is not None and start_x is not None:\n                ax1.axvspan(start_x, idx, alpha=0.2, color=regime_colors.get(current_regime, 'white'))\n            # Start new regime block\n            current_regime = reg\n            start_x = idx\n            \n# Fill last regime block\nif current_regime is not None and start_x is not None:\n    ax1.axvspan(start_x, regime.index[-1], alpha=0.2, color=regime_colors.get(current_regime, 'white'))\n\n# Plot 2: Regime as colored bars\nregime_numeric = regime.fillna(-1)\ncolors = [regime_colors.get(int(r), 'gray') if r >= 0 else 'gray' for r in regime_numeric]\n\nax2.bar(regime.index, [1]*len(regime), color=colors, width=0.04, edgecolor='none')\nax2.set_ylabel('Regime', fontsize=12)\nax2.set_yticks([0.5])\nax2.set_yticklabels([''])\nax2.set_ylim(0, 1)\nax2.grid(True, alpha=0.3, axis='x')\n\n# Add legend for regimes\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor=regime_colors[0], label='0: Chop/Mean Reversion'),\n                   Patch(facecolor=regime_colors[1], label='1: Trending'),\n                   Patch(facecolor=regime_colors[2], label='2: Jump/Event')]\nax2.legend(handles=legend_elements, loc='upper right', ncol=3)\n\nplt.xlabel('Time', fontsize=12)\nplt.tight_layout()\nplt.show()\n\n# Print some stats for this period\nprint(f\"\\nPeriod: {price.index[0]} to {price.index[-1]}\")\nprint(f\"Regime distribution:\")\nregime_counts = regime.value_counts().sort_index()\nfor reg, count in regime_counts.items():\n    if pd.notna(reg):\n        reg_int = int(reg)\n        pct = count / len(regime) * 100\n        print(f\"  Class {reg_int} ({regime_labels.get(reg_int, 'Unknown')}): {count} hours ({pct:.1f}%)\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":1,"endColumn":1}}],"cellIndex":5},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb#W5sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","scheme":"vscode-notebook-cell","fragment":"W5sZmlsZQ=="},"requestId":"request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2","epoch":32,"edits":[{"text":"import matplotlib.pyplot as plt\nimport numpy as np\n\n# Pick a random 1-month period (720 hours)\ntotal_rows = len(targets)\nif total_rows > 720:\n    start_idx = np.random.randint(0, total_rows - 720)\n    end_idx = start_idx + 720\nelse:\n    start_idx = 0\n    end_idx = total_rows\n\n# Slice data for the period\nperiod_data = features.iloc[start_idx:end_idx].copy()\nperiod_targets = targets.iloc[start_idx:end_idx].copy()\n\n# Get price and regime\nprice = period_data['c'] if 'c' in period_data.columns else period_data.index.to_series()\nregime = period_targets['regime_label']\n\n# Create figure with 2 subplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 8), sharex=True)\n\n# Plot 1: Price with regime background colors\nax1.plot(price.index, price.values, color='black', linewidth=1.5, label='Close Price')\nax1.set_ylabel('Price', fontsize=12)\nax1.set_title(f'Price and Volatility Regimes\\n{price.index[0]} to {price.index[-1]}', fontsize=14)\nax1.grid(True, alpha=0.3)\nax1.legend(loc='upper left')\n\n# Add colored background for regimes\nregime_colors = {0: 'lightgreen', 1: 'lightblue', 2: 'lightcoral'}\nregime_labels = {0: 'Chop/Mean Reversion', 1: 'Trending', 2: 'Jump/Event'}\n\ny_min, y_max = ax1.get_ylim()\ncurrent_regime = None\nstart_x = None\n\nfor i, (idx, reg) in enumerate(regime.items()):\n    if pd.notna(reg):\n        reg = int(reg)\n        if reg != current_regime:\n            # End previous regime block\n            if current_regime is not None and start_x is not None:\n                ax1.axvspan(start_x, idx, alpha=0.2, color=regime_colors.get(current_regime, 'white'))\n            # Start new regime block\n            current_regime = reg\n            start_x = idx\n            \n# Fill last regime block\nif current_regime is not None and start_x is not None:\n    ax1.axvspan(start_x, regime.index[-1], alpha=0.2, color=regime_colors.get(current_regime, 'white'))\n\n# Plot 2: Regime as colored bars\nregime_numeric = regime.fillna(-1)\ncolors = [regime_colors.get(int(r), 'gray') if r >= 0 else 'gray' for r in regime_numeric]\n\nax2.bar(regime.index, [1]*len(regime), color=colors, width=0.04, edgecolor='none')\nax2.set_ylabel('Regime', fontsize=12)\nax2.set_yticks([0.5])\nax2.set_yticklabels([''])\nax2.set_ylim(0, 1)\nax2.grid(True, alpha=0.3, axis='x')\n\n# Add legend for regimes\nfrom matplotlib.patches import Patch\nlegend_elements = [Patch(facecolor=regime_colors[0], label='0: Chop/Mean Reversion'),\n                   Patch(facecolor=regime_colors[1], label='1: Trending'),\n                   Patch(facecolor=regime_colors[2], label='2: Jump/Event')]\nax2.legend(handles=legend_elements, loc='upper right', ncol=3)\n\nplt.xlabel('Time', fontsize=12)\nplt.tight_layout()\nplt.show()\n\n# Print some stats for this period\nprint(f\"\\nPeriod: {price.index[0]} to {price.index[-1]}\")\nprint(f\"Regime distribution:\")\nregime_counts = regime.value_counts().sort_index()\nfor reg, count in regime_counts.items():\n    if pd.notna(reg):\n        reg_int = int(reg)\n        pct = count / len(regime) * 100\n        print(f\"  Class {reg_int} ({regime_labels.get(reg_int, 'Unknown')}): {count} hours ({pct:.1f}%)\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":85,"endColumn":1}}],"cellIndex":5},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_49631ab7-9ad2-4700-9e9e-b32efabc7177","epoch":35,"cellEdits":[{"editType":1,"index":3,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Clean combined dataframe - drop first 6 months and last 11 rows\nmonths_to_drop = 6\ntail_rows_to_drop = 11\n\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\nprint(f\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\")\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\n\nif tail_rows_to_drop > 0:\n    print(f\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\")\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\n\nprint(f\"Rows after cleaning: {len(combined_df_clean)}\")\n\n# Split into train/val/test (80/10/10)\nn_samples = len(combined_df_clean)\ntrain_end = int(n_samples * 0.8)\nval_end = train_end + int(n_samples * 0.1)\n\n# Get feature and target columns\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\n\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\n\ny_train = combined_df_clean[target_cols].iloc[:train_end]\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\ny_test = combined_df_clean[target_cols].iloc[val_end:]\n\nprint(f\"X shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\")\nprint(f\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X11sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X11sZmlsZQ=="},"requestId":"request_49631ab7-9ad2-4700-9e9e-b32efabc7177","epoch":36,"edits":[{"text":"# Clean combined dataframe - drop first month and last 11 rows (minimal cleaning for small dataset)\nmonths_to_drop = 1  # Only 1 month for small dataset\ntail_rows_to_drop = 11\n\ncutoff = combined_df.index.min() + pd.DateOffset(months=months_to_drop)\nprint(f\"Removing data before {cutoff:%Y-%m-%d} (first {months_to_drop} months)\")\ncombined_df_clean = combined_df.loc[combined_df.index >= cutoff]\n\nif tail_rows_to_drop > 0:\n    print(f\"Dropping last {tail_rows_to_drop} rows to avoid trailing NaNs\")\n    combined_df_clean = combined_df_clean.iloc[:-tail_rows_to_drop]\n\nprint(f\"Rows after cleaning: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\")\n\n# Split into train/val/test (80/10/10)\nn_samples = len(combined_df_clean)\ntrain_end = int(n_samples * 0.8)\nval_end = train_end + int(n_samples * 0.1)\n\n# Get feature and target columns\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\n\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\n\ny_train = combined_df_clean[target_cols].iloc[:train_end]\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\ny_test = combined_df_clean[target_cols].iloc[val_end:]\n\nprint(f\"\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\")\nprint(f\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\")\n\n# Quick NaN check on training data\ntrain_nans = X_train.isna().sum()\nif train_nans.sum() > 0:\n    print(f\"\\n Training features with NaNs: {(train_nans > 0).sum()} columns\")\n    print(f\"  Max NaNs in any column: {train_nans.max()} ({train_nans.max()/len(X_train):.1%})\")\nelse:\n    print(\"\\n No NaNs in training features\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":34,"endColumn":1}}],"cellIndex":3},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_8896403a-6894-4396-a058-b17b1b1499e7","epoch":39,"edits":[{"text":"import pandas as pd\nfrom pathlib import Path\nfrom typing import Optional\nimport time\nfrom data_pipeline import load_data  # This just loads the data and cleans it\nfrom featureEngineer import FeatureEngineer\nfrom targetEngineer import ExpirationTargetEngineer\nfrom ML_setup import CONFIG\nfrom ML_general_tools import *\nfrom pathlib import Path\n\nprint(\"Imports and configuration ready\")\n\n# Build features, targets, and combined dataframe\nt0 = time.time()\nraw_history = load_data(CONFIG[\"data\"][\"path\"])\nprint(f\"Loaded raw data: {raw_history.shape} in {time.time()-t0:.2f}s\")\n\n# Use slice for faster testing (or use [:] for full data)\nhistory_slice = raw_history[-3000:]  # Last 3000 rows for faster testing\nprint(f\"Using slice: {history_slice.shape}\")\n\nfeature_params = dict(CONFIG[\"features\"][\"params\"])\nheavy_cache_cfg = CONFIG[\"features\"].get(\"heavy_cache\", {})\nheavy_cache_root = Path(heavy_cache_cfg.get(\"directory\", \"cache/heavy_features\"))\n\ncurrent_output_root_str = CONFIG[\"output\"][\"directory\"]\ncurrent_output_root_path = Path(current_output_root_str)\n\npaths = {\n    \"root\": current_output_root_path,\n    \"feature_selection\": current_output_root_path / CONFIG[\"output\"][\"subdirectories\"][\"features\"],\n    \"trained_models\": current_output_root_path / CONFIG[\"output\"][\"subdirectories\"][\"models\"],\n    \"hpt_studies\": current_output_root_path / CONFIG[\"output\"][\"subdirectories\"][\"hpt\"],\n    \"feature_cache\": current_output_root_path / CONFIG[\"output\"][\"subdirectories\"][\"cache\"]\n}\n\ncache_dir = heavy_cache_root\ncache_dir.mkdir(parents=True, exist_ok=True)\ncache_files = sorted(cache_dir.glob(\"heavy_features_v*.pkl\"))\ncache_ready = bool(cache_files)\nif cache_ready:\n    print(f\"Heavy cache ready: {cache_files[-1].name} (total {len(cache_files)}) in {cache_dir}\")\nelse:\n    print(f\"No heavy cache file found in {cache_dir}; initial fit will populate.\")\n\n## Feature Engineering\nfe = FeatureEngineer(verbose=True, **{k: v for k, v in feature_params.items() if k != \"verbose\"})\n\n## Cache usage\ncache_ready = bool(cache_files)  # Use actual cache status\n\nmanual_features = None\nif cache_ready and fe.heavy_cache.load():\n    print(\"\\n Using heavy cache (only prev_cycle features cached)\")\n    print(\"  Note: Rolling/stateless features still computed on-the-fly\")\n    t1 = time.time()\n    fe._heavy_payload = fe.heavy_cache.payload\n    reference = fe._prepare_reference_frame(history_slice)\n    fe._full_reference = reference\n    manual_features = fe._compute_all_features(reference, build_heavy=False)\n    fe.feature_names_out_ = manual_features.columns.tolist()\n    fe._reference_features = manual_features\n    print(f\"  Features computed in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\")\nelse:\n    print(\"\\n Heavy cache not available; running full fit (slower)\")\n    t1 = time.time()\n    verbose_flag = feature_params.pop(\"verbose\", False)\n    fe = FeatureEngineer(verbose=True, **feature_params)\n    fe.fit(history_slice)\n    manual_features = fe.transform(history_slice)\n    print(f\"  Full fit+transform in {time.time()-t1:.2f}s -> shape: {manual_features.shape}\")\n\nfeature_engineer = fe\nfeatures = manual_features.copy()\n\n## 2a. Volatility Regime Target Engineering ---\nfrom targetEngineer import VolatilityRegimeEngineer\n\nprint(\"\\n--- Building Volatility Regime Targets ---\")\nt2 = time.time()\n\nregime_engineer = VolatilityRegimeEngineer(\n    lookback_window=24*3,    # 3 days lookback for vol\n    seasonal_window=24*30,   # 30 days to learn patterns\n    forward_window=24,       # 24h classification\n    trend_std=1.2,           # 1.2 daily sigmas\n    jump_std=3.0,            # 3.0 daily sigmas\n    jump_speed_window=6,     # 6h window for jump detection\n)\n\nregime_engineer.fit(features)\ntargets = regime_engineer.transform(features)\nprint(f\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\")\n\n# Check distribution\ndist = regime_engineer.get_regime_distribution(features)\nprint(\"\\nRegime distribution:\")\nprint(dist)\n\n# Combine\ncombined_df = pd.concat([features, targets], axis=1)\nprint(f\"\\nCombined shape: {combined_df.shape}\")\nprint(f\"Total pipeline time: {time.time()-t0:.2f}s\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":114,"endColumn":1}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X12sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X12sZmlsZQ=="},"requestId":"request_b054dee5-2ef3-417c-a8ac-7d662a467283","epoch":42,"edits":[{"text":"import pickle\nfrom pathlib import Path\n\n# Define cache paths\ncache_root = paths[\"root\"]\ncache_root.mkdir(parents=True, exist_ok=True)\n\nfeature_cache = cache_root / \"features_cache.pkl\"\ntarget_cache = cache_root / \"targets_cache.pkl\"\ncombined_cache = cache_root / \"combined_cache.pkl\"\n\n# Option 1: Load from cache if exists\nFORCE_REBUILD = False  # Set to True to rebuild from scratch\n\nif not FORCE_REBUILD and feature_cache.exists() and target_cache.exists():\n    print(\"=\" * 60)\n    print(\"Loading cached features and targets...\")\n    t_load = time.time()\n    \n    with open(feature_cache, 'rb') as f:\n        features = pickle.load(f)\n    with open(target_cache, 'rb') as f:\n        targets = pickle.load(f)\n    with open(combined_cache, 'rb') as f:\n        combined_df = pickle.load(f)\n    \n    print(f\" Loaded from cache in {time.time()-t_load:.2f}s\")\n    print(f\"  Features: {features.shape}\")\n    print(f\"  Targets: {targets.shape}\")\n    print(f\"  Combined: {combined_df.shape}\")\n    print(f\"  Date range: {features.index[0]} to {features.index[-1]}\")\n    print(\"=\" * 60)\n    \nelse:\n    print(\"=\" * 60)\n    print(\"Cache not found or FORCE_REBUILD=True - will save after first run\")\n    print(\"To use cache next time:\")\n    print(\"  1. Run the first cell with history_slice = raw_history[:]\")\n    print(\"  2. Wait for features/targets to compute\")\n    print(\"  3. This cell will save them\")\n    print(\"  4. Next time, set FORCE_REBUILD=False and skip the first cell\")\n    print(\"=\" * 60)\n    \n    # Save the current run to cache\n    if 'features' in globals() and 'targets' in globals():\n        print(\"\\nSaving current features and targets to cache...\")\n        t_save = time.time()\n        \n        with open(feature_cache, 'wb') as f:\n            pickle.dump(features, f)\n        with open(target_cache, 'wb') as f:\n            pickle.dump(targets, f)\n        with open(combined_cache, 'wb') as f:\n            pickle.dump(combined_df, f)\n        \n        print(f\" Saved to cache in {time.time()-t_save:.2f}s\")\n        print(f\"  Location: {cache_root}\")\n    else:\n        print(\" No features/targets to save yet - run the first cell first\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":6,"endColumn":1}}],"cellIndex":2},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X13sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X13sZmlsZQ=="},"requestId":"request_9d1a734f-1fb3-4999-b7bb-8a28cceeb48e","epoch":46,"edits":[{"text":"# Comprehensive NaN analysis in features\nprint(\"=\" * 70)\nprint(\"NaN Analysis in Features\")\nprint(\"=\" * 70)\n\n# 1. Overall NaN statistics\nnan_counts = features.isna().sum()\nnan_features = nan_counts[nan_counts > 0].sort_values(ascending=False)\n\nprint(f\"\\nTotal features: {len(features.columns)}\")\nprint(f\"Features with NaNs: {len(nan_features)}\")\nprint(f\"Total rows: {len(features)}\")\n\n# 2. Group NaN features by prefix to identify source\nprint(\"\\n\" + \"=\" * 70)\nprint(\"NaN Features Grouped by Source:\")\nprint(\"=\" * 70)\n\nfeature_groups = {}\nfor feat in nan_features.index:\n    # Extract prefix (everything before first underscore or digit)\n    if '_' in feat:\n        prefix = feat.split('_')[0]\n    else:\n        prefix = 'other'\n    \n    if prefix not in feature_groups:\n        feature_groups[prefix] = []\n    feature_groups[prefix].append((feat, nan_counts[feat]))\n\n# Sort groups by total NaN count\nsorted_groups = sorted(feature_groups.items(), \n                       key=lambda x: sum(count for _, count in x[1]), \n                       reverse=True)\n\nfor prefix, features_list in sorted_groups[:10]:  # Top 10 groups\n    total_nans = sum(count for _, count in features_list)\n    print(f\"\\n{prefix.upper()} features: {len(features_list)} features, {total_nans:,} total NaNs\")\n    # Show top 5 within each group\n    for feat, count in sorted(features_list, key=lambda x: x[1], reverse=True)[:5]:\n        pct = (count / len(features)) * 100\n        print(f\"  {feat:50s} {count:6,} NaNs ({pct:5.2f}%)\")\n\n# 3. Analyze NaN patterns (start/middle/end)\nprint(\"\\n\" + \"=\" * 70)\nprint(\"NaN Location Analysis (Top 10 worst features):\")\nprint(\"=\" * 70)\n\nfor feat in nan_features.head(10).index:\n    series = features[feat]\n    nan_mask = series.isna()\n    \n    # Find first and last valid index\n    valid_indices = series[~nan_mask].index\n    if len(valid_indices) == 0:\n        print(f\"\\n{feat}: ALL NaNs!\")\n        continue\n    \n    first_valid = valid_indices[0]\n    last_valid = valid_indices[-1]\n    \n    # Count NaNs at start, middle, end\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\n    middle_nans = nan_mask.sum() - start_nans - end_nans\n    \n    print(f\"\\n{feat}:\")\n    print(f\"  Total NaNs: {nan_mask.sum():,} ({nan_mask.sum()/len(features)*100:.2f}%)\")\n    print(f\"  Start NaNs: {start_nans:,} (before {first_valid})\")\n    print(f\"  Middle NaNs: {middle_nans:,}\")\n    print(f\"  End NaNs: {end_nans:,} (after {last_valid})\")\n\n# 4. Check specific feature types that are expected\nprint(\"\\n\" + \"=\" * 70)\nprint(\"Expected NaN Sources (prev_weekend, empirical, etc.):\")\nprint(\"=\" * 70)\n\nprev_weekend_features = [f for f in nan_features.index if 'prev_saturday' in f or 'prev_sunday' in f]\nempirical_features = [f for f in nan_features.index if 'emp_' in f]\nprev_weekday_features = [f for f in nan_features.index if 'prev_weekday' in f]\n\nprint(f\"\\nprev_saturday/sunday features with NaNs: {len(prev_weekend_features)}\")\nif prev_weekend_features:\n    for feat in prev_weekend_features[:5]:\n        print(f\"  {feat}: {nan_counts[feat]:,} NaNs\")\n\nprint(f\"\\nemp_ (empirical) features with NaNs: {len(empirical_features)}\")\nif empirical_features:\n    for feat in empirical_features[:5]:\n        print(f\"  {feat}: {nan_counts[feat]:,} NaNs\")\n\nprint(f\"\\nprev_weekday features with NaNs: {len(prev_weekday_features)}\")\nif prev_weekday_features:\n    for feat in prev_weekday_features[:5]:\n        print(f\"  {feat}: {nan_counts[feat]:,} NaNs\")\n\n# 5. Check which rows have NaNs\nprint(\"\\n\" + \"=\" * 70)\nprint(\"Row-wise NaN Analysis:\")\nprint(\"=\" * 70)\n\nrows_with_nans = features.isna().any(axis=1)\nprint(f\"Rows with ANY NaNs: {rows_with_nans.sum():,} / {len(features):,} ({rows_with_nans.sum()/len(features)*100:.2f}%)\")\n\n# Show first and last rows with NaNs\nnan_row_indices = features[rows_with_nans].index\nif len(nan_row_indices) > 0:\n    print(f\"First row with NaNs: {nan_row_indices[0]}\")\n    print(f\"Last row with NaNs: {nan_row_indices[-1]}\")\n    \n    # Count consecutive NaNs at start and end\n    consecutive_start = 0\n    for i in range(len(rows_with_nans)):\n        if rows_with_nans.iloc[i]:\n            consecutive_start += 1\n        else:\n            break\n    \n    consecutive_end = 0\n    for i in range(len(rows_with_nans)-1, -1, -1):\n        if rows_with_nans.iloc[i]:\n            consecutive_end += 1\n        else:\n            break\n    \n    print(f\"Consecutive NaN rows at start: {consecutive_start}\")\n    print(f\"Consecutive NaN rows at end: {consecutive_end}\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":3,"endColumn":25}}],"cellIndex":3},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_269d5b27-8e89-438c-bbb8-63b3245733cb","epoch":49,"cellEdits":[{"editType":1,"index":4,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Investigate middle NaNs - specifically stochastic features\nprint(\"=\" * 70)\nprint(\"Investigating Middle NaNs in Stochastic Features\")\nprint(\"=\" * 70)\n\n# Get stochastic features\nstoch_features = [col for col in features.columns if 'stoch_pos' in col]\nprint(f\"\\nStochastic features: {stoch_features}\")\n\n# Check where NaNs occur\nstoch_3h = features['stoch_pos_3h']\nnan_mask = stoch_3h.isna()\n\nprint(f\"\\nTotal NaNs in stoch_pos_3h: {nan_mask.sum()}\")\n\n# Find the NaN rows\nnan_rows = features[nan_mask]\nprint(f\"\\nDate range of NaN occurrences:\")\nprint(f\"  First NaN: {nan_rows.index[0]}\")\nprint(f\"  Last NaN: {nan_rows.index[-1]}\")\n\n# Sample some NaN periods\nprint(f\"\\nSample NaN periods (showing 10 random samples):\")\nsample_nans = nan_rows.sample(min(10, len(nan_rows)))\nfor idx in sample_nans.index:\n    print(f\"  {idx}\")\n\n# Check if these correspond to flat price periods\nprint(\"\\n\" + \"=\" * 70)\nprint(\"Checking if NaNs coincide with flat price periods\")\nprint(\"=\" * 70)\n\n# Need to access raw OHLC data to verify\nif 'raw_history' in globals():\n    # Get a few NaN samples and check the raw data around them\n    sample_nan_times = nan_rows.index[:5]\n    \n    for nan_time in sample_nan_times:\n        # Get 3h window around this time\n        window_start = nan_time - pd.Timedelta(hours=3)\n        window_end = nan_time\n        \n        window_data = raw_history.loc[window_start:window_end, ['high', 'low', 'close']]\n        \n        if len(window_data) > 0:\n            price_range = window_data['high'].max() - window_data['low'].min()\n            print(f\"\\n{nan_time}:\")\n            print(f\"  High-Low range over 3h: ${price_range:.2f}\")\n            print(f\"  High: ${window_data['high'].max():.2f}, Low: ${window_data['low'].min():.2f}\")\n            \n            if price_range < 0.01:\n                print(f\"   FLAT PERIOD - price range < $0.01\")\nelse:\n    print(\"\\nraw_history not available - cannot verify flat periods\")\n    print(\"But this is the expected cause: high == low over the window  stoch denominator = 0\")","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_8f542cb0-d845-4c87-bb2c-b83a4b508fb0","epoch":53,"edits":[{"text":"        for w in self.vol_window_sizes:\n            if w <= 1:\n                continue\n            min_p = max(1, w // 2)\n            rolling_high = high.rolling(window=w, min_periods=min_p).max()\n            rolling_low = low.rolling(window=w, min_periods=min_p).min()\n            range_w = rolling_high - rolling_low\n            # Add epsilon to avoid division by zero in flat periods; flat periods get 0.5 (neutral)\n            epsilon = 1e-10\n            rel_df[f\"stoch_pos_{w}h\"] = ((close - rolling_low) / (range_w + epsilon)).clip(0, 1)","range":{"startLineNumber":630,"startColumn":1,"endLineNumber":637,"endColumn":85}}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_12a6e73d-b33c-4750-899a-23b3790b61ab","epoch":56,"cellEdits":[{"editType":1,"index":5,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Investigate the 2 middle NaNs in vol_gkyz and price_rank features\nprint(\"=\" * 70)\nprint(\"Investigating 2 Middle NaNs in vol_gkyz_288h and price_rank_288h\")\nprint(\"=\" * 70)\n\n# Check vol_gkyz_288h\nvol_feature = features['vol_gkyz_288h']\nnan_mask = vol_feature.isna()\n\nprint(f\"\\nTotal NaNs in vol_gkyz_288h: {nan_mask.sum()}\")\n\n# Find first and last valid\nvalid_indices = vol_feature[~nan_mask].index\nfirst_valid = valid_indices[0]\nlast_valid = valid_indices[-1]\n\nprint(f\"First valid index: {first_valid}\")\nprint(f\"Last valid index: {last_valid}\")\n\n# Find the middle NaNs (those between first and last valid)\nmiddle_nan_mask = nan_mask.copy()\nmiddle_nan_mask.loc[:first_valid] = False\nmiddle_nan_mask.loc[last_valid:] = False\n\nmiddle_nan_indices = features[middle_nan_mask].index\n\nprint(f\"\\nMiddle NaN count: {len(middle_nan_indices)}\")\nprint(f\"Middle NaN locations:\")\nfor idx in middle_nan_indices:\n    print(f\"  {idx}\")\n\n# Check what's happening around these times\nif len(middle_nan_indices) > 0:\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Context around middle NaNs:\")\n    print(\"=\" * 70)\n    \n    for nan_idx in middle_nan_indices:\n        # Look at a window around the NaN\n        window_start = features.index.get_loc(nan_idx) - 5\n        window_end = features.index.get_loc(nan_idx) + 5\n        \n        print(f\"\\nAround {nan_idx}:\")\n        window_data = features.iloc[window_start:window_end+1][['vol_gkyz_288h', 'price_rank_288h']]\n        print(window_data)\n        \n        # Check raw OHLC data if available\n        if 'raw_history' in globals():\n            print(f\"\\nRaw OHLC data around {nan_idx}:\")\n            raw_window = raw_history.loc[nan_idx - pd.Timedelta(hours=2):nan_idx + pd.Timedelta(hours=2)]\n            print(raw_window[['open', 'high', 'low', 'close', 'volume']].head(10))","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X20sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X20sZmlsZQ=="},"requestId":"request_12a6e73d-b33c-4750-899a-23b3790b61ab","epoch":57,"edits":[{"text":"# Investigate the 2 middle NaNs - reproduce exact calculation from earlier cell\nprint(\"=\" * 70)\nprint(\"Reproducing NaN Location Calculation for vol_gkyz_288h\")\nprint(\"=\" * 70)\n\nfeat = 'vol_gkyz_288h'\nseries = features[feat]\nnan_mask = series.isna()\n\nprint(f\"Total NaNs: {nan_mask.sum()}\")\n\n# Find first and last valid index (same logic as earlier cell)\nvalid_indices = series[~nan_mask].index\nif len(valid_indices) == 0:\n    print(f\"\\n{feat}: ALL NaNs!\")\nelse:\n    first_valid = valid_indices[0]\n    last_valid = valid_indices[-1]\n    \n    print(f\"First valid: {first_valid}\")\n    print(f\"Last valid: {last_valid}\")\n    \n    # Count NaNs at start, middle, end (EXACT same logic as earlier)\n    start_nans = nan_mask.loc[:first_valid].sum() - 1  # -1 to exclude first valid\n    end_nans = nan_mask.loc[last_valid:].sum() - 1  # -1 to exclude last valid\n    middle_nans = nan_mask.sum() - start_nans - end_nans\n    \n    print(f\"\\nStart NaNs: {start_nans} (before {first_valid})\")\n    print(f\"End NaNs: {end_nans} (after {last_valid})\")\n    print(f\"Middle NaNs: {middle_nans}\")\n    \n    # Debug the calculation\n    print(f\"\\nDebug:\")\n    print(f\"  Total NaNs = {nan_mask.sum()}\")\n    print(f\"  NaNs up to first_valid (inclusive) = {nan_mask.loc[:first_valid].sum()}\")\n    print(f\"  Start NaNs = {nan_mask.loc[:first_valid].sum()} - 1 = {start_nans}\")\n    print(f\"  NaNs from last_valid onwards (inclusive) = {nan_mask.loc[last_valid:].sum()}\")\n    print(f\"  End NaNs = {nan_mask.loc[last_valid:].sum()} - 1 = {end_nans}\")\n    print(f\"  Middle = {nan_mask.sum()} - {start_nans} - {end_nans} = {middle_nans}\")\n    \n    # Check if there are actually any NaNs between first and last valid\n    actual_middle_nans = nan_mask.loc[first_valid:last_valid]\n    actual_middle_nan_count = actual_middle_nans.sum()\n    \n    print(f\"\\nActual middle NaNs (between first and last valid, inclusive):\")\n    print(f\"  Count: {actual_middle_nan_count}\")\n    \n    if actual_middle_nan_count > 0:\n        print(f\"  Locations:\")\n        for idx in series[actual_middle_nans].index:\n            print(f\"    {idx}\")","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":51,"endColumn":83}}],"cellIndex":5},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X14sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X14sZmlsZQ=="},"requestId":"request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76","epoch":60,"edits":[{"text":"# Clean combined dataframe based on actual NaN patterns\n# From analysis: 288 consecutive NaN rows at start, 0 at end\n\n# Drop rows with NaNs (all at the start from lookback windows)\nrows_with_nans = combined_df.isna().any(axis=1)\nfirst_clean_idx = combined_df[~rows_with_nans].index[0]\n\nprint(f\"First row without NaNs: {first_clean_idx}\")\nprint(f\"Dropping {rows_with_nans.sum()} rows with NaNs (all at start)\")\n\ncombined_df_clean = combined_df[~rows_with_nans].copy()\n\nprint(f\"Rows after NaN removal: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\")\nprint(f\"Date range: {(combined_df_clean.index[-1] - combined_df_clean.index[0]).days} days\")\n\n# Final check\nfinal_nan_check = combined_df_clean.isna().sum().sum()\nprint(f\"\\nFinal NaN check: {final_nan_check} total NaNs remaining\")\n\ncombined_df_clean","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":15,"endColumn":1}}],"cellIndex":4},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X15sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X15sZmlsZQ=="},"requestId":"request_f9f1b2fb-a629-476d-b2f3-a5248e53ec76","epoch":61,"edits":[{"text":"# Split into train/val/test (80/10/10)\nn_samples = len(combined_df_clean)\ntrain_end = int(n_samples * 0.8)\nval_end = train_end + int(n_samples * 0.1)\n\n# Get feature and target columns\nfeature_cols = features.columns.intersection(combined_df_clean.columns)\ntarget_cols = targets.columns.intersection(combined_df_clean.columns)\n\nX_train = combined_df_clean[feature_cols].iloc[:train_end]\nX_val = combined_df_clean[feature_cols].iloc[train_end:val_end]\nX_test = combined_df_clean[feature_cols].iloc[val_end:]\n\ny_train = combined_df_clean[target_cols].iloc[:train_end]\ny_val = combined_df_clean[target_cols].iloc[train_end:val_end]\ny_test = combined_df_clean[target_cols].iloc[val_end:]\n\nprint(f\"Split sizes:\")\nprint(f\"  Train: {len(X_train):,} rows ({len(X_train)/n_samples*100:.1f}%)\")\nprint(f\"  Val:   {len(X_val):,} rows ({len(X_val)/n_samples*100:.1f}%)\")\nprint(f\"  Test:  {len(X_test):,} rows ({len(X_test)/n_samples*100:.1f}%)\")\n\nprint(f\"\\nX shapes -> train {X_train.shape}, val {X_val.shape}, test {X_test.shape}\")\nprint(f\"y shapes -> train {y_train.shape}, val {y_val.shape}, test {y_test.shape}\")\n\n# Final NaN check on all splits\ntrain_nans = X_train.isna().sum().sum()\nval_nans = X_val.isna().sum().sum()\ntest_nans = X_test.isna().sum().sum()\n\nif train_nans + val_nans + test_nans == 0:\n    print(\"\\n No NaNs in any split - ready for training!\")\nelse:\n    print(f\"\\n NaNs found:\")\n    if train_nans > 0:\n        print(f\"  Train: {train_nans} NaNs\")\n    if val_nans > 0:\n        print(f\"  Val: {val_nans} NaNs\")\n    if test_nans > 0:\n        print(f\"  Test: {test_nans} NaNs\")","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":37,"endColumn":1}}],"cellIndex":5},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X14sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X14sZmlsZQ=="},"requestId":"request_3676fdae-cdcc-4867-91e4-99d4b4c0f9a6","epoch":64,"edits":[{"text":"# Clean combined dataframe - only drop start and end NaNs, preserve middle for debugging\n# From analysis: 288 consecutive NaN rows at start, 0 at end\n\nrows_with_nans = combined_df.isna().any(axis=1)\n\n# Find first and last valid rows\nvalid_rows = ~rows_with_nans\nvalid_indices = combined_df[valid_rows].index\n\nif len(valid_indices) > 0:\n    first_valid = valid_indices[0]\n    last_valid = valid_indices[-1]\n    \n    # Count start and end NaNs\n    start_nans = rows_with_nans.loc[:first_valid].sum() - 1\n    end_nans = rows_with_nans.loc[last_valid:].sum() - 1\n    \n    print(f\"NaN Summary:\")\n    print(f\"  First valid row: {first_valid}\")\n    print(f\"  Last valid row: {last_valid}\")\n    print(f\"  Start NaNs to drop: {start_nans}\")\n    print(f\"  End NaNs to drop: {max(0, end_nans)}\")\n    \n    # Slice from first valid to last valid (inclusive)\n    combined_df_clean = combined_df.loc[first_valid:last_valid].copy()\n    \n    # Check for middle NaNs (these are preserved for inspection)\n    middle_nans = combined_df_clean.isna().any(axis=1).sum()\n    \n    print(f\"\\nAfter trimming start/end:\")\n    print(f\"  Rows: {len(combined_df_clean)} (from {combined_df_clean.index[0]} to {combined_df_clean.index[-1]})\")\n    print(f\"  Middle rows with NaNs: {middle_nans}\")\n    \n    if middle_nans > 0:\n        print(f\"   WARNING: {middle_nans} rows with NaNs in middle - preserved for debugging\")\nelse:\n    print(\"No valid rows found!\")\n    combined_df_clean = combined_df.iloc[0:0]  # Empty dataframe\n\ncombined_df_clean","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":20,"endColumn":18}}],"cellIndex":4},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_338f27d9-6b23-4aad-a745-773b1b4384a6","epoch":67,"cellEdits":[{"editType":1,"index":5,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Analyze which features have the middle NaNs\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\n    print(\"=\" * 70)\n    print(\"Analyzing Middle NaN Features\")\n    print(\"=\" * 70)\n    \n    # Get rows with NaNs\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\n    \n    if rows_with_middle_nans.sum() > 0:\n        # Count NaNs per feature\n        middle_nan_counts = combined_df_clean.isna().sum()\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\n        \n        print(f\"\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\")\n        print(f\"\\nTop 10 features by NaN count:\")\n        for feat, count in features_with_middle_nans.head(10).items():\n            pct = (count / len(combined_df_clean)) * 100\n            print(f\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\")\n        \n        # Group by prefix\n        print(f\"\\nGrouped by feature type:\")\n        feature_groups = {}\n        for feat in features_with_middle_nans.index:\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\n            if prefix not in feature_groups:\n                feature_groups[prefix] = 0\n            feature_groups[prefix] += features_with_middle_nans[feat]\n        \n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\n            print(f\"  {prefix:20s} {total_nans:6,} total NaNs\")\n        \n        # Show date range of NaN occurrences\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\n        print(f\"\\nDate range of middle NaNs:\")\n        print(f\"  First: {nan_dates[0]}\")\n        print(f\"  Last: {nan_dates[-1]}\")\n        \n        # Explanation\n        print(f\"\\n{'='*70}\")\n        print(\"Expected cause: Stochastic features produce NaN when price is flat\")\n        print(\"(high == low over window  0/0 = NaN)\")\n        print(f\"{'='*70}\")\n    else:\n        print(\"\\n No middle NaNs found!\")\nelse:\n    print(\"No data to analyze\")","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X21sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X21sZmlsZQ=="},"requestId":"request_18c89704-8cd3-4be9-b079-5a7dee1a30c8","epoch":71,"edits":[{"text":"# Analyze which features have the middle NaNs and verify stochastic fix\nif 'combined_df_clean' in globals() and len(combined_df_clean) > 0:\n    print(\"=\" * 70)\n    print(\"Analyzing Middle NaN Features\")\n    print(\"=\" * 70)\n    \n    # Get rows with NaNs\n    rows_with_middle_nans = combined_df_clean.isna().any(axis=1)\n    \n    if rows_with_middle_nans.sum() > 0:\n        # Count NaNs per feature\n        middle_nan_counts = combined_df_clean.isna().sum()\n        features_with_middle_nans = middle_nan_counts[middle_nan_counts > 0].sort_values(ascending=False)\n        \n        print(f\"\\nFeatures with middle NaNs: {len(features_with_middle_nans)}\")\n        print(f\"\\nTop 20 features by NaN count:\")\n        for feat, count in features_with_middle_nans.head(20).items():\n            pct = (count / len(combined_df_clean)) * 100\n            print(f\"  {feat:40s} {count:4d} NaNs ({pct:5.2f}%)\")\n        \n        # Group by prefix\n        print(f\"\\nGrouped by feature type:\")\n        feature_groups = {}\n        for feat in features_with_middle_nans.index:\n            prefix = feat.split('_')[0] if '_' in feat else 'other'\n            if prefix not in feature_groups:\n                feature_groups[prefix] = 0\n            feature_groups[prefix] += features_with_middle_nans[feat]\n        \n        for prefix, total_nans in sorted(feature_groups.items(), key=lambda x: x[1], reverse=True):\n            print(f\"  {prefix:20s} {total_nans:6,} total NaNs\")\n        \n        # Check specifically for stochastic features\n        stoch_features_in_nans = [f for f in features_with_middle_nans.index if 'stoch' in f]\n        print(f\"\\nStochastic features with NaNs: {len(stoch_features_in_nans)}\")\n        if stoch_features_in_nans:\n            print(\"   STOCHASTIC FIX NOT APPLIED! Should be 0.\")\n            for feat in stoch_features_in_nans:\n                print(f\"    {feat}: {features_with_middle_nans[feat]} NaNs\")\n        else:\n            print(\"   No stochastic NaNs - fix is working!\")\n        \n        # Show date range of NaN occurrences\n        nan_dates = combined_df_clean[rows_with_middle_nans].index\n        print(f\"\\nDate range of middle NaNs:\")\n        print(f\"  First: {nan_dates[0]}\")\n        print(f\"  Last: {nan_dates[-1]}\")\n        \n    else:\n        print(\"\\n No middle NaNs found!\")\nelse:\n    print(\"No data to analyze\")","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":47,"endColumn":32}}],"cellIndex":5},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_9d694dd5-b50c-4dd8-9cbc-d1e314dc8ebb","epoch":74,"cellEdits":[{"editType":1,"index":6,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Investigate why regime_label has NaNs in Jan 2020\nprint(\"=\" * 70)\nprint(\"Investigating Regime Label NaNs\")\nprint(\"=\" * 70)\n\n# Get the rows with regime NaNs\nregime_nans = combined_df_clean['regime_label'].isna()\nnan_rows = combined_df_clean[regime_nans]\n\nprint(f\"\\nTotal rows with regime_label NaN: {regime_nans.sum()}\")\nprint(f\"Date range: {nan_rows.index[0]} to {nan_rows.index[-1]}\")\n\n# Check if this is a continuous block\nprint(f\"\\nFirst 10 NaN timestamps:\")\nfor ts in nan_rows.index[:10]:\n    print(f\"  {ts}\")\n\n# Check the raw data around this period\nif 'raw_history' in globals():\n    print(f\"\\nChecking raw data around NaN period:\")\n    check_start = nan_rows.index[0] - pd.Timedelta(hours=24)\n    check_end = nan_rows.index[-1] + pd.Timedelta(hours=24)\n    \n    raw_slice = raw_history.loc[check_start:check_end]\n    print(f\"  Raw data rows in this period: {len(raw_slice)}\")\n    print(f\"  Expected rows (hourly): {int((check_end - check_start).total_seconds() / 3600)}\")\n    \n    # Check for gaps\n    if len(raw_slice) > 0:\n        time_diffs = raw_slice.index.to_series().diff()\n        gaps = time_diffs[time_diffs > pd.Timedelta(hours=1)]\n        if len(gaps) > 0:\n            print(f\"\\n   Found {len(gaps)} time gaps:\")\n            for gap_time, gap_size in gaps.items():\n                print(f\"    {gap_time}: {gap_size}\")\n        else:\n            print(f\"   No time gaps found\")\n\n# Check what features look like during this period\nprint(f\"\\nFeature values during NaN period (first NaN row):\")\nfirst_nan_row = combined_df_clean.loc[nan_rows.index[0]]\nprint(f\"  vol_rs_24h: {first_nan_row.get('vol_rs_24h', 'N/A')}\")\nprint(f\"  vol_rs_72h: {first_nan_row.get('vol_rs_72h', 'N/A')}\")\nprint(f\"  trend_strength_24h: {first_nan_row.get('trend_strength_24h', 'N/A')}\")\nprint(f\"  logret_24h: {first_nan_row.get('logret_24h', 'N/A')}\")","outputs":[],"internalMetadata":{}}]}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_668f889f-1529-48c7-a0f0-c7536b019d14","epoch":77,"cellEdits":[{"editType":1,"index":7,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Check what volatility features actually exist\nprint(\"=\" * 70)\nprint(\"Checking Available Volatility Features\")\nprint(\"=\" * 70)\n\n# Get all vol features\nvol_features = [col for col in features.columns if 'vol' in col.lower()]\nprint(f\"\\nTotal volatility features: {len(vol_features)}\")\nprint(f\"\\nFirst 20 vol features:\")\nfor feat in sorted(vol_features)[:20]:\n    print(f\"  {feat}\")\n\n# Specifically look for Rogers-Satchell vol\nrs_vol_features = [col for col in features.columns if 'vol_rs' in col]\nprint(f\"\\nRogers-Satchell vol features: {len(rs_vol_features)}\")\nif rs_vol_features:\n    for feat in rs_vol_features:\n        print(f\"  {feat}\")\nelse:\n    print(\"   NO Rogers-Satchell volatility features found!\")\n    print(\"  This means the VolatilityRegimeEngineer cannot compute volatility.\")\n    \n# Check what the regime engineer expects\nprint(f\"\\n\" + \"=\" * 70)\nprint(\"What VolatilityRegimeEngineer needs:\")\nprint(\"=\" * 70)\nprint(\"The regime engineer computes Rogers-Satchell vol internally from OHLC\")\nprint(\"It does NOT use pre-computed vol_rs features from featureEngineer!\")\nprint(\"\\nBut it's passed the features DataFrame, and it should have OHLC columns...\")\n\n# Check if features has OHLC\nohlc_cols = ['open', 'high', 'low', 'close']\nhas_ohlc = [col for col in ohlc_cols if col in features.columns]\nprint(f\"\\nOHLC columns in features: {has_ohlc}\")\nif len(has_ohlc) < 4:\n    print(f\"   MISSING OHLC! Regime engineer needs all 4 OHLC columns\")\n    print(f\"  Missing: {[c for c in ohlc_cols if c not in features.columns]}\")","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":81,"edits":[{"text":"# Pass raw history (has OHLC) instead of features (doesn't have OHLC)","range":{"startLineNumber":92,"startColumn":1,"endLineNumber":92,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":82,"edits":[{"text":"regime_engineer.fit(history_slice)","range":{"startLineNumber":93,"startColumn":1,"endLineNumber":93,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":83,"edits":[{"text":"targets = regime_engineer.transform(history_slice)","range":{"startLineNumber":94,"startColumn":1,"endLineNumber":94,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":84,"edits":[{"text":"print(f\"Regime targets built in {time.time()-t2:.2f}s -> shape: {targets.shape}\")","range":{"startLineNumber":95,"startColumn":1,"endLineNumber":95,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":85,"edits":[{"text":"","range":{"startLineNumber":96,"startColumn":1,"endLineNumber":96,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":86,"edits":[{"text":"# Check distribution","range":{"startLineNumber":97,"startColumn":1,"endLineNumber":97,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":87,"edits":[{"text":"dist = regime_engineer.get_regime_distribution(history_slice)","range":{"startLineNumber":98,"startColumn":1,"endLineNumber":98,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":88,"edits":[{"text":"print(\"\\nRegime distribution:\")","range":{"startLineNumber":99,"startColumn":1,"endLineNumber":99,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":89,"edits":[{"text":"print(dist)","range":{"startLineNumber":100,"startColumn":1,"endLineNumber":100,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":90,"edits":[{"text":"","range":{"startLineNumber":101,"startColumn":1,"endLineNumber":101,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":91,"edits":[{"text":"# Combine","range":{"startLineNumber":102,"startColumn":1,"endLineNumber":102,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":92,"edits":[{"text":"combined_df = pd.concat([features, targets], axis=1)","range":{"startLineNumber":103,"startColumn":1,"endLineNumber":103,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":93,"edits":[{"text":"print(f\"\\nCombined shape: {combined_df.shape}\")","range":{"startLineNumber":104,"startColumn":1,"endLineNumber":104,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":94,"edits":[{"text":"print(f\"Total pipeline time: {time.time()-t0:.2f}s\")","range":{"startLineNumber":105,"startColumn":1,"endLineNumber":105,"endColumn":1073741825}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#W1sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"W1sZmlsZQ=="},"requestId":"request_e8dcf706-b65c-44ab-bbe2-dd4f896bc15f","epoch":95,"edits":[{"text":"\n","range":{"startLineNumber":106,"startColumn":1,"endLineNumber":106,"endColumn":1}}],"cellIndex":1},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_ab239e5c-3640-4e58-99d5-329005c0207e","epoch":100,"edits":[{"text":"        for idx in X.index:\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            # If box_std is NaN or too small (flat period), assign chop (0) and continue\n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0:\n                results.at[idx, 'regime_label'] = 0\n                continue","range":{"startLineNumber":270,"startColumn":1,"endLineNumber":274,"endColumn":79}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":105,"edits":[{"text":"        for idx in X.index:\n            box_std = box_df.loc[idx, 'box_std']\n            ref_price = box_df.loc[idx, 'reference_price']\n            \n            # If box_std is NaN or too small (flat period), assign chop (0) and continue\n            if pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue","range":{"startLineNumber":270,"startColumn":1,"endLineNumber":277,"endColumn":25}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":108,"edits":[{"text":"        ## lets use raw vol as thats what blackscholes does and they actually got a noble prize somehow\n        vol_24 = _lookup(\"vol_raw_24h\")\n        vol_144 = _lookup(\"vol_raw_144h\")\n        vol_288 = _lookup(\"vol_raw_288h\")\n\n        epsilon = 1e-10\n        vol_df[\"vol_ratio_24h_144h\"] = vol_24 / (vol_144 + epsilon)\n        vol_df[\"vol_ratio_24h_288h\"] = vol_24 / (vol_288 + epsilon)","range":{"startLineNumber":515,"startColumn":1,"endLineNumber":521,"endColumn":75}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":110,"edits":[{"text":"            fwd_indices = X.index[idx_pos+1:fwd_end_pos]\n            fwd_highs = high.loc[fwd_indices]\n            fwd_lows = low.loc[fwd_indices]\n            if fwd_highs.empty:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue","range":{"startLineNumber":285,"startColumn":1,"endLineNumber":288,"endColumn":41}}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":111,"edits":[{"text":"            idx_pos = X.index.get_loc(idx)\n            fwd_end_pos = min(idx_pos + self.forward_window, len(X.index))\n            if fwd_end_pos <= idx_pos + 1:\n                results.at[idx, 'regime_label'] = 0\n                results.at[idx, 'max_fwd_z_score'] = 0.0\n                results.at[idx, 'max_jump_z_score'] = 0.0\n                continue\n            \n            fwd_indices = X.index[idx_pos+1:fwd_end_pos]","range":{"startLineNumber":281,"startColumn":1,"endLineNumber":285,"endColumn":57}}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":113,"cellEdits":[{"editType":1,"index":6,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Deep dive into exact NaN locations\nnan_rows = combined_df_clean[combined_df_clean.isna().any(axis=1)]\nprint(f\"Rows with NaNs: {len(nan_rows)}\")\n\n# For each row, show which columns have NaNs\nprint(\"\\nFirst 10 rows with NaNs and their NaN columns:\")\nfor idx in nan_rows.index[:10]:\n    nan_cols = nan_rows.loc[idx][nan_rows.loc[idx].isna()].index.tolist()\n    print(f\"  {idx}: {nan_cols}\")\n\n# Check a specific row more deeply\nif len(nan_rows) > 0:\n    first_nan_idx = nan_rows.index[0]\n    print(f\"\\nDetailed view of first NaN row ({first_nan_idx}):\")\n    row = combined_df_clean.loc[first_nan_idx]\n    \n    # Show all z_score and regime columns\n    relevant_cols = [c for c in row.index if 'regime' in c or 'z_score' in c or 'vol_ratio' in c]\n    for col in relevant_cols:\n        val = row[col]\n        print(f\"  {col:30s} = {val}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","epoch":114,"cellEdits":[{"editType":1,"index":7,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Check what's happening with these rows - simulate the regime engineer logic\nfrom targetEngineer import VolatilityRegimeEngineer\n\n# Get the raw history data for this period\ntest_period_start = pd.Timestamp('2020-01-05 00:00:00')\ntest_period_end = pd.Timestamp('2020-01-10 00:00:00')\n\nif 'history_slice' in globals():\n    test_data = history_slice.loc[test_period_start:test_period_end]\n    print(f\"Test data shape: {test_data.shape}\")\n    print(f\"\\nOHLC values during flat period:\")\n    print(test_data[['open', 'high', 'low', 'close']].head(20))\n    \n    # Check if OHLC are all equal\n    ohlc_equal = (test_data['open'] == test_data['high']) & \\\n                 (test_data['high'] == test_data['low']) & \\\n                 (test_data['low'] == test_data['close'])\n    print(f\"\\nRows where OHLC all equal: {ohlc_equal.sum()} / {len(test_data)}\")\n    \n    # Manually compute box_std for first NaN row\n    first_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\n    lookback_window = 24*3  # 3 days\n    \n    # Get lookback window\n    idx_pos = history_slice.index.get_loc(first_nan_ts)\n    lookback_start_pos = max(0, idx_pos - lookback_window)\n    lookback_indices = history_slice.index[lookback_start_pos:idx_pos]\n    \n    print(f\"\\nLookback window for {first_nan_ts}:\")\n    print(f\"  Indices: {len(lookback_indices)} (from {lookback_indices[0]} to {lookback_indices[-1]})\")\n    \n    # Compute Rogers-Satchell for this window\n    lb_data = history_slice.loc[lookback_indices]\n    term1 = np.log(lb_data['high'] / lb_data['close']) * np.log(lb_data['high'] / lb_data['open'])\n    term2 = np.log(lb_data['low'] / lb_data['close']) * np.log(lb_data['low'] / lb_data['open'])\n    sum_term = term1 + term2\n    \n    print(f\"  term1+term2 has NaNs: {sum_term.isna().sum()}\")\n    print(f\"  term1+term2 min: {sum_term.min()}\")\n    print(f\"  term1+term2 max: {sum_term.max()}\")\n    \n    raw_vol = np.sqrt(sum_term.mean())\n    print(f\"  raw_vol: {raw_vol}\")\n    print(f\"  raw_vol is NaN: {pd.isna(raw_vol)}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"external":"vscode-notebook-cell:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb#X25sZmlsZQ%3D%3D","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"vscode-notebook-cell","fragment":"X25sZmlsZQ=="},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":117,"edits":[{"text":"# Check what's happening with these rows - simulate the regime engineer logic\nfrom targetEngineer import VolatilityRegimeEngineer\n\n# Get the raw history data for this period\ntest_period_start = pd.Timestamp('2020-01-05 00:00:00')\ntest_period_end = pd.Timestamp('2020-01-10 00:00:00')\n\nif 'history_slice' in globals():\n    test_data = history_slice.loc[test_period_start:test_period_end]\n    print(f\"Test data shape: {test_data.shape}\")\n    print(f\"\\nOHLC values during flat period:\")\n    print(test_data[['o', 'h', 'l', 'c']].head(20))\n    \n    # Check if OHLC are all equal\n    ohlc_equal = (test_data['o'] == test_data['h']) & \\\n                 (test_data['h'] == test_data['l']) & \\\n                 (test_data['l'] == test_data['c'])\n    print(f\"\\nRows where OHLC all equal: {ohlc_equal.sum()} / {len(test_data)}\")\n    \n    # Manually compute box_std for first NaN row\n    first_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\n    lookback_window = 24*3  # 3 days\n    \n    # Get lookback window\n    idx_pos = history_slice.index.get_loc(first_nan_ts)\n    lookback_start_pos = max(0, idx_pos - lookback_window)\n    lookback_indices = history_slice.index[lookback_start_pos:idx_pos]\n    \n    print(f\"\\nLookback window for {first_nan_ts}:\")\n    print(f\"  Indices: {len(lookback_indices)} (from {lookback_indices[0]} to {lookback_indices[-1]})\")\n    \n    # Compute Rogers-Satchell for this window\n    lb_data = history_slice.loc[lookback_indices]\n    term1 = np.log(lb_data['h'] / lb_data['c']) * np.log(lb_data['h'] / lb_data['o'])\n    term2 = np.log(lb_data['l'] / lb_data['c']) * np.log(lb_data['l'] / lb_data['o'])\n    sum_term = term1 + term2\n    \n    print(f\"  term1+term2 has NaNs: {sum_term.isna().sum()}\")\n    print(f\"  term1+term2 min: {sum_term.min()}\")\n    print(f\"  term1+term2 max: {sum_term.max()}\")\n    \n    raw_vol = np.sqrt(sum_term.mean())\n    print(f\"  raw_vol: {raw_vol}\")\n    print(f\"  raw_vol is NaN: {pd.isna(raw_vol)}\")\n","range":{"startLineNumber":1,"startColumn":1,"endLineNumber":45,"endColumn":1}}],"cellIndex":7},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":118,"cellEdits":[{"editType":1,"index":8,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Check if the NaN rows are hitting the fwd_end_pos check\nfirst_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\nforward_window = 24  # from regime engineer\n\nidx_pos = history_slice.index.get_loc(first_nan_ts)\nfwd_end_pos = min(idx_pos + forward_window, len(history_slice.index))\n\nprint(f\"For timestamp {first_nan_ts}:\")\nprint(f\"  idx_pos: {idx_pos}\")\nprint(f\"  forward_window: {forward_window}\")\nprint(f\"  idx_pos + forward_window: {idx_pos + forward_window}\")\nprint(f\"  len(history_slice): {len(history_slice)}\")\nprint(f\"  fwd_end_pos: {fwd_end_pos}\")\nprint(f\"  fwd_end_pos <= idx_pos + 1: {fwd_end_pos <= idx_pos + 1}\")\n\n# Show the forward window indices\nfwd_indices = history_slice.index[idx_pos+1:fwd_end_pos]\nprint(f\"\\nForward indices: {len(fwd_indices)} rows\")\nif len(fwd_indices) > 0:\n    print(f\"  From: {fwd_indices[0]}\")\n    print(f\"  To: {fwd_indices[-1]}\")\n    \n    # Check OHLC in forward window\n    fwd_data = history_slice.loc[fwd_indices]\n    ohlc_equal_fwd = (fwd_data['o'] == fwd_data['h']) & \\\n                     (fwd_data['h'] == fwd_data['l']) & \\\n                     (fwd_data['l'] == fwd_data['c'])\n    print(f\"  Forward rows with equal OHLC: {ohlc_equal_fwd.sum()} / {len(fwd_data)}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":119,"cellEdits":[{"editType":1,"index":9,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Check the jump loop iteration count\njump_speed_window = 6  # from regime engineer\n\nprint(f\"len(fwd_indices): {len(fwd_indices)}\")\nprint(f\"jump_speed_window: {jump_speed_window}\")\nprint(f\"len(fwd_indices) - jump_speed_window + 1: {len(fwd_indices) - jump_speed_window + 1}\")\nprint(f\"Jump loop will iterate: {max(0, len(fwd_indices) - jump_speed_window + 1)} times\")\n\nif len(fwd_indices) - jump_speed_window + 1 <= 0:\n    print(\"\\n Jump loop will NOT execute - max_jump_z_score will remain NaN!\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":120,"cellEdits":[{"editType":1,"index":10,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Check dtypes of z_score columns in targets\nprint(\"Z-score column dtypes in targets DataFrame:\")\nzscore_cols = [c for c in targets.columns if 'z_score' in c]\nfor col in zscore_cols:\n    print(f\"  {col:30s} {targets[col].dtype}\")\n\n# Check the specific NaN values\nfirst_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\nprint(f\"\\nValues for {first_nan_ts}:\")\nprint(f\"  max_fwd_z_score: {targets.loc[first_nan_ts, 'max_fwd_z_score']} (type: {type(targets.loc[first_nan_ts, 'max_fwd_z_score'])})\")\nprint(f\"  max_jump_z_score: {targets.loc[first_nan_ts, 'max_jump_z_score']} (type: {type(targets.loc[first_nan_ts, 'max_jump_z_score'])})\")\n\n# Check a non-NaN row\nnon_nan_ts = pd.Timestamp('2020-01-10 00:00:00')\nprint(f\"\\nValues for {non_nan_ts} (should be non-NaN):\")\nprint(f\"  max_fwd_z_score: {targets.loc[non_nan_ts, 'max_fwd_z_score']}\")\nprint(f\"  max_jump_z_score: {targets.loc[non_nan_ts, 'max_jump_z_score']}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"notebookEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","path":"/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","scheme":"file"},"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","epoch":121,"cellEdits":[{"editType":1,"index":11,"count":0,"cells":[{"cellKind":2,"language":"python","source":"# Manually simulate the regime engineer logic for the NaN row\nimport numpy as np\n\nfirst_nan_ts = pd.Timestamp('2020-01-05 16:00:00')\nprint(f\"Simulating regime logic for {first_nan_ts}:\")\n\n# Get box_std (from earlier we know it's ~0.001029)\nlookback_window = 24*3\nidx_pos = history_slice.index.get_loc(first_nan_ts)\nlookback_start_pos = max(0, idx_pos - lookback_window)\nlookback_indices = history_slice.index[lookback_start_pos:idx_pos]\nlb_data = history_slice.loc[lookback_indices]\nterm1 = np.log(lb_data['h'] / lb_data['c']) * np.log(lb_data['h'] / lb_data['o'])\nterm2 = np.log(lb_data['l'] / lb_data['c']) * np.log(lb_data['l'] / lb_data['o'])\nbox_std = np.sqrt((term1 + term2).mean())\nref_price = history_slice.loc[first_nan_ts, 'c']\n\nprint(f\"  box_std: {box_std}\")\nprint(f\"  ref_price: {ref_price}\")\nprint(f\"  box_std is NaN: {pd.isna(box_std)}\")\nprint(f\"  box_std <= 1e-9: {box_std <= 1e-9}\")\nprint(f\"  Would hit early continue: {pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0}\")\n\nif not (pd.isna(box_std) or box_std <= 1e-9 or ref_price <= 0):\n    print(\"\\n  Passed early checks, continuing...\")\n    \n    # Forward window\n    forward_window = 24\n    fwd_end_pos = min(idx_pos + forward_window, len(history_slice.index))\n    print(f\"  fwd_end_pos: {fwd_end_pos}, idx_pos: {idx_pos}\")\n    print(f\"  fwd_end_pos <= idx_pos + 1: {fwd_end_pos <= idx_pos + 1}\")\n    \n    if fwd_end_pos > idx_pos + 1:\n        fwd_indices = history_slice.index[idx_pos+1:fwd_end_pos]\n        fwd_highs = history_slice.loc[fwd_indices, 'h']\n        fwd_lows = history_slice.loc[fwd_indices, 'l']\n        \n        print(f\"  fwd_highs.empty: {fwd_highs.empty}\")\n        \n        if not fwd_highs.empty:\n            max_high = fwd_highs.max()\n            min_low = fwd_lows.min()\n            \n            ret_max = np.log(max_high / ref_price)\n            ret_min = np.log(min_low / ref_price)\n            max_abs_ret = max(abs(ret_max), abs(ret_min))\n            \n            sqrt_fwd = np.sqrt(forward_window)\n            fwd_z_score = max_abs_ret / (box_std * sqrt_fwd)\n            \n            print(f\"\\n  Computed fwd_z_score: {fwd_z_score}\")\n            print(f\"  max_high: {max_high}, min_low: {min_low}\")\n            print(f\"  ret_max: {ret_max}, ret_min: {ret_min}\")\n            print(f\"  max_abs_ret: {max_abs_ret}\")\n","outputs":[],"internalMetadata":{}}]}]},{"type":"textEdit","uri":{"$mid":1,"fsPath":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","external":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","path":"/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","scheme":"file"},"requestId":"request_411ab292-5756-487f-8aa8-328dd69ca5e8","epoch":134,"edits":[{"text":"        price_targets = self._calculate_price_targets(df)\n        abs_targets = self._calculate_absolute_expiry_targets(df)\n        \n        # Select engineered columns - only the ones created in this transform\n        # Exclude emp_ features that happen to contain 'logret_'\n        eng_cols = [c for c in df.columns \n                    if (c.startswith('logret_up_') or c.startswith('logret_down_') or c == 'next_24h_vol')\n                    and not c.startswith('emp_')]\n        df_targets = pd.concat([price_targets, abs_targets, df[eng_cols]], axis=1)","range":{"startLineNumber":150,"startColumn":1,"endLineNumber":155,"endColumn":83}}]}],"epochCounter":135},"recentSnapshot":{"entries":[{"resource":"file:///home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py","languageId":"python","originalHash":"32fd7c7","currentHash":"32fd7c7","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/home/east/shared/eastSync/pyEast/pro_version/targetEngineer.py?%7B%22sessionId%22%3A%22f2e62d2c-77c9-4883-ab60-40b4656f2b16%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_411ab292-5756-487f-8aa8-328dd69ca5e8","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py","languageId":"python","originalHash":"caa3f3e","currentHash":"caa3f3e","state":1,"snapshotUri":"chat-editing-snapshot-text-model:/home/east/shared/eastSync/pyEast/pro_version/featureEngineer.py?%7B%22sessionId%22%3A%22f2e62d2c-77c9-4883-ab60-40b4656f2b16%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%7D","telemetryInfo":{"requestId":"request_926b3694-cc27-4bf4-b344-24aa1dcd8cee","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb","languageId":"VSCodeChatNotebookSnapshotLanguage","originalHash":"c17c503","currentHash":"2b18980","state":1,"snapshotUri":"chat-editing-notebook-snapshot-model:/home/east/shared/eastSync/pyEast/pro_version/simple_feature_test.ipynb?%7B%22sessionId%22%3A%22f2e62d2c-77c9-4883-ab60-40b4656f2b16%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%2C%22viewType%22%3A%22jupyter-notebook%22%7D","telemetryInfo":{"requestId":"request_0bf0ab4d-1842-49d0-a6f4-d31ded4ca8e2","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}},{"resource":"file:///home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb","languageId":"VSCodeChatNotebookSnapshotLanguage","originalHash":"e4dcd29","currentHash":"6c71bd6","state":1,"snapshotUri":"chat-editing-notebook-snapshot-model:/home/east/shared/eastSync/pyEast/pro_version/targeting_volatility.ipynb?%7B%22sessionId%22%3A%22f2e62d2c-77c9-4883-ab60-40b4656f2b16%22%2C%22requestId%22%3A%22%22%2C%22undoStop%22%3A%22%22%2C%22viewType%22%3A%22jupyter-notebook%22%7D","telemetryInfo":{"requestId":"request_3964bb12-351a-4ec5-81d8-8a8c6d0e69b8","agentId":"github.copilot.editsAgent","modelId":"copilot/claude-sonnet-4.5","modeId":"agent"}}]}}